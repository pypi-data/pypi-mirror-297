# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

import numpy as np
import sys
import typing

if sys.version_info[0] < 3:
    from importlib_metadata import version
else:   
    from importlib.metadata import version

try:
    __version__ = version(__package__ or __name__)
except:
    __version__ = "0.0.0"


from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _tttrlib
else:
    import _tttrlib

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

RECORD_PHOTON = _tttrlib.RECORD_PHOTON

RECORD_MARKER = _tttrlib.RECORD_MARKER

class SwigPyIterator(object):
    r"""Proxy of C++ swig::SwigPyIterator class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _tttrlib.delete_SwigPyIterator

    def value(self):
        r"""value(self) -> PyObject *"""
        return _tttrlib.SwigPyIterator_value(self)

    def incr(self, n=1):
        r"""
        incr(self, n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _tttrlib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        r"""
        decr(self, n=1) -> SwigPyIterator

        Parameters
        ----------
        n: size_t

        """
        return _tttrlib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        r"""
        distance(self, x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _tttrlib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        r"""
        equal(self, x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _tttrlib.SwigPyIterator_equal(self, x)

    def copy(self):
        r"""copy(self) -> SwigPyIterator"""
        return _tttrlib.SwigPyIterator_copy(self)

    def next(self):
        r"""next(self) -> PyObject *"""
        return _tttrlib.SwigPyIterator_next(self)

    def __next__(self):
        r"""__next__(self) -> PyObject *"""
        return _tttrlib.SwigPyIterator___next__(self)

    def previous(self):
        r"""previous(self) -> PyObject *"""
        return _tttrlib.SwigPyIterator_previous(self)

    def advance(self, n):
        r"""
        advance(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _tttrlib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        r"""
        __eq__(self, x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _tttrlib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        r"""
        __ne__(self, x) -> bool

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _tttrlib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        r"""
        __iadd__(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _tttrlib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        r"""
        __isub__(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _tttrlib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        r"""
        __add__(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        """
        return _tttrlib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        r"""
        __sub__(self, n) -> SwigPyIterator

        Parameters
        ----------
        n: ptrdiff_t

        __sub__(self, x) -> ptrdiff_t

        Parameters
        ----------
        x: swig::SwigPyIterator const &

        """
        return _tttrlib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _tttrlib:
_tttrlib.SwigPyIterator_swigregister(SwigPyIterator)
SHARED_PTR_DISOWN = _tttrlib.SHARED_PTR_DISOWN

class SetInt32(object):
    r"""Proxy of C++ std::set< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.SetInt32_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.SetInt32___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.SetInt32___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::set< int >::size_type"""
        return _tttrlib.SetInt32___len__(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::set< int >::value_type

        """
        return _tttrlib.SetInt32_append(self, x)

    def __contains__(self, x):
        r"""
        __contains__(self, x) -> bool

        Parameters
        ----------
        x: std::set< int >::value_type

        """
        return _tttrlib.SetInt32___contains__(self, x)

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> std::set< int >::value_type

        Parameters
        ----------
        i: std::set< int >::difference_type

        """
        return _tttrlib.SetInt32___getitem__(self, i)

    def add(self, x):
        r"""
        add(self, x)

        Parameters
        ----------
        x: std::set< int >::value_type

        """
        return _tttrlib.SetInt32_add(self, x)

    def discard(self, x):
        r"""
        discard(self, x)

        Parameters
        ----------
        x: std::set< int >::value_type

        """
        return _tttrlib.SetInt32_discard(self, x)

    def __init__(self, *args):
        r"""
        __init__(self, other) -> SetInt32

        Parameters
        ----------
        other: std::less< int > const &

        __init__(self) -> SetInt32
        __init__(self, other) -> SetInt32

        Parameters
        ----------
        other: std::set< int > const &

        """
        _tttrlib.SetInt32_swiginit(self, _tttrlib.new_SetInt32(*args))

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.SetInt32_empty(self)

    def size(self):
        r"""size(self) -> std::set< int >::size_type"""
        return _tttrlib.SetInt32_size(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.SetInt32_clear(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::set< int > &

        """
        return _tttrlib.SetInt32_swap(self, v)

    def count(self, x):
        r"""
        count(self, x) -> std::set< int >::size_type

        Parameters
        ----------
        x: std::set< int >::key_type const &

        """
        return _tttrlib.SetInt32_count(self, x)

    def begin(self):
        r"""begin(self) -> std::set< int >::iterator"""
        return _tttrlib.SetInt32_begin(self)

    def end(self):
        r"""end(self) -> std::set< int >::iterator"""
        return _tttrlib.SetInt32_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::set< int >::reverse_iterator"""
        return _tttrlib.SetInt32_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::set< int >::reverse_iterator"""
        return _tttrlib.SetInt32_rend(self)

    def erase(self, *args):
        r"""
        erase(self, x) -> std::set< int >::size_type

        Parameters
        ----------
        x: std::set< int >::key_type const &

        erase(self, pos)

        Parameters
        ----------
        pos: std::set< int >::iterator

        erase(self, first, last)

        Parameters
        ----------
        first: std::set< int >::iterator
        last: std::set< int >::iterator

        """
        return _tttrlib.SetInt32_erase(self, *args)

    def find(self, x):
        r"""
        find(self, x) -> std::set< int >::iterator

        Parameters
        ----------
        x: std::set< int >::key_type const &

        """
        return _tttrlib.SetInt32_find(self, x)

    def lower_bound(self, x):
        r"""
        lower_bound(self, x) -> std::set< int >::iterator

        Parameters
        ----------
        x: std::set< int >::key_type const &

        """
        return _tttrlib.SetInt32_lower_bound(self, x)

    def upper_bound(self, x):
        r"""
        upper_bound(self, x) -> std::set< int >::iterator

        Parameters
        ----------
        x: std::set< int >::key_type const &

        """
        return _tttrlib.SetInt32_upper_bound(self, x)

    def equal_range(self, x):
        r"""
        equal_range(self, x) -> std::pair< std::set< int >::iterator,std::set< int >::iterator >

        Parameters
        ----------
        x: std::set< int >::key_type const &

        """
        return _tttrlib.SetInt32_equal_range(self, x)

    def insert(self, __x):
        r"""
        insert(self, __x) -> std::pair< std::set< int >::iterator,bool >

        Parameters
        ----------
        __x: std::set< int >::value_type const &

        """
        return _tttrlib.SetInt32_insert(self, __x)
    __swig_destroy__ = _tttrlib.delete_SetInt32

# Register SetInt32 in _tttrlib:
_tttrlib.SetInt32_swigregister(SetInt32)
class VectorBool(object):
    r"""Proxy of C++ std::vector< bool > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.VectorBool_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.VectorBool___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.VectorBool___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< bool >::size_type"""
        return _tttrlib.VectorBool___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> VectorBool

        Parameters
        ----------
        i: std::vector< bool >::difference_type
        j: std::vector< bool >::difference_type

        """
        return _tttrlib.VectorBool___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< bool >::difference_type
        j: std::vector< bool >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< bool >::difference_type
        j: std::vector< bool >::difference_type
        v: std::vector< bool,std::allocator< bool > > const &

        """
        return _tttrlib.VectorBool___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< bool >::difference_type
        j: std::vector< bool >::difference_type

        """
        return _tttrlib.VectorBool___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< bool >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _tttrlib.VectorBool___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> VectorBool

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(self, i) -> std::vector< bool >::value_type

        Parameters
        ----------
        i: std::vector< bool >::difference_type

        """
        return _tttrlib.VectorBool___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< bool,std::allocator< bool > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< bool >::difference_type
        x: std::vector< bool >::value_type

        """
        return _tttrlib.VectorBool___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< bool >::value_type"""
        return _tttrlib.VectorBool_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< bool >::value_type

        """
        return _tttrlib.VectorBool_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.VectorBool_empty(self)

    def size(self):
        r"""size(self) -> std::vector< bool >::size_type"""
        return _tttrlib.VectorBool_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< bool > &

        """
        return _tttrlib.VectorBool_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< bool >::iterator"""
        return _tttrlib.VectorBool_begin(self)

    def end(self):
        r"""end(self) -> std::vector< bool >::iterator"""
        return _tttrlib.VectorBool_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< bool >::reverse_iterator"""
        return _tttrlib.VectorBool_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< bool >::reverse_iterator"""
        return _tttrlib.VectorBool_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.VectorBool_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< bool >::allocator_type"""
        return _tttrlib.VectorBool_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _tttrlib.VectorBool_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< bool >::iterator

        Parameters
        ----------
        pos: std::vector< bool >::iterator

        erase(self, first, last) -> std::vector< bool >::iterator

        Parameters
        ----------
        first: std::vector< bool >::iterator
        last: std::vector< bool >::iterator

        """
        return _tttrlib.VectorBool_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> VectorBool
        __init__(self, other) -> VectorBool

        Parameters
        ----------
        other: std::vector< bool > const &

        __init__(self, size) -> VectorBool

        Parameters
        ----------
        size: std::vector< bool >::size_type

        __init__(self, size, value) -> VectorBool

        Parameters
        ----------
        size: std::vector< bool >::size_type
        value: std::vector< bool >::value_type

        """
        _tttrlib.VectorBool_swiginit(self, _tttrlib.new_VectorBool(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< bool >::value_type

        """
        return _tttrlib.VectorBool_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< bool >::value_type"""
        return _tttrlib.VectorBool_front(self)

    def back(self):
        r"""back(self) -> std::vector< bool >::value_type"""
        return _tttrlib.VectorBool_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< bool >::size_type
        x: std::vector< bool >::value_type

        """
        return _tttrlib.VectorBool_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< bool >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< bool >::size_type
        x: std::vector< bool >::value_type

        """
        return _tttrlib.VectorBool_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< bool >::iterator

        Parameters
        ----------
        pos: std::vector< bool >::iterator
        x: std::vector< bool >::value_type

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< bool >::iterator
        n: std::vector< bool >::size_type
        x: std::vector< bool >::value_type

        """
        return _tttrlib.VectorBool_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< bool >::size_type

        """
        return _tttrlib.VectorBool_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< bool >::size_type"""
        return _tttrlib.VectorBool_capacity(self)
    __swig_destroy__ = _tttrlib.delete_VectorBool

# Register VectorBool in _tttrlib:
_tttrlib.VectorBool_swigregister(VectorBool)
class VectorDouble(object):
    r"""Proxy of C++ std::vector< double > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.VectorDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.VectorDouble___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.VectorDouble___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< double >::size_type"""
        return _tttrlib.VectorDouble___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> VectorDouble

        Parameters
        ----------
        i: std::vector< double >::difference_type
        j: std::vector< double >::difference_type

        """
        return _tttrlib.VectorDouble___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< double >::difference_type
        j: std::vector< double >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< double >::difference_type
        j: std::vector< double >::difference_type
        v: std::vector< double,std::allocator< double > > const &

        """
        return _tttrlib.VectorDouble___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< double >::difference_type
        j: std::vector< double >::difference_type

        """
        return _tttrlib.VectorDouble___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< double >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _tttrlib.VectorDouble___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> VectorDouble

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(self, i) -> std::vector< double >::value_type const &

        Parameters
        ----------
        i: std::vector< double >::difference_type

        """
        return _tttrlib.VectorDouble___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< double,std::allocator< double > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< double >::difference_type
        x: std::vector< double >::value_type const &

        """
        return _tttrlib.VectorDouble___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< double >::value_type"""
        return _tttrlib.VectorDouble_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< double >::value_type const &

        """
        return _tttrlib.VectorDouble_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.VectorDouble_empty(self)

    def size(self):
        r"""size(self) -> std::vector< double >::size_type"""
        return _tttrlib.VectorDouble_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< double > &

        """
        return _tttrlib.VectorDouble_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< double >::iterator"""
        return _tttrlib.VectorDouble_begin(self)

    def end(self):
        r"""end(self) -> std::vector< double >::iterator"""
        return _tttrlib.VectorDouble_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< double >::reverse_iterator"""
        return _tttrlib.VectorDouble_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< double >::reverse_iterator"""
        return _tttrlib.VectorDouble_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.VectorDouble_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< double >::allocator_type"""
        return _tttrlib.VectorDouble_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _tttrlib.VectorDouble_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< double >::iterator

        Parameters
        ----------
        pos: std::vector< double >::iterator

        erase(self, first, last) -> std::vector< double >::iterator

        Parameters
        ----------
        first: std::vector< double >::iterator
        last: std::vector< double >::iterator

        """
        return _tttrlib.VectorDouble_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> VectorDouble
        __init__(self, other) -> VectorDouble

        Parameters
        ----------
        other: std::vector< double > const &

        __init__(self, size) -> VectorDouble

        Parameters
        ----------
        size: std::vector< double >::size_type

        __init__(self, size, value) -> VectorDouble

        Parameters
        ----------
        size: std::vector< double >::size_type
        value: std::vector< double >::value_type const &

        """
        _tttrlib.VectorDouble_swiginit(self, _tttrlib.new_VectorDouble(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< double >::value_type const &

        """
        return _tttrlib.VectorDouble_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< double >::value_type const &"""
        return _tttrlib.VectorDouble_front(self)

    def back(self):
        r"""back(self) -> std::vector< double >::value_type const &"""
        return _tttrlib.VectorDouble_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< double >::size_type
        x: std::vector< double >::value_type const &

        """
        return _tttrlib.VectorDouble_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< double >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< double >::size_type
        x: std::vector< double >::value_type const &

        """
        return _tttrlib.VectorDouble_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< double >::iterator

        Parameters
        ----------
        pos: std::vector< double >::iterator
        x: std::vector< double >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< double >::iterator
        n: std::vector< double >::size_type
        x: std::vector< double >::value_type const &

        """
        return _tttrlib.VectorDouble_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< double >::size_type

        """
        return _tttrlib.VectorDouble_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< double >::size_type"""
        return _tttrlib.VectorDouble_capacity(self)
    __swig_destroy__ = _tttrlib.delete_VectorDouble

# Register VectorDouble in _tttrlib:
_tttrlib.VectorDouble_swigregister(VectorDouble)
class VectorInt16(object):
    r"""Proxy of C++ std::vector< short > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.VectorInt16_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.VectorInt16___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.VectorInt16___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< short >::size_type"""
        return _tttrlib.VectorInt16___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> VectorInt16

        Parameters
        ----------
        i: std::vector< short >::difference_type
        j: std::vector< short >::difference_type

        """
        return _tttrlib.VectorInt16___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< short >::difference_type
        j: std::vector< short >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< short >::difference_type
        j: std::vector< short >::difference_type
        v: std::vector< short,std::allocator< short > > const &

        """
        return _tttrlib.VectorInt16___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< short >::difference_type
        j: std::vector< short >::difference_type

        """
        return _tttrlib.VectorInt16___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< short >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _tttrlib.VectorInt16___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> VectorInt16

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(self, i) -> std::vector< short >::value_type const &

        Parameters
        ----------
        i: std::vector< short >::difference_type

        """
        return _tttrlib.VectorInt16___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< short,std::allocator< short > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< short >::difference_type
        x: std::vector< short >::value_type const &

        """
        return _tttrlib.VectorInt16___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< short >::value_type"""
        return _tttrlib.VectorInt16_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< short >::value_type const &

        """
        return _tttrlib.VectorInt16_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.VectorInt16_empty(self)

    def size(self):
        r"""size(self) -> std::vector< short >::size_type"""
        return _tttrlib.VectorInt16_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< short > &

        """
        return _tttrlib.VectorInt16_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< short >::iterator"""
        return _tttrlib.VectorInt16_begin(self)

    def end(self):
        r"""end(self) -> std::vector< short >::iterator"""
        return _tttrlib.VectorInt16_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< short >::reverse_iterator"""
        return _tttrlib.VectorInt16_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< short >::reverse_iterator"""
        return _tttrlib.VectorInt16_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.VectorInt16_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< short >::allocator_type"""
        return _tttrlib.VectorInt16_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _tttrlib.VectorInt16_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< short >::iterator

        Parameters
        ----------
        pos: std::vector< short >::iterator

        erase(self, first, last) -> std::vector< short >::iterator

        Parameters
        ----------
        first: std::vector< short >::iterator
        last: std::vector< short >::iterator

        """
        return _tttrlib.VectorInt16_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> VectorInt16
        __init__(self, other) -> VectorInt16

        Parameters
        ----------
        other: std::vector< short > const &

        __init__(self, size) -> VectorInt16

        Parameters
        ----------
        size: std::vector< short >::size_type

        __init__(self, size, value) -> VectorInt16

        Parameters
        ----------
        size: std::vector< short >::size_type
        value: std::vector< short >::value_type const &

        """
        _tttrlib.VectorInt16_swiginit(self, _tttrlib.new_VectorInt16(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< short >::value_type const &

        """
        return _tttrlib.VectorInt16_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< short >::value_type const &"""
        return _tttrlib.VectorInt16_front(self)

    def back(self):
        r"""back(self) -> std::vector< short >::value_type const &"""
        return _tttrlib.VectorInt16_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< short >::size_type
        x: std::vector< short >::value_type const &

        """
        return _tttrlib.VectorInt16_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< short >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< short >::size_type
        x: std::vector< short >::value_type const &

        """
        return _tttrlib.VectorInt16_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< short >::iterator

        Parameters
        ----------
        pos: std::vector< short >::iterator
        x: std::vector< short >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< short >::iterator
        n: std::vector< short >::size_type
        x: std::vector< short >::value_type const &

        """
        return _tttrlib.VectorInt16_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< short >::size_type

        """
        return _tttrlib.VectorInt16_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< short >::size_type"""
        return _tttrlib.VectorInt16_capacity(self)
    __swig_destroy__ = _tttrlib.delete_VectorInt16

# Register VectorInt16 in _tttrlib:
_tttrlib.VectorInt16_swigregister(VectorInt16)
class VectorInt32(object):
    r"""Proxy of C++ std::vector< int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.VectorInt32_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.VectorInt32___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.VectorInt32___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< int >::size_type"""
        return _tttrlib.VectorInt32___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> VectorInt32

        Parameters
        ----------
        i: std::vector< int >::difference_type
        j: std::vector< int >::difference_type

        """
        return _tttrlib.VectorInt32___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< int >::difference_type
        j: std::vector< int >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< int >::difference_type
        j: std::vector< int >::difference_type
        v: std::vector< int,std::allocator< int > > const &

        """
        return _tttrlib.VectorInt32___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< int >::difference_type
        j: std::vector< int >::difference_type

        """
        return _tttrlib.VectorInt32___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< int >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _tttrlib.VectorInt32___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> VectorInt32

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(self, i) -> std::vector< int >::value_type const &

        Parameters
        ----------
        i: std::vector< int >::difference_type

        """
        return _tttrlib.VectorInt32___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< int,std::allocator< int > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< int >::difference_type
        x: std::vector< int >::value_type const &

        """
        return _tttrlib.VectorInt32___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< int >::value_type"""
        return _tttrlib.VectorInt32_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< int >::value_type const &

        """
        return _tttrlib.VectorInt32_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.VectorInt32_empty(self)

    def size(self):
        r"""size(self) -> std::vector< int >::size_type"""
        return _tttrlib.VectorInt32_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< int > &

        """
        return _tttrlib.VectorInt32_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< int >::iterator"""
        return _tttrlib.VectorInt32_begin(self)

    def end(self):
        r"""end(self) -> std::vector< int >::iterator"""
        return _tttrlib.VectorInt32_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< int >::reverse_iterator"""
        return _tttrlib.VectorInt32_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< int >::reverse_iterator"""
        return _tttrlib.VectorInt32_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.VectorInt32_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< int >::allocator_type"""
        return _tttrlib.VectorInt32_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _tttrlib.VectorInt32_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< int >::iterator

        Parameters
        ----------
        pos: std::vector< int >::iterator

        erase(self, first, last) -> std::vector< int >::iterator

        Parameters
        ----------
        first: std::vector< int >::iterator
        last: std::vector< int >::iterator

        """
        return _tttrlib.VectorInt32_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> VectorInt32
        __init__(self, other) -> VectorInt32

        Parameters
        ----------
        other: std::vector< int > const &

        __init__(self, size) -> VectorInt32

        Parameters
        ----------
        size: std::vector< int >::size_type

        __init__(self, size, value) -> VectorInt32

        Parameters
        ----------
        size: std::vector< int >::size_type
        value: std::vector< int >::value_type const &

        """
        _tttrlib.VectorInt32_swiginit(self, _tttrlib.new_VectorInt32(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< int >::value_type const &

        """
        return _tttrlib.VectorInt32_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< int >::value_type const &"""
        return _tttrlib.VectorInt32_front(self)

    def back(self):
        r"""back(self) -> std::vector< int >::value_type const &"""
        return _tttrlib.VectorInt32_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< int >::size_type
        x: std::vector< int >::value_type const &

        """
        return _tttrlib.VectorInt32_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< int >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< int >::size_type
        x: std::vector< int >::value_type const &

        """
        return _tttrlib.VectorInt32_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< int >::iterator

        Parameters
        ----------
        pos: std::vector< int >::iterator
        x: std::vector< int >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< int >::iterator
        n: std::vector< int >::size_type
        x: std::vector< int >::value_type const &

        """
        return _tttrlib.VectorInt32_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< int >::size_type

        """
        return _tttrlib.VectorInt32_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< int >::size_type"""
        return _tttrlib.VectorInt32_capacity(self)
    __swig_destroy__ = _tttrlib.delete_VectorInt32

# Register VectorInt32 in _tttrlib:
_tttrlib.VectorInt32_swigregister(VectorInt32)
class VectorInt64(object):
    r"""Proxy of C++ std::vector< long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.VectorInt64_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.VectorInt64___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.VectorInt64___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< long long >::size_type"""
        return _tttrlib.VectorInt64___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> VectorInt64

        Parameters
        ----------
        i: std::vector< long long >::difference_type
        j: std::vector< long long >::difference_type

        """
        return _tttrlib.VectorInt64___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< long long >::difference_type
        j: std::vector< long long >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< long long >::difference_type
        j: std::vector< long long >::difference_type
        v: std::vector< long long,std::allocator< long long > > const &

        """
        return _tttrlib.VectorInt64___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< long long >::difference_type
        j: std::vector< long long >::difference_type

        """
        return _tttrlib.VectorInt64___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< long long >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _tttrlib.VectorInt64___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> VectorInt64

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(self, i) -> std::vector< long long >::value_type const &

        Parameters
        ----------
        i: std::vector< long long >::difference_type

        """
        return _tttrlib.VectorInt64___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< long long,std::allocator< long long > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< long long >::difference_type
        x: std::vector< long long >::value_type const &

        """
        return _tttrlib.VectorInt64___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< long long >::value_type"""
        return _tttrlib.VectorInt64_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< long long >::value_type const &

        """
        return _tttrlib.VectorInt64_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.VectorInt64_empty(self)

    def size(self):
        r"""size(self) -> std::vector< long long >::size_type"""
        return _tttrlib.VectorInt64_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< long long > &

        """
        return _tttrlib.VectorInt64_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< long long >::iterator"""
        return _tttrlib.VectorInt64_begin(self)

    def end(self):
        r"""end(self) -> std::vector< long long >::iterator"""
        return _tttrlib.VectorInt64_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< long long >::reverse_iterator"""
        return _tttrlib.VectorInt64_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< long long >::reverse_iterator"""
        return _tttrlib.VectorInt64_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.VectorInt64_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< long long >::allocator_type"""
        return _tttrlib.VectorInt64_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _tttrlib.VectorInt64_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< long long >::iterator

        Parameters
        ----------
        pos: std::vector< long long >::iterator

        erase(self, first, last) -> std::vector< long long >::iterator

        Parameters
        ----------
        first: std::vector< long long >::iterator
        last: std::vector< long long >::iterator

        """
        return _tttrlib.VectorInt64_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> VectorInt64
        __init__(self, other) -> VectorInt64

        Parameters
        ----------
        other: std::vector< long long > const &

        __init__(self, size) -> VectorInt64

        Parameters
        ----------
        size: std::vector< long long >::size_type

        __init__(self, size, value) -> VectorInt64

        Parameters
        ----------
        size: std::vector< long long >::size_type
        value: std::vector< long long >::value_type const &

        """
        _tttrlib.VectorInt64_swiginit(self, _tttrlib.new_VectorInt64(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< long long >::value_type const &

        """
        return _tttrlib.VectorInt64_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< long long >::value_type const &"""
        return _tttrlib.VectorInt64_front(self)

    def back(self):
        r"""back(self) -> std::vector< long long >::value_type const &"""
        return _tttrlib.VectorInt64_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< long long >::size_type
        x: std::vector< long long >::value_type const &

        """
        return _tttrlib.VectorInt64_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< long long >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< long long >::size_type
        x: std::vector< long long >::value_type const &

        """
        return _tttrlib.VectorInt64_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< long long >::iterator

        Parameters
        ----------
        pos: std::vector< long long >::iterator
        x: std::vector< long long >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< long long >::iterator
        n: std::vector< long long >::size_type
        x: std::vector< long long >::value_type const &

        """
        return _tttrlib.VectorInt64_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< long long >::size_type

        """
        return _tttrlib.VectorInt64_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< long long >::size_type"""
        return _tttrlib.VectorInt64_capacity(self)
    __swig_destroy__ = _tttrlib.delete_VectorInt64

# Register VectorInt64 in _tttrlib:
_tttrlib.VectorInt64_swigregister(VectorInt64)
class VectorUint32(object):
    r"""Proxy of C++ std::vector< unsigned int > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.VectorUint32_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.VectorUint32___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.VectorUint32___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< unsigned int >::size_type"""
        return _tttrlib.VectorUint32___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> VectorUint32

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        j: std::vector< unsigned int >::difference_type

        """
        return _tttrlib.VectorUint32___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        j: std::vector< unsigned int >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        j: std::vector< unsigned int >::difference_type
        v: std::vector< unsigned int,std::allocator< unsigned int > > const &

        """
        return _tttrlib.VectorUint32___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        j: std::vector< unsigned int >::difference_type

        """
        return _tttrlib.VectorUint32___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _tttrlib.VectorUint32___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> VectorUint32

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(self, i) -> std::vector< unsigned int >::value_type const &

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type

        """
        return _tttrlib.VectorUint32___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< unsigned int,std::allocator< unsigned int > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< unsigned int >::difference_type
        x: std::vector< unsigned int >::value_type const &

        """
        return _tttrlib.VectorUint32___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< unsigned int >::value_type"""
        return _tttrlib.VectorUint32_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< unsigned int >::value_type const &

        """
        return _tttrlib.VectorUint32_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.VectorUint32_empty(self)

    def size(self):
        r"""size(self) -> std::vector< unsigned int >::size_type"""
        return _tttrlib.VectorUint32_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< unsigned int > &

        """
        return _tttrlib.VectorUint32_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< unsigned int >::iterator"""
        return _tttrlib.VectorUint32_begin(self)

    def end(self):
        r"""end(self) -> std::vector< unsigned int >::iterator"""
        return _tttrlib.VectorUint32_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< unsigned int >::reverse_iterator"""
        return _tttrlib.VectorUint32_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< unsigned int >::reverse_iterator"""
        return _tttrlib.VectorUint32_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.VectorUint32_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< unsigned int >::allocator_type"""
        return _tttrlib.VectorUint32_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _tttrlib.VectorUint32_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< unsigned int >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned int >::iterator

        erase(self, first, last) -> std::vector< unsigned int >::iterator

        Parameters
        ----------
        first: std::vector< unsigned int >::iterator
        last: std::vector< unsigned int >::iterator

        """
        return _tttrlib.VectorUint32_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> VectorUint32
        __init__(self, other) -> VectorUint32

        Parameters
        ----------
        other: std::vector< unsigned int > const &

        __init__(self, size) -> VectorUint32

        Parameters
        ----------
        size: std::vector< unsigned int >::size_type

        __init__(self, size, value) -> VectorUint32

        Parameters
        ----------
        size: std::vector< unsigned int >::size_type
        value: std::vector< unsigned int >::value_type const &

        """
        _tttrlib.VectorUint32_swiginit(self, _tttrlib.new_VectorUint32(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< unsigned int >::value_type const &

        """
        return _tttrlib.VectorUint32_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< unsigned int >::value_type const &"""
        return _tttrlib.VectorUint32_front(self)

    def back(self):
        r"""back(self) -> std::vector< unsigned int >::value_type const &"""
        return _tttrlib.VectorUint32_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< unsigned int >::size_type
        x: std::vector< unsigned int >::value_type const &

        """
        return _tttrlib.VectorUint32_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< unsigned int >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< unsigned int >::size_type
        x: std::vector< unsigned int >::value_type const &

        """
        return _tttrlib.VectorUint32_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< unsigned int >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned int >::iterator
        x: std::vector< unsigned int >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< unsigned int >::iterator
        n: std::vector< unsigned int >::size_type
        x: std::vector< unsigned int >::value_type const &

        """
        return _tttrlib.VectorUint32_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< unsigned int >::size_type

        """
        return _tttrlib.VectorUint32_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< unsigned int >::size_type"""
        return _tttrlib.VectorUint32_capacity(self)
    __swig_destroy__ = _tttrlib.delete_VectorUint32

# Register VectorUint32 in _tttrlib:
_tttrlib.VectorUint32_swigregister(VectorUint32)
class VectorUint64(object):
    r"""Proxy of C++ std::vector< unsigned long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.VectorUint64_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.VectorUint64___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.VectorUint64___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< unsigned long >::size_type"""
        return _tttrlib.VectorUint64___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> VectorUint64

        Parameters
        ----------
        i: std::vector< unsigned long >::difference_type
        j: std::vector< unsigned long >::difference_type

        """
        return _tttrlib.VectorUint64___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< unsigned long >::difference_type
        j: std::vector< unsigned long >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< unsigned long >::difference_type
        j: std::vector< unsigned long >::difference_type
        v: std::vector< unsigned long,std::allocator< unsigned long > > const &

        """
        return _tttrlib.VectorUint64___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< unsigned long >::difference_type
        j: std::vector< unsigned long >::difference_type

        """
        return _tttrlib.VectorUint64___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< unsigned long >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _tttrlib.VectorUint64___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> VectorUint64

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(self, i) -> std::vector< unsigned long >::value_type const &

        Parameters
        ----------
        i: std::vector< unsigned long >::difference_type

        """
        return _tttrlib.VectorUint64___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< unsigned long,std::allocator< unsigned long > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< unsigned long >::difference_type
        x: std::vector< unsigned long >::value_type const &

        """
        return _tttrlib.VectorUint64___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< unsigned long >::value_type"""
        return _tttrlib.VectorUint64_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< unsigned long >::value_type const &

        """
        return _tttrlib.VectorUint64_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.VectorUint64_empty(self)

    def size(self):
        r"""size(self) -> std::vector< unsigned long >::size_type"""
        return _tttrlib.VectorUint64_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< unsigned long > &

        """
        return _tttrlib.VectorUint64_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< unsigned long >::iterator"""
        return _tttrlib.VectorUint64_begin(self)

    def end(self):
        r"""end(self) -> std::vector< unsigned long >::iterator"""
        return _tttrlib.VectorUint64_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< unsigned long >::reverse_iterator"""
        return _tttrlib.VectorUint64_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< unsigned long >::reverse_iterator"""
        return _tttrlib.VectorUint64_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.VectorUint64_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< unsigned long >::allocator_type"""
        return _tttrlib.VectorUint64_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _tttrlib.VectorUint64_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< unsigned long >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned long >::iterator

        erase(self, first, last) -> std::vector< unsigned long >::iterator

        Parameters
        ----------
        first: std::vector< unsigned long >::iterator
        last: std::vector< unsigned long >::iterator

        """
        return _tttrlib.VectorUint64_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> VectorUint64
        __init__(self, other) -> VectorUint64

        Parameters
        ----------
        other: std::vector< unsigned long > const &

        __init__(self, size) -> VectorUint64

        Parameters
        ----------
        size: std::vector< unsigned long >::size_type

        __init__(self, size, value) -> VectorUint64

        Parameters
        ----------
        size: std::vector< unsigned long >::size_type
        value: std::vector< unsigned long >::value_type const &

        """
        _tttrlib.VectorUint64_swiginit(self, _tttrlib.new_VectorUint64(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< unsigned long >::value_type const &

        """
        return _tttrlib.VectorUint64_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< unsigned long >::value_type const &"""
        return _tttrlib.VectorUint64_front(self)

    def back(self):
        r"""back(self) -> std::vector< unsigned long >::value_type const &"""
        return _tttrlib.VectorUint64_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< unsigned long >::size_type
        x: std::vector< unsigned long >::value_type const &

        """
        return _tttrlib.VectorUint64_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< unsigned long >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< unsigned long >::size_type
        x: std::vector< unsigned long >::value_type const &

        """
        return _tttrlib.VectorUint64_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< unsigned long >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned long >::iterator
        x: std::vector< unsigned long >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< unsigned long >::iterator
        n: std::vector< unsigned long >::size_type
        x: std::vector< unsigned long >::value_type const &

        """
        return _tttrlib.VectorUint64_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< unsigned long >::size_type

        """
        return _tttrlib.VectorUint64_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< unsigned long >::size_type"""
        return _tttrlib.VectorUint64_capacity(self)
    __swig_destroy__ = _tttrlib.delete_VectorUint64

# Register VectorUint64 in _tttrlib:
_tttrlib.VectorUint64_swigregister(VectorUint64)
class VectorUint128(object):
    r"""Proxy of C++ std::vector< unsigned long long > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.VectorUint128_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.VectorUint128___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.VectorUint128___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< unsigned long long >::size_type"""
        return _tttrlib.VectorUint128___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> VectorUint128

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type

        """
        return _tttrlib.VectorUint128___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type
        v: std::vector< unsigned long long,std::allocator< unsigned long long > > const &

        """
        return _tttrlib.VectorUint128___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        j: std::vector< unsigned long long >::difference_type

        """
        return _tttrlib.VectorUint128___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _tttrlib.VectorUint128___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> VectorUint128

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(self, i) -> std::vector< unsigned long long >::value_type const &

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type

        """
        return _tttrlib.VectorUint128___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< unsigned long long,std::allocator< unsigned long long > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< unsigned long long >::difference_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _tttrlib.VectorUint128___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< unsigned long long >::value_type"""
        return _tttrlib.VectorUint128_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< unsigned long long >::value_type const &

        """
        return _tttrlib.VectorUint128_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.VectorUint128_empty(self)

    def size(self):
        r"""size(self) -> std::vector< unsigned long long >::size_type"""
        return _tttrlib.VectorUint128_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< unsigned long long > &

        """
        return _tttrlib.VectorUint128_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< unsigned long long >::iterator"""
        return _tttrlib.VectorUint128_begin(self)

    def end(self):
        r"""end(self) -> std::vector< unsigned long long >::iterator"""
        return _tttrlib.VectorUint128_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< unsigned long long >::reverse_iterator"""
        return _tttrlib.VectorUint128_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< unsigned long long >::reverse_iterator"""
        return _tttrlib.VectorUint128_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.VectorUint128_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< unsigned long long >::allocator_type"""
        return _tttrlib.VectorUint128_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _tttrlib.VectorUint128_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< unsigned long long >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned long long >::iterator

        erase(self, first, last) -> std::vector< unsigned long long >::iterator

        Parameters
        ----------
        first: std::vector< unsigned long long >::iterator
        last: std::vector< unsigned long long >::iterator

        """
        return _tttrlib.VectorUint128_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> VectorUint128
        __init__(self, other) -> VectorUint128

        Parameters
        ----------
        other: std::vector< unsigned long long > const &

        __init__(self, size) -> VectorUint128

        Parameters
        ----------
        size: std::vector< unsigned long long >::size_type

        __init__(self, size, value) -> VectorUint128

        Parameters
        ----------
        size: std::vector< unsigned long long >::size_type
        value: std::vector< unsigned long long >::value_type const &

        """
        _tttrlib.VectorUint128_swiginit(self, _tttrlib.new_VectorUint128(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< unsigned long long >::value_type const &

        """
        return _tttrlib.VectorUint128_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< unsigned long long >::value_type const &"""
        return _tttrlib.VectorUint128_front(self)

    def back(self):
        r"""back(self) -> std::vector< unsigned long long >::value_type const &"""
        return _tttrlib.VectorUint128_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< unsigned long long >::size_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _tttrlib.VectorUint128_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< unsigned long long >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< unsigned long long >::size_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _tttrlib.VectorUint128_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< unsigned long long >::iterator

        Parameters
        ----------
        pos: std::vector< unsigned long long >::iterator
        x: std::vector< unsigned long long >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< unsigned long long >::iterator
        n: std::vector< unsigned long long >::size_type
        x: std::vector< unsigned long long >::value_type const &

        """
        return _tttrlib.VectorUint128_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< unsigned long long >::size_type

        """
        return _tttrlib.VectorUint128_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< unsigned long long >::size_type"""
        return _tttrlib.VectorUint128_capacity(self)
    __swig_destroy__ = _tttrlib.delete_VectorUint128

# Register VectorUint128 in _tttrlib:
_tttrlib.VectorUint128_swigregister(VectorUint128)
class VectorUint32_3D(object):
    r"""Proxy of C++ std::vector< std::vector< std::vector< unsigned int > > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.VectorUint32_3D_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.VectorUint32_3D___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.VectorUint32_3D___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::vector< std::vector< unsigned int > > >::size_type"""
        return _tttrlib.VectorUint32_3D___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> VectorUint32_3D

        Parameters
        ----------
        i: std::vector< std::vector< std::vector< unsigned int > > >::difference_type
        j: std::vector< std::vector< std::vector< unsigned int > > >::difference_type

        """
        return _tttrlib.VectorUint32_3D___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< std::vector< unsigned int > > >::difference_type
        j: std::vector< std::vector< std::vector< unsigned int > > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::vector< std::vector< unsigned int > > >::difference_type
        j: std::vector< std::vector< std::vector< unsigned int > > >::difference_type
        v: std::vector< std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > >,std::allocator< std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > > > const &

        """
        return _tttrlib.VectorUint32_3D___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< std::vector< unsigned int > > >::difference_type
        j: std::vector< std::vector< std::vector< unsigned int > > >::difference_type

        """
        return _tttrlib.VectorUint32_3D___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::vector< std::vector< unsigned int > > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _tttrlib.VectorUint32_3D___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> VectorUint32_3D

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(self, i) -> std::vector< std::vector< std::vector< unsigned int > > >::value_type const &

        Parameters
        ----------
        i: std::vector< std::vector< std::vector< unsigned int > > >::difference_type

        """
        return _tttrlib.VectorUint32_3D___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > >,std::allocator< std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::vector< std::vector< unsigned int > > >::difference_type
        x: std::vector< std::vector< std::vector< unsigned int > > >::value_type const &

        """
        return _tttrlib.VectorUint32_3D___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< std::vector< std::vector< unsigned int > > >::value_type"""
        return _tttrlib.VectorUint32_3D_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< std::vector< unsigned int > > >::value_type const &

        """
        return _tttrlib.VectorUint32_3D_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.VectorUint32_3D_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::vector< std::vector< unsigned int > > >::size_type"""
        return _tttrlib.VectorUint32_3D_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > > &

        """
        return _tttrlib.VectorUint32_3D_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::vector< std::vector< unsigned int > > >::iterator"""
        return _tttrlib.VectorUint32_3D_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::vector< std::vector< unsigned int > > >::iterator"""
        return _tttrlib.VectorUint32_3D_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::vector< std::vector< unsigned int > > >::reverse_iterator"""
        return _tttrlib.VectorUint32_3D_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::vector< std::vector< unsigned int > > >::reverse_iterator"""
        return _tttrlib.VectorUint32_3D_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.VectorUint32_3D_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::vector< std::vector< unsigned int > > >::allocator_type"""
        return _tttrlib.VectorUint32_3D_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _tttrlib.VectorUint32_3D_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::vector< std::vector< unsigned int > > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< std::vector< unsigned int > > >::iterator

        erase(self, first, last) -> std::vector< std::vector< std::vector< unsigned int > > >::iterator

        Parameters
        ----------
        first: std::vector< std::vector< std::vector< unsigned int > > >::iterator
        last: std::vector< std::vector< std::vector< unsigned int > > >::iterator

        """
        return _tttrlib.VectorUint32_3D_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> VectorUint32_3D
        __init__(self, other) -> VectorUint32_3D

        Parameters
        ----------
        other: std::vector< std::vector< std::vector< unsigned int,std::allocator< unsigned int > >,std::allocator< std::vector< unsigned int,std::allocator< unsigned int > > > > > const &

        __init__(self, size) -> VectorUint32_3D

        Parameters
        ----------
        size: std::vector< std::vector< std::vector< unsigned int > > >::size_type

        __init__(self, size, value) -> VectorUint32_3D

        Parameters
        ----------
        size: std::vector< std::vector< std::vector< unsigned int > > >::size_type
        value: std::vector< std::vector< std::vector< unsigned int > > >::value_type const &

        """
        _tttrlib.VectorUint32_3D_swiginit(self, _tttrlib.new_VectorUint32_3D(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< std::vector< unsigned int > > >::value_type const &

        """
        return _tttrlib.VectorUint32_3D_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< std::vector< std::vector< unsigned int > > >::value_type const &"""
        return _tttrlib.VectorUint32_3D_front(self)

    def back(self):
        r"""back(self) -> std::vector< std::vector< std::vector< unsigned int > > >::value_type const &"""
        return _tttrlib.VectorUint32_3D_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::vector< std::vector< unsigned int > > >::size_type
        x: std::vector< std::vector< std::vector< unsigned int > > >::value_type const &

        """
        return _tttrlib.VectorUint32_3D_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::vector< std::vector< unsigned int > > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::vector< std::vector< unsigned int > > >::size_type
        x: std::vector< std::vector< std::vector< unsigned int > > >::value_type const &

        """
        return _tttrlib.VectorUint32_3D_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::vector< std::vector< unsigned int > > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< std::vector< unsigned int > > >::iterator
        x: std::vector< std::vector< std::vector< unsigned int > > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::vector< std::vector< unsigned int > > >::iterator
        n: std::vector< std::vector< std::vector< unsigned int > > >::size_type
        x: std::vector< std::vector< std::vector< unsigned int > > >::value_type const &

        """
        return _tttrlib.VectorUint32_3D_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::vector< std::vector< unsigned int > > >::size_type

        """
        return _tttrlib.VectorUint32_3D_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::vector< std::vector< unsigned int > > >::size_type"""
        return _tttrlib.VectorUint32_3D_capacity(self)
    __swig_destroy__ = _tttrlib.delete_VectorUint32_3D

# Register VectorUint32_3D in _tttrlib:
_tttrlib.VectorUint32_3D_swigregister(VectorUint32_3D)
class VectorDouble_2D(object):
    r"""Proxy of C++ std::vector< std::vector< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.VectorDouble_2D_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.VectorDouble_2D___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.VectorDouble_2D___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::vector< double > >::size_type"""
        return _tttrlib.VectorDouble_2D___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> VectorDouble_2D

        Parameters
        ----------
        i: std::vector< std::vector< double > >::difference_type
        j: std::vector< std::vector< double > >::difference_type

        """
        return _tttrlib.VectorDouble_2D___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< double > >::difference_type
        j: std::vector< std::vector< double > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::vector< double > >::difference_type
        j: std::vector< std::vector< double > >::difference_type
        v: std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &

        """
        return _tttrlib.VectorDouble_2D___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::vector< double > >::difference_type
        j: std::vector< std::vector< double > >::difference_type

        """
        return _tttrlib.VectorDouble_2D___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::vector< double > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _tttrlib.VectorDouble_2D___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> VectorDouble_2D

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(self, i) -> VectorDouble

        Parameters
        ----------
        i: std::vector< std::vector< double > >::difference_type

        """
        return _tttrlib.VectorDouble_2D___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::vector< double > >::difference_type
        x: std::vector< std::vector< double > >::value_type const &

        """
        return _tttrlib.VectorDouble_2D___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> VectorDouble"""
        return _tttrlib.VectorDouble_2D_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< double > >::value_type const &

        """
        return _tttrlib.VectorDouble_2D_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.VectorDouble_2D_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::vector< double > >::size_type"""
        return _tttrlib.VectorDouble_2D_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::vector< double,std::allocator< double > > > &

        """
        return _tttrlib.VectorDouble_2D_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::vector< double > >::iterator"""
        return _tttrlib.VectorDouble_2D_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::vector< double > >::iterator"""
        return _tttrlib.VectorDouble_2D_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _tttrlib.VectorDouble_2D_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _tttrlib.VectorDouble_2D_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.VectorDouble_2D_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::vector< double > >::allocator_type"""
        return _tttrlib.VectorDouble_2D_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _tttrlib.VectorDouble_2D_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::vector< double > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< double > >::iterator

        erase(self, first, last) -> std::vector< std::vector< double > >::iterator

        Parameters
        ----------
        first: std::vector< std::vector< double > >::iterator
        last: std::vector< std::vector< double > >::iterator

        """
        return _tttrlib.VectorDouble_2D_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> VectorDouble_2D
        __init__(self, other) -> VectorDouble_2D

        Parameters
        ----------
        other: std::vector< std::vector< double,std::allocator< double > > > const &

        __init__(self, size) -> VectorDouble_2D

        Parameters
        ----------
        size: std::vector< std::vector< double > >::size_type

        __init__(self, size, value) -> VectorDouble_2D

        Parameters
        ----------
        size: std::vector< std::vector< double > >::size_type
        value: std::vector< std::vector< double > >::value_type const &

        """
        _tttrlib.VectorDouble_2D_swiginit(self, _tttrlib.new_VectorDouble_2D(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::vector< double > >::value_type const &

        """
        return _tttrlib.VectorDouble_2D_push_back(self, x)

    def front(self):
        r"""front(self) -> VectorDouble"""
        return _tttrlib.VectorDouble_2D_front(self)

    def back(self):
        r"""back(self) -> VectorDouble"""
        return _tttrlib.VectorDouble_2D_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::vector< double > >::size_type
        x: std::vector< std::vector< double > >::value_type const &

        """
        return _tttrlib.VectorDouble_2D_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::vector< double > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::vector< double > >::size_type
        x: std::vector< std::vector< double > >::value_type const &

        """
        return _tttrlib.VectorDouble_2D_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::vector< double > >::iterator

        Parameters
        ----------
        pos: std::vector< std::vector< double > >::iterator
        x: std::vector< std::vector< double > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::vector< double > >::iterator
        n: std::vector< std::vector< double > >::size_type
        x: std::vector< std::vector< double > >::value_type const &

        """
        return _tttrlib.VectorDouble_2D_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::vector< double > >::size_type

        """
        return _tttrlib.VectorDouble_2D_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::vector< double > >::size_type"""
        return _tttrlib.VectorDouble_2D_capacity(self)
    __swig_destroy__ = _tttrlib.delete_VectorDouble_2D

# Register VectorDouble_2D in _tttrlib:
_tttrlib.VectorDouble_2D_swigregister(VectorDouble_2D)
class MapStringString(object):
    r"""Proxy of C++ std::map< std::string,std::string > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.MapStringString_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.MapStringString___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.MapStringString___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::map< std::string,std::string >::size_type"""
        return _tttrlib.MapStringString___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        r"""
        __getitem__(self, key) -> std::map< std::string,std::string >::mapped_type const &

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        """
        return _tttrlib.MapStringString___getitem__(self, key)

    def __delitem__(self, key):
        r"""
        __delitem__(self, key)

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        """
        return _tttrlib.MapStringString___delitem__(self, key)

    def has_key(self, key):
        r"""
        has_key(self, key) -> bool

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        """
        return _tttrlib.MapStringString_has_key(self, key)

    def keys(self):
        r"""keys(self) -> PyObject *"""
        return _tttrlib.MapStringString_keys(self)

    def values(self):
        r"""values(self) -> PyObject *"""
        return _tttrlib.MapStringString_values(self)

    def items(self):
        r"""items(self) -> PyObject *"""
        return _tttrlib.MapStringString_items(self)

    def __contains__(self, key):
        r"""
        __contains__(self, key) -> bool

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        """
        return _tttrlib.MapStringString___contains__(self, key)

    def key_iterator(self):
        r"""key_iterator(self) -> SwigPyIterator"""
        return _tttrlib.MapStringString_key_iterator(self)

    def value_iterator(self):
        r"""value_iterator(self) -> SwigPyIterator"""
        return _tttrlib.MapStringString_value_iterator(self)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, key)

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &

        __setitem__(self, key, x)

        Parameters
        ----------
        key: std::map< std::string,std::string >::key_type const &
        x: std::map< std::string,std::string >::mapped_type const &

        """
        return _tttrlib.MapStringString___setitem__(self, *args)

    def asdict(self):
        r"""asdict(self) -> PyObject *"""
        return _tttrlib.MapStringString_asdict(self)

    def __init__(self, *args):
        r"""
        __init__(self, other) -> MapStringString

        Parameters
        ----------
        other: std::less< std::string > const &

        __init__(self) -> MapStringString
        __init__(self, other) -> MapStringString

        Parameters
        ----------
        other: std::map< std::string,std::string > const &

        """
        _tttrlib.MapStringString_swiginit(self, _tttrlib.new_MapStringString(*args))

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.MapStringString_empty(self)

    def size(self):
        r"""size(self) -> std::map< std::string,std::string >::size_type"""
        return _tttrlib.MapStringString_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::map< std::string,std::string > &

        """
        return _tttrlib.MapStringString_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::map< std::string,std::string >::iterator"""
        return _tttrlib.MapStringString_begin(self)

    def end(self):
        r"""end(self) -> std::map< std::string,std::string >::iterator"""
        return _tttrlib.MapStringString_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::map< std::string,std::string >::reverse_iterator"""
        return _tttrlib.MapStringString_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::map< std::string,std::string >::reverse_iterator"""
        return _tttrlib.MapStringString_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.MapStringString_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::map< std::string,std::string >::allocator_type"""
        return _tttrlib.MapStringString_get_allocator(self)

    def count(self, x):
        r"""
        count(self, x) -> std::map< std::string,std::string >::size_type

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        """
        return _tttrlib.MapStringString_count(self, x)

    def erase(self, *args):
        r"""
        erase(self, x) -> std::map< std::string,std::string >::size_type

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        erase(self, position)

        Parameters
        ----------
        position: std::map< std::string,std::string >::iterator

        erase(self, first, last)

        Parameters
        ----------
        first: std::map< std::string,std::string >::iterator
        last: std::map< std::string,std::string >::iterator

        """
        return _tttrlib.MapStringString_erase(self, *args)

    def find(self, x):
        r"""
        find(self, x) -> std::map< std::string,std::string >::iterator

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        """
        return _tttrlib.MapStringString_find(self, x)

    def lower_bound(self, x):
        r"""
        lower_bound(self, x) -> std::map< std::string,std::string >::iterator

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        """
        return _tttrlib.MapStringString_lower_bound(self, x)

    def upper_bound(self, x):
        r"""
        upper_bound(self, x) -> std::map< std::string,std::string >::iterator

        Parameters
        ----------
        x: std::map< std::string,std::string >::key_type const &

        """
        return _tttrlib.MapStringString_upper_bound(self, x)
    __swig_destroy__ = _tttrlib.delete_MapStringString

# Register MapStringString in _tttrlib:
_tttrlib.MapStringString_swigregister(MapStringString)
class MapShortVectorDouble(object):
    r"""Proxy of C++ std::map< short,std::vector< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.MapShortVectorDouble_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.MapShortVectorDouble___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.MapShortVectorDouble___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::map< short,std::vector< double > >::size_type"""
        return _tttrlib.MapShortVectorDouble___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        r"""
        __getitem__(self, key) -> VectorDouble

        Parameters
        ----------
        key: std::map< short,std::vector< double > >::key_type const &

        """
        return _tttrlib.MapShortVectorDouble___getitem__(self, key)

    def __delitem__(self, key):
        r"""
        __delitem__(self, key)

        Parameters
        ----------
        key: std::map< short,std::vector< double > >::key_type const &

        """
        return _tttrlib.MapShortVectorDouble___delitem__(self, key)

    def has_key(self, key):
        r"""
        has_key(self, key) -> bool

        Parameters
        ----------
        key: std::map< short,std::vector< double > >::key_type const &

        """
        return _tttrlib.MapShortVectorDouble_has_key(self, key)

    def keys(self):
        r"""keys(self) -> PyObject *"""
        return _tttrlib.MapShortVectorDouble_keys(self)

    def values(self):
        r"""values(self) -> PyObject *"""
        return _tttrlib.MapShortVectorDouble_values(self)

    def items(self):
        r"""items(self) -> PyObject *"""
        return _tttrlib.MapShortVectorDouble_items(self)

    def __contains__(self, key):
        r"""
        __contains__(self, key) -> bool

        Parameters
        ----------
        key: std::map< short,std::vector< double > >::key_type const &

        """
        return _tttrlib.MapShortVectorDouble___contains__(self, key)

    def key_iterator(self):
        r"""key_iterator(self) -> SwigPyIterator"""
        return _tttrlib.MapShortVectorDouble_key_iterator(self)

    def value_iterator(self):
        r"""value_iterator(self) -> SwigPyIterator"""
        return _tttrlib.MapShortVectorDouble_value_iterator(self)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, key)

        Parameters
        ----------
        key: std::map< short,std::vector< double > >::key_type const &

        __setitem__(self, key, x)

        Parameters
        ----------
        key: std::map< short,std::vector< double > >::key_type const &
        x: std::map< short,std::vector< double > >::mapped_type const &

        """
        return _tttrlib.MapShortVectorDouble___setitem__(self, *args)

    def asdict(self):
        r"""asdict(self) -> PyObject *"""
        return _tttrlib.MapShortVectorDouble_asdict(self)

    def __init__(self, *args):
        r"""
        __init__(self, other) -> MapShortVectorDouble

        Parameters
        ----------
        other: std::less< short > const &

        __init__(self) -> MapShortVectorDouble
        __init__(self, other) -> MapShortVectorDouble

        Parameters
        ----------
        other: std::map< short,std::vector< double,std::allocator< double > > > const &

        """
        _tttrlib.MapShortVectorDouble_swiginit(self, _tttrlib.new_MapShortVectorDouble(*args))

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.MapShortVectorDouble_empty(self)

    def size(self):
        r"""size(self) -> std::map< short,std::vector< double > >::size_type"""
        return _tttrlib.MapShortVectorDouble_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::map< short,std::vector< double,std::allocator< double > > > &

        """
        return _tttrlib.MapShortVectorDouble_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::map< short,std::vector< double > >::iterator"""
        return _tttrlib.MapShortVectorDouble_begin(self)

    def end(self):
        r"""end(self) -> std::map< short,std::vector< double > >::iterator"""
        return _tttrlib.MapShortVectorDouble_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::map< short,std::vector< double > >::reverse_iterator"""
        return _tttrlib.MapShortVectorDouble_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::map< short,std::vector< double > >::reverse_iterator"""
        return _tttrlib.MapShortVectorDouble_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.MapShortVectorDouble_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::map< short,std::vector< double > >::allocator_type"""
        return _tttrlib.MapShortVectorDouble_get_allocator(self)

    def count(self, x):
        r"""
        count(self, x) -> std::map< short,std::vector< double > >::size_type

        Parameters
        ----------
        x: std::map< short,std::vector< double > >::key_type const &

        """
        return _tttrlib.MapShortVectorDouble_count(self, x)

    def erase(self, *args):
        r"""
        erase(self, x) -> std::map< short,std::vector< double > >::size_type

        Parameters
        ----------
        x: std::map< short,std::vector< double > >::key_type const &

        erase(self, position)

        Parameters
        ----------
        position: std::map< short,std::vector< double > >::iterator

        erase(self, first, last)

        Parameters
        ----------
        first: std::map< short,std::vector< double > >::iterator
        last: std::map< short,std::vector< double > >::iterator

        """
        return _tttrlib.MapShortVectorDouble_erase(self, *args)

    def find(self, x):
        r"""
        find(self, x) -> std::map< short,std::vector< double > >::iterator

        Parameters
        ----------
        x: std::map< short,std::vector< double > >::key_type const &

        """
        return _tttrlib.MapShortVectorDouble_find(self, x)

    def lower_bound(self, x):
        r"""
        lower_bound(self, x) -> std::map< short,std::vector< double > >::iterator

        Parameters
        ----------
        x: std::map< short,std::vector< double > >::key_type const &

        """
        return _tttrlib.MapShortVectorDouble_lower_bound(self, x)

    def upper_bound(self, x):
        r"""
        upper_bound(self, x) -> std::map< short,std::vector< double > >::iterator

        Parameters
        ----------
        x: std::map< short,std::vector< double > >::key_type const &

        """
        return _tttrlib.MapShortVectorDouble_upper_bound(self, x)
    __swig_destroy__ = _tttrlib.delete_MapShortVectorDouble

# Register MapShortVectorDouble in _tttrlib:
_tttrlib.MapShortVectorDouble_swigregister(MapShortVectorDouble)
class VectorPairInt(object):
    r"""Proxy of C++ std::vector< std::pair< int,int > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.VectorPairInt_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.VectorPairInt___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.VectorPairInt___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< std::pair< int,int > >::size_type"""
        return _tttrlib.VectorPairInt___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> VectorPairInt

        Parameters
        ----------
        i: std::vector< std::pair< int,int > >::difference_type
        j: std::vector< std::pair< int,int > >::difference_type

        """
        return _tttrlib.VectorPairInt___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::pair< int,int > >::difference_type
        j: std::vector< std::pair< int,int > >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< std::pair< int,int > >::difference_type
        j: std::vector< std::pair< int,int > >::difference_type
        v: std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > const &

        """
        return _tttrlib.VectorPairInt___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< std::pair< int,int > >::difference_type
        j: std::vector< std::pair< int,int > >::difference_type

        """
        return _tttrlib.VectorPairInt___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< std::pair< int,int > >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _tttrlib.VectorPairInt___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> VectorPairInt

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(self, i) -> std::vector< std::pair< int,int > >::value_type const &

        Parameters
        ----------
        i: std::vector< std::pair< int,int > >::difference_type

        """
        return _tttrlib.VectorPairInt___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< std::pair< int,int > >::difference_type
        x: std::vector< std::pair< int,int > >::value_type const &

        """
        return _tttrlib.VectorPairInt___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> std::vector< std::pair< int,int > >::value_type"""
        return _tttrlib.VectorPairInt_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< std::pair< int,int > >::value_type const &

        """
        return _tttrlib.VectorPairInt_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.VectorPairInt_empty(self)

    def size(self):
        r"""size(self) -> std::vector< std::pair< int,int > >::size_type"""
        return _tttrlib.VectorPairInt_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< std::pair< int,int > > &

        """
        return _tttrlib.VectorPairInt_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< std::pair< int,int > >::iterator"""
        return _tttrlib.VectorPairInt_begin(self)

    def end(self):
        r"""end(self) -> std::vector< std::pair< int,int > >::iterator"""
        return _tttrlib.VectorPairInt_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< std::pair< int,int > >::reverse_iterator"""
        return _tttrlib.VectorPairInt_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< std::pair< int,int > >::reverse_iterator"""
        return _tttrlib.VectorPairInt_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.VectorPairInt_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< std::pair< int,int > >::allocator_type"""
        return _tttrlib.VectorPairInt_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _tttrlib.VectorPairInt_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< std::pair< int,int > >::iterator

        Parameters
        ----------
        pos: std::vector< std::pair< int,int > >::iterator

        erase(self, first, last) -> std::vector< std::pair< int,int > >::iterator

        Parameters
        ----------
        first: std::vector< std::pair< int,int > >::iterator
        last: std::vector< std::pair< int,int > >::iterator

        """
        return _tttrlib.VectorPairInt_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> VectorPairInt
        __init__(self, other) -> VectorPairInt

        Parameters
        ----------
        other: std::vector< std::pair< int,int > > const &

        __init__(self, size) -> VectorPairInt

        Parameters
        ----------
        size: std::vector< std::pair< int,int > >::size_type

        __init__(self, size, value) -> VectorPairInt

        Parameters
        ----------
        size: std::vector< std::pair< int,int > >::size_type
        value: std::vector< std::pair< int,int > >::value_type const &

        """
        _tttrlib.VectorPairInt_swiginit(self, _tttrlib.new_VectorPairInt(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< std::pair< int,int > >::value_type const &

        """
        return _tttrlib.VectorPairInt_push_back(self, x)

    def front(self):
        r"""front(self) -> std::vector< std::pair< int,int > >::value_type const &"""
        return _tttrlib.VectorPairInt_front(self)

    def back(self):
        r"""back(self) -> std::vector< std::pair< int,int > >::value_type const &"""
        return _tttrlib.VectorPairInt_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< std::pair< int,int > >::size_type
        x: std::vector< std::pair< int,int > >::value_type const &

        """
        return _tttrlib.VectorPairInt_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< std::pair< int,int > >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< std::pair< int,int > >::size_type
        x: std::vector< std::pair< int,int > >::value_type const &

        """
        return _tttrlib.VectorPairInt_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< std::pair< int,int > >::iterator

        Parameters
        ----------
        pos: std::vector< std::pair< int,int > >::iterator
        x: std::vector< std::pair< int,int > >::value_type const &

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< std::pair< int,int > >::iterator
        n: std::vector< std::pair< int,int > >::size_type
        x: std::vector< std::pair< int,int > >::value_type const &

        """
        return _tttrlib.VectorPairInt_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< std::pair< int,int > >::size_type

        """
        return _tttrlib.VectorPairInt_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< std::pair< int,int > >::size_type"""
        return _tttrlib.VectorPairInt_capacity(self)
    __swig_destroy__ = _tttrlib.delete_VectorPairInt

# Register VectorPairInt in _tttrlib:
_tttrlib.VectorPairInt_swigregister(VectorPairInt)
class PairVectorDouble(object):
    r"""Proxy of C++ std::pair< std::vector< double >,std::vector< double > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> PairVectorDouble
        __init__(self, first, second) -> PairVectorDouble

        Parameters
        ----------
        first: std::vector< double,std::allocator< double > >
        second: std::vector< double,std::allocator< double > >

        __init__(self, other) -> PairVectorDouble

        Parameters
        ----------
        other: std::pair< std::vector< double,std::allocator< double > >,std::vector< double,std::allocator< double > > > const &

        """
        _tttrlib.PairVectorDouble_swiginit(self, _tttrlib.new_PairVectorDouble(*args))
    first = property(_tttrlib.PairVectorDouble_first_get, _tttrlib.PairVectorDouble_first_set, doc=r"""first""")
    second = property(_tttrlib.PairVectorDouble_second_get, _tttrlib.PairVectorDouble_second_set, doc=r"""second""")
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _tttrlib.delete_PairVectorDouble

# Register PairVectorDouble in _tttrlib:
_tttrlib.PairVectorDouble_swigregister(PairVectorDouble)
class PairVectorInt64(object):
    r"""Proxy of C++ std::pair< std::vector< unsigned long long >,std::vector< unsigned long long > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> PairVectorInt64
        __init__(self, first, second) -> PairVectorInt64

        Parameters
        ----------
        first: std::vector< unsigned long long,std::allocator< unsigned long long > >
        second: std::vector< unsigned long long,std::allocator< unsigned long long > >

        __init__(self, other) -> PairVectorInt64

        Parameters
        ----------
        other: std::pair< std::vector< unsigned long long,std::allocator< unsigned long long > >,std::vector< unsigned long long,std::allocator< unsigned long long > > > const &

        """
        _tttrlib.PairVectorInt64_swiginit(self, _tttrlib.new_PairVectorInt64(*args))
    first = property(_tttrlib.PairVectorInt64_first_get, _tttrlib.PairVectorInt64_first_set, doc=r"""first""")
    second = property(_tttrlib.PairVectorInt64_second_get, _tttrlib.PairVectorInt64_second_set, doc=r"""second""")
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _tttrlib.delete_PairVectorInt64

# Register PairVectorInt64 in _tttrlib:
_tttrlib.PairVectorInt64_swigregister(PairVectorInt64)

def isHDF5File(filename):
    r"""
    isHDF5File(filename) -> bool

    Parameters
    ----------
    filename: std::string const &

    """
    return _tttrlib.isHDF5File(filename)

def isSMFile(filename):
    r"""
    isSMFile(filename) -> bool

    Parameters
    ----------
    filename: std::string const &

    """
    return _tttrlib.isSMFile(filename)

def isPTUFile(filename):
    r"""
    isPTUFile(filename) -> bool

    Parameters
    ----------
    filename: std::string const &

    """
    return _tttrlib.isPTUFile(filename)

def isHT3File(filename):
    r"""
    isHT3File(filename) -> bool

    Parameters
    ----------
    filename: std::string const &

    """
    return _tttrlib.isHT3File(filename)

def isBH132File(filename):
    r"""
    isBH132File(filename) -> bool

    Parameters
    ----------
    filename: std::string const &

    """
    return _tttrlib.isBH132File(filename)

def inferTTTRFileType(fn):
    r"""
    inferTTTRFileType(fn) -> int

    Parameters
    ----------
    fn: char const *

    """
    return _tttrlib.inferTTTRFileType(fn)

def isCZConfocor3File(filename):
    r"""
    isCZConfocor3File(filename) -> bool

    Parameters
    ----------
    filename: std::string const &

    """
    return _tttrlib.isCZConfocor3File(filename)
class TTTRHeader(object):
    r"""


    C++ includes: TTTRHeader.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def get_tag(json_data, name, idx=-1):
        r"""
        get_tag(json_data, name, idx=-1) -> nlohmann::json

        Parameters
        ----------
        json_data: nlohmann::json
        name: std::string const &
        idx: int


        TTTRHeader::get_tag
        Get a tag / entry from the meta data list in a JSON dict  

        Parameters
        ----------
        * `json_data` :  
        * `name` :  
        * `idx` :  

        Returns
        -------  

        """
        return _tttrlib.TTTRHeader_get_tag(json_data, name, idx)

    @staticmethod
    def find_tag(json_data, name, idx=-1):
        r"""
        find_tag(json_data, name, idx=-1) -> int

        Parameters
        ----------
        json_data: nlohmann::json &
        name: std::string const &
        idx: int


        TTTRHeader::find_tag
        Find the index of a tag in the JSON data by name type and index  

        Parameters
        ----------
        * `json_data` :  
        * `name` :  
        * `type` :  
        * `idx` :  

        Returns
        -------  

        """
        return _tttrlib.TTTRHeader_find_tag(json_data, name, idx)

    @staticmethod
    def add_tag(*args, **kwargs):
        r"""
        add_tag(json_data, name, value, type=tyAnsiString, idx=-1)

        Parameters
        ----------
        json_data: nlohmann::json &
        name: std::string const &
        value: std::any
        type: unsigned int
        idx: int


        TTTRHeader::add_tag
        Add a meta data tag. If the tag already exists the value of the meta data tag is
        replaced.  

        Parameters
        ----------
        * `json_data` :  
        * `name` :  
        * `value` :  
        * `type` :  
        * `idx` :  

        """
        return _tttrlib.TTTRHeader_add_tag(*args, **kwargs)

    def get_bytes_per_record(self):
        r"""
        get_bytes_per_record(self) -> size_t

        TTTRHeader::get_bytes_per_record
        Stores the bytes per TTTR record of the associated TTTR file This attribute is
        changed when a header is read  

        """
        return _tttrlib.TTTRHeader_get_bytes_per_record(self)

    def end(self):
        r"""
        end(self) -> size_t

        TTTRHeader::end
        """
        return _tttrlib.TTTRHeader_end(self)

    def size(self):
        r"""
        size(self) -> size_t

        TTTRHeader::size
        Number of meta data entries  

        """
        return _tttrlib.TTTRHeader_size(self)

    def get_pixel_duration(self):
        r"""
        get_pixel_duration(self) -> int

        TTTRHeader::get_pixel_duration
        Duration of a pixel in LSM in units of macro time clock.  

        """
        return _tttrlib.TTTRHeader_get_pixel_duration(self)

    def get_line_duration(self):
        r"""
        get_line_duration(self) -> int

        TTTRHeader::get_line_duration
        Duration of a line in LSM in units of macro time clock.  

        """
        return _tttrlib.TTTRHeader_get_line_duration(self)

    def get_effective_number_of_micro_time_channels(self):
        r"""
        get_effective_number_of_micro_time_channels(self) -> unsigned int

        TTTRHeader::get_effective_number_of_micro_time_channels
        The number of micro time channels that fit between two macro times.  

        The total (possible) number of TAC channels can exceed the number that fit
        between two macro time channels. This function returns the effective number,
        i.e., the number of micro time channels between two macro times. The micro time
        channels that are outside of this bound should (usually) not be filled.  

        Returns
        -------
        effective_tac_channels (that fit between to macro times)  

        """
        return _tttrlib.TTTRHeader_get_effective_number_of_micro_time_channels(self)

    def __init__(self, *args):
        r"""
        __init__(self) -> TTTRHeader
        __init__(self, tttr_container_type) -> TTTRHeader

        Parameters
        ----------
        tttr_container_type: int

        __init__(self, p2) -> TTTRHeader

        Parameters
        ----------
        p2: TTTRHeader const &

        __init__(self, fn, tttr_container_type=0) -> TTTRHeader

        Parameters
        ----------
        fn: std::string
        tttr_container_type: int


        TTTRHeader::TTTRHeader
        """
        _tttrlib.TTTRHeader_swiginit(self, _tttrlib.new_TTTRHeader(*args))
    __swig_destroy__ = _tttrlib.delete_TTTRHeader

    @staticmethod
    def read_ptu_header(fpin, tttr_record_type, json_data, rewind=True):
        r"""
        read_ptu_header(fpin, tttr_record_type, json_data, rewind=True) -> size_t

        Parameters
        ----------
        fpin: std::FILE *
        tttr_record_type: int &
        json_data: nlohmann::json &
        rewind: bool


        TTTRHeader::read_ptu_header
        Reads the header of a ptu file and sets the reading routing for  

        Parameters
        ----------
        * `fpin` :  
        * `rewind` :  
        * `tttr_record_type` :  
        * `json_data` :  
        * `macro_time_resolution` :  
        * `micro_time_resolution` :  

        Returns
        -------
        The position of the file pointer at the end of the header  

        """
        return _tttrlib.TTTRHeader_read_ptu_header(fpin, tttr_record_type, json_data, rewind)

    @staticmethod
    def read_ht3_header(fpin, data, rewind=True):
        r"""
        read_ht3_header(fpin, data, rewind=True) -> size_t

        Parameters
        ----------
        fpin: std::FILE *
        data: nlohmann::json &
        rewind: bool


        TTTRHeader::read_ht3_header
        Reads the header of a ht3 file and sets the reading routing for  

        Parameters
        ----------
        * `fpin` :  
        * `rewind` :  
        * `tttr_record_type` :  
        * `data` :  

        Returns
        -------
        The position of the file pointer at the end of the header  

        """
        return _tttrlib.TTTRHeader_read_ht3_header(fpin, data, rewind)

    @staticmethod
    def read_sm_header(file, j):
        r"""
        read_sm_header(file, j) -> size_t

        Parameters
        ----------
        file: FILE *
        j: nlohmann::json &

        """
        return _tttrlib.TTTRHeader_read_sm_header(file, j)

    @staticmethod
    def read_bh132_header(fpin, data, rewind=True):
        r"""
        read_bh132_header(fpin, data, rewind=True) -> size_t

        Parameters
        ----------
        fpin: std::FILE *
        data: nlohmann::json &
        rewind: bool


        TTTRHeader::read_bh132_header
        Reads the header of a Becker&Hickel SPC132 file and sets the reading routing  

        Parameters
        ----------
        * `fpin` :  
        * `rewind` :  
        * `tttr_record_type` :  
        * `data` :  
            JSON dictionary that will contain the header information  

        """
        return _tttrlib.TTTRHeader_read_bh132_header(fpin, data, rewind)

    @staticmethod
    def read_cz_confocor3_header(fpin, data, rewind=True):
        r"""
        read_cz_confocor3_header(fpin, data, rewind=True) -> size_t

        Parameters
        ----------
        fpin: std::FILE *
        data: nlohmann::json &
        rewind: bool

        """
        return _tttrlib.TTTRHeader_read_cz_confocor3_header(fpin, data, rewind)

    @staticmethod
    def write_spc132_header(*args, **kwargs):
        r"""
        write_spc132_header(fn, header, modes="w")

        Parameters
        ----------
        fn: std::string
        header: TTTRHeader *
        modes: std::string


        TTTRHeader::write_spc132_header
        Write a spc132 header to a file  

        WARNING: If the default write mode is "wb". Existing files are overwritten.  

        Parameters
        ----------
        * `fn` :  
            filename  
        * `header` :  
            pointer to the TTTRHeader object that is written to the file  
        * `modes` :  
            the writing modes (default 'w+b')  

        """
        return _tttrlib.TTTRHeader_write_spc132_header(*args, **kwargs)

    @staticmethod
    def write_ptu_header(*args, **kwargs):
        r"""
        write_ptu_header(fn, header, modes="wb")

        Parameters
        ----------
        fn: std::string
        header: TTTRHeader *
        modes: std::string


        TTTRHeader::write_ptu_header
        Write a PTU header to a file  

        WARNING: If the default write mode is "wb". Existing files are overwritten.  

        Parameters
        ----------
        * `fn` :  
            filename  
        * `header` :  
            pointer to the TTTRHeader object that is written to the file  
        * `modes` :  
            the writing modes (default 'wb')  

        """
        return _tttrlib.TTTRHeader_write_ptu_header(*args, **kwargs)

    @staticmethod
    def write_ht3_header(*args, **kwargs):
        r"""
        write_ht3_header(fn, header, modes="wb")

        Parameters
        ----------
        fn: std::string
        header: TTTRHeader *
        modes: std::string


        TTTRHeader::write_ht3_header
        Write a HT3 header to a file  

        WARNING: If the default write mode is "wb". Existing files are overwritten.  

        Parameters
        ----------
        * `fn` :  
            filename  
        * `header` :  
            pointer to the TTTRHeader object that is written to the file  
        * `modes` :  
            the writing modes (default 'wb')  

        """
        return _tttrlib.TTTRHeader_write_ht3_header(*args, **kwargs)

    def get_json(self, *args, **kwargs):
        r"""
        get_json(self, tag_name="", idx=-1, indent=1) -> std::string

        Parameters
        ----------
        tag_name: std::string
        idx: int
        indent: int


        TTTRHeader::get_json
        Get a representation of the TTTRHeader meta data as a JSON string  

        Parameters
        ----------
        * `tag_name` :  
            name of requested tag (if no name is provided) the entire information in the
            TTTRHeader is returned  
        * `idx` :  
            index of the tag  
        * `indent` :  
            an integer that controls the indent in the returned JSON string  

        Returns
        -------  

        """
        return _tttrlib.TTTRHeader_get_json(self, *args, **kwargs)

    def set_json(self, json_string):
        r"""
        set_json(self, json_string)

        Parameters
        ----------
        json_string: std::string


        TTTRHeader::set_json
        Set / update the TTTRHeader meta data using a JSON string  

        Parameters
        ----------
        * `json_string` :  

        """
        return _tttrlib.TTTRHeader_set_json(self, json_string)
    number_of_micro_time_channels = property(_tttrlib.TTTRHeader_number_of_micro_time_channels_get, doc=r"""number_of_micro_time_channels""")
    macro_time_resolution = property(_tttrlib.TTTRHeader_macro_time_resolution_get, doc=r"""macro_time_resolution""")
    micro_time_resolution = property(_tttrlib.TTTRHeader_micro_time_resolution_get, doc=r"""micro_time_resolution""")
    tttr_record_type = property(_tttrlib.TTTRHeader_tttr_record_type_get, _tttrlib.TTTRHeader_tttr_record_type_set, doc=r"""tttr_record_type""")
    tttr_container_type = property(_tttrlib.TTTRHeader_tttr_container_type_get, _tttrlib.TTTRHeader_tttr_container_type_set, doc=r"""tttr_container_type""")

    @property
    def json(self):
        return self.get_json()

    @json.setter
    def json(self, v):
        return self.set_json(v)

    @property
    def tags(self):
        import json
        return json.loads(self.json)["tags"]

    def tag(self, name, idx=-1):
        import json
        js = self.get_json(name, idx, 0)
        return json.loads(js)

    def add_tags(self, header2):
        import json
        if isinstance(header2, str):
            header2_dict = json.loads(header2)
        elif isinstance(header2, TTTRHeader):
            header2_dict = json.loads(header2.json)
        elif isinstance(header2, dict):
            header2_dict = header2
    # Copy tags from header 2 to header 1 if the tag is not in header 1
        header1_dict = json.loads(self.json)
    # remove Header_End tags
        tags_1 = header1_dict["tags"]
        tags_2 = header2_dict["tags"]
        for tag2 in tags_2:
            existing_tag = False
            for tag1 in tags_1:
                if (tag1["name"] == tag2["name"]) and (tag1["idx"] == tag2["idx"]):
                    existing_tag = True
                    break
            if not existing_tag:
                tags_1.append(tag2)
        header1_dict["tags"] = tags_1
        self.set_json(json.dumps(header1_dict))

    def __init__(self, *args, **kwargs):
        this = _tttrlib.new_TTTRHeader(*args, **kwargs)
        try:
            self.this.append(this)
        except:
            self.this = this



# Register TTTRHeader in _tttrlib:
_tttrlib.TTTRHeader_swigregister(TTTRHeader)
cvar = _tttrlib.cvar
TTTRTagRes = cvar.TTTRTagRes
TTTRTagGlobRes = cvar.TTTRTagGlobRes
TTTRSyncRate = cvar.TTTRSyncRate
TTTRNMicroTimes = cvar.TTTRNMicroTimes
TTTRRecordType = cvar.TTTRRecordType
TTTRContainerType = cvar.TTTRContainerType
TTTRTagTTTRRecType = cvar.TTTRTagTTTRRecType
TTTRTagBits = cvar.TTTRTagBits
FileTagEnd = cvar.FileTagEnd

class TTTRRange(object):
    r"""


    C++ includes: TTTRRange.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, start=-1, stop=-1, other=None):
        r"""
        __init__(self, start=-1, stop=-1, other=None) -> TTTRRange

        Parameters
        ----------
        start: int
        stop: int
        other: TTTRRange *


        TTTRRange::TTTRRange
        Copy constructor.  

        """
        _tttrlib.TTTRRange_swiginit(self, _tttrlib.new_TTTRRange(start, stop, other))

    def size(self):
        r"""
        size(self) -> size_t

        TTTRRange::size
        """
        return _tttrlib.TTTRRange_size(self)

    def get_stop_time(self, tttr):
        r"""
        get_stop_time(self, tttr) -> unsigned long

        Parameters
        ----------
        tttr: TTTR *


        TTTRRange::get_stop_time
        The stop time of the TTTR range object.  

        """
        return _tttrlib.TTTRRange_get_stop_time(self, tttr)

    def get_start_time(self, tttr):
        r"""
        get_start_time(self, tttr) -> unsigned long

        Parameters
        ----------
        tttr: TTTR *


        TTTRRange::get_start_time
        The start time of the TTTR range object.  

        """
        return _tttrlib.TTTRRange_get_start_time(self, tttr)

    def get_start_stop_time(self, tttr):
        r"""
        get_start_stop_time(self, tttr) -> VectorUint64

        Parameters
        ----------
        tttr: TTTR *


        TTTRRange::get_start_stop_time
        A vector of the start and stop time.  

        """
        return _tttrlib.TTTRRange_get_start_stop_time(self, tttr)

    def get_duration(self, tttr):
        r"""
        get_duration(self, tttr) -> unsigned int

        Parameters
        ----------
        tttr: TTTR *


        TTTRRange::get_duration
        The difference between the start and the stop time of a range.  

        """
        return _tttrlib.TTTRRange_get_duration(self, tttr)

    def insert(self, idx):
        r"""
        insert(self, idx)

        Parameters
        ----------
        idx: int


        TTTRRange::insert
        Append a index to the TTTR index vector.  

        """
        return _tttrlib.TTTRRange_insert(self, idx)

    def clear(self):
        r"""
        clear(self)

        TTTRRange::clear
        Clears the TTTR index vector.  

        """
        return _tttrlib.TTTRRange_clear(self)

    def strip(self, tttr_indices, offset=0):
        r"""
        strip(self, tttr_indices, offset=0) -> int

        Parameters
        ----------
        tttr_indices: std::vector< int,std::allocator< int > > const &
        offset: int


        TTTRRange::strip
        Strip tttr_indices from a range starting at tttr_indices[offset] the
        tttr_indices need to be sorted in ascending size  

        """
        return _tttrlib.TTTRRange_strip(self, tttr_indices, offset)

    def get_mean_microtime(self, tttr_data, microtime_resolution=-1.0, minimum_number_of_photons=1):
        r"""
        get_mean_microtime(self, tttr_data, microtime_resolution=-1.0, minimum_number_of_photons=1) -> double

        Parameters
        ----------
        tttr_data: TTTR *
        microtime_resolution: double
        minimum_number_of_photons: int


        TTTRRange::get_mean_microtime
        Computes to the mean micro time (in units of the micro channel resolution).  

        If there are less then the minimum number of photons in a TTTRRange the function
        returns zero.  

        Parameters
        ----------
        * `tttr_data[in]` :  
            pointer to a TTTR object  
        * `minimum_number_of_photons[in]` :  
            the minimum number of photons in a micro time  

        """
        return _tttrlib.TTTRRange_get_mean_microtime(self, tttr_data, microtime_resolution, minimum_number_of_photons)

    def get_microtime_histogram(self, tttr, micro_time_coarsening):
        r"""
        get_microtime_histogram(self, tttr, micro_time_coarsening)

        Parameters
        ----------
        tttr: std::shared_ptr< TTTR >
        micro_time_coarsening: unsigned short


        TTTRRange::get_microtime_histogram
        """
        return _tttrlib.TTTRRange_get_microtime_histogram(self, tttr, micro_time_coarsening)

    def get_mean_lifetime(self, tttr_data, minimum_number_of_photons=3, tttr_irf=None, m0_irf=1.0, m1_irf=1.0, dt=1.0, background=None, m0_bg=0.0, m1_bg=0.0, background_fraction=-1.0):
        r"""
        get_mean_lifetime(self, tttr_data, minimum_number_of_photons=3, tttr_irf=None, m0_irf=1.0, m1_irf=1.0, dt=1.0, background=None, m0_bg=0.0, m1_bg=0.0, background_fraction=-1.0) -> double

        Parameters
        ----------
        tttr_data: TTTR *
        minimum_number_of_photons: int
        tttr_irf: TTTR *
        m0_irf: double
        m1_irf: double
        dt: double
        background: std::vector< double,std::allocator< double > > *
        m0_bg: double
        m1_bg: double
        background_fraction: double


        TTTRRange::get_mean_lifetime
        Return the average lifetime  

        If a TTTRRange has not enough photons return -1  

        By default the fluorescence lifetimes are computed in units of the micro time if
        no dt is provided.  

        Parameters
        ----------
        * `tttr_data[in]` :  
            pointer to a TTTR object  
        * `tttr_irf[in]` :  
            pointer to a TTTR object of the IRF  
        * `minimum_number_of_photons[in]` :  
            the minimum number of photons in a micro time  
        * `m0_irf` :  
            is the zero moment of the IRF (optional, default=1)  
        * `m1_irf` :  
            is the first moment of the IRF (optional, default=1)  
        * `dt` :  
            time resolution of the micro time  

        """
        return _tttrlib.TTTRRange_get_mean_lifetime(self, tttr_data, minimum_number_of_photons, tttr_irf, m0_irf, m1_irf, dt, background, m0_bg, m1_bg, background_fraction)

    @staticmethod
    def compute_mean_lifetime(tttr_indices, tttr_data, minimum_number_of_photons=3, tttr_irf=None, m0_irf=1.0, m1_irf=1.0, dt=1.0, background=None, m0_bg=0.0, m1_bg=0.0, background_fraction=-1.0):
        r"""
        compute_mean_lifetime(tttr_indices, tttr_data, minimum_number_of_photons=3, tttr_irf=None, m0_irf=1.0, m1_irf=1.0, dt=1.0, background=None, m0_bg=0.0, m1_bg=0.0, background_fraction=-1.0) -> double

        Parameters
        ----------
        tttr_indices: std::vector< int,std::allocator< int > > &
        tttr_data: TTTR *
        minimum_number_of_photons: int
        tttr_irf: TTTR *
        m0_irf: double
        m1_irf: double
        dt: double
        background: std::vector< double,std::allocator< double > > *
        m0_bg: double
        m1_bg: double
        background_fraction: double


        TTTRRange::compute_mean_lifetime
        Compute the average lifetime for a set of TTTR indices  

        The average lifetimes are computed (not fitted) by the methods of moments (Irvin
        Isenberg, 1973, Biophysical journal). This approach does not consider scattered
        light.  

        If a TTTRRange has not enough photons it is filled with zeros.  

        By default the fluorescence lifetimes are computed in units of the micro time if
        no dt is provided.  

        Parameters
        ----------
        * `tttr_data[in]` :  
            pointer to a TTTR object  
        * `tttr_irf[in]` :  
            pointer to a TTTR object of the IRF  
        * `minimum_number_of_photons[in]` :  
            the minimum number of photons in a micro time  
        * `m0_irf` :  
            is the zero moment of the IRF (optional, default=1)  
        * `m1_irf` :  
            is the first moment of the IRF (optional, default=1)  
        * `dt` :  
            time resolution of the micro time  
        * `background_fraction` :  
            fraction of background pattern in data (if negative no background)  

        """
        return _tttrlib.TTTRRange_compute_mean_lifetime(tttr_indices, tttr_data, minimum_number_of_photons, tttr_irf, m0_irf, m1_irf, dt, background, m0_bg, m1_bg, background_fraction)

    def __eq__(self, other):
        r"""
        __eq__(self, other) -> bool

        Parameters
        ----------
        other: TTTRRange const &

        """
        return _tttrlib.TTTRRange___eq__(self, other)

    def __ne__(self, other):
        r"""
        __ne__(self, other) -> bool

        Parameters
        ----------
        other: TTTRRange const &

        """
        return _tttrlib.TTTRRange___ne__(self, other)

    def __iadd__(self, rhs):
        r"""
        __iadd__(self, rhs) -> TTTRRange

        Parameters
        ----------
        rhs: TTTRRange const &

        """
        return _tttrlib.TTTRRange___iadd__(self, rhs)
    tttr_indices = property(_tttrlib.TTTRRange_tttr_indices_get, doc=r"""tttr_indices""")
    start_stop = property(_tttrlib.TTTRRange_start_stop_get, doc=r"""start_stop""")
    start = property(_tttrlib.TTTRRange_start_get, doc=r"""start""")
    stop = property(_tttrlib.TTTRRange_stop_get, doc=r"""stop""")
    __swig_destroy__ = _tttrlib.delete_TTTRRange

# Register TTTRRange in _tttrlib:
_tttrlib.TTTRRange_swigregister(TTTRRange)
class TTTRSelection(TTTRRange):
    r"""


    C++ includes: TTTRSelection.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def get_tttr(self):
        r"""
        get_tttr(self) -> TTTR

        TTTRSelection::get_tttr
        """
        return _tttrlib.TTTRSelection_get_tttr(self)

    def set_tttr(self, tttr):
        r"""
        set_tttr(self, tttr)

        Parameters
        ----------
        tttr: TTTR *


        TTTRSelection::set_tttr
        """
        return _tttrlib.TTTRSelection_set_tttr(self, tttr)

    def __init__(self, *args):
        r"""
        __init__(self, start, stop, tttr) -> TTTRSelection

        Parameters
        ----------
        start: int
        stop: int
        tttr: TTTR *

        __init__(self, p2) -> TTTRSelection

        Parameters
        ----------
        p2: TTTRSelection const &

        __init__(self, tttr=0) -> TTTRSelection

        Parameters
        ----------
        tttr: std::shared_ptr< TTTR >


        TTTRSelection::TTTRSelection
        """
        _tttrlib.TTTRSelection_swiginit(self, _tttrlib.new_TTTRSelection(*args))
    tttr_indices = property(_tttrlib.TTTRSelection_tttr_indices_get, doc=r"""tttr_indices""")
    __swig_destroy__ = _tttrlib.delete_TTTRSelection

# Register TTTRSelection in _tttrlib:
_tttrlib.TTTRSelection_swigregister(TTTRSelection)

def selection_by_count_rate(time, time_window, n_ph_max, macro_time_calibration=1.0, invert=False, make_mask=False):
    r"""
    selection_by_count_rate(time, time_window, n_ph_max, macro_time_calibration=1.0, invert=False, make_mask=False)

    Parameters
    ----------
    time: unsigned long long *
    time_window: double
    n_ph_max: int
    macro_time_calibration: double
    invert: bool
    make_mask: bool



    A count rate (cr) filter that returns an array containing a list of indices
    where the cr was smaller than a specified cr.  

    The filter is applied to a series of consecutive time events. The time events
    are sliced into time windows tw) which have at least a duration as specified by
    time_window. The tttr indices of the time windows are written to the output
    parameter output. Moreover, for every tw the number of photons is determined. If
    in a tw the number of photons exceeds n_ph_max and invert is false (default) the
    tw is not written to output. If If in a tw the number of photons is less then
    n_ph_max and invert is true the tw is not written to output.  

    Parameters
    ----------
    * `selection` :  
        output array  
    * `n_selected` :  
        number of elements in output array  
    * `time` :  
        array of times  
    * `n_time` :  
        number of times  
    * `time_window` :  
        length of the time window  
    * `n_ph_max` :  
        maximum number of photons in a time window  
    * `macro_time_calibration` :  
    * `invert` :  
        if invert is true (default false) only indices where the number of photons
        exceeds n_ph_max are selected  

    """
    return _tttrlib.selection_by_count_rate(time, time_window, n_ph_max, macro_time_calibration, invert, make_mask)

def ranges_by_time_window(input, minimum_window_length, maximum_window_length=-1, minimum_number_of_photons_in_time_window=-1, maximum_number_of_photons_in_time_window=-1, macro_time_calibration=1.0, invert=False):
    r"""
    ranges_by_time_window(input, minimum_window_length, maximum_window_length=-1, minimum_number_of_photons_in_time_window=-1, maximum_number_of_photons_in_time_window=-1, macro_time_calibration=1.0, invert=False)

    Parameters
    ----------
    input: unsigned long long *
    minimum_window_length: double
    maximum_window_length: double
    minimum_number_of_photons_in_time_window: int
    maximum_number_of_photons_in_time_window: int
    macro_time_calibration: double
    invert: bool



    Returns time windows (tw), i.e., the start and the stop indices for a minimum tw
    size, a minimum number of photons in a tw.  

    Parameters
    ----------
    * `output` :  
        [out] Array containing the interleaved start and stop indices of the tws in
        the TTTR object.  
    * `n_output` :  
        [out] Length of the output array  
    * `input` :  
        [in] Array containing the macro times  
    * `n_input` :  
        [in] Number of macro times  
    * `minimum_window_length` :  
        [in] Minimum length of a tw (mandatory).  
    * `maximum_window_length` :  
        [in] Maximum length of a tw (optional).  
    * `minimum_number_of_photons_in_time_window` :  
        [in] Minimum number of photons a selected tw contains (optional)  
    * `maximum_number_of_photons_in_time_window` :  
        [in] Maximum number of photons a selected tw contains (optional)  
    * `invert` :  
        [in] If set to true, the selection criteria are inverted.  

    """
    return _tttrlib.ranges_by_time_window(input, minimum_window_length, maximum_window_length, minimum_number_of_photons_in_time_window, maximum_number_of_photons_in_time_window, macro_time_calibration, invert)

def compute_intensity_trace(input, time_window_length, macro_time_resolution=1.0):
    r"""
    compute_intensity_trace(input, time_window_length, macro_time_resolution=1.0)

    Parameters
    ----------
    input: unsigned long long *
    time_window_length: double
    macro_time_resolution: double



    Computes a intensity trace for a sequence of time events  

    The intensity trace is computed by splitting the trace of time events into time
    windows (tws) with a minimum specified length and counts the number of photons
    in each tw.  

    Parameters
    ----------
    * `output` :  
        number of photons in each time window  
    * `n_output` :  
        number of time windows  
    * `input` :  
        array of time points  
    * `n_input` :  
        number number of time points  
    * `time_window` :  
        time window size in units of the macro time resolution  
    * `macro_time_resolution` :  
        the resolution of the macro time clock  

    """
    return _tttrlib.compute_intensity_trace(input, time_window_length, macro_time_resolution)
class TTTR(object):
    r"""


    C++ includes: TTTR.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def Get(self):
        r"""
        Get(self) -> std::shared_ptr< TTTR >

        TTTR::Get
        Make shared pointer.  

        """
        return _tttrlib.TTTR_Get(self)

    def copy_from(self, p2, include_big_data=True):
        r"""
        copy_from(self, p2, include_big_data=True)

        Parameters
        ----------
        p2: TTTR const &
        include_big_data: bool


        TTTR::copy_from
        Copy the information from another TTTR object  

        Parameters
        ----------
        * `p2` :  
            the TTTR object which which the information is copied from  
        * `include_big_data` :  
            if this is true also the macro time, micro time etc. are copied. Otherwise
            all other is copied  

        """
        return _tttrlib.TTTR_copy_from(self, p2, include_big_data)

    def read_file(self, fn=None, container_type=-1):
        r"""
        read_file(self, fn=None, container_type=-1) -> int

        Parameters
        ----------
        fn: char const *
        container_type: int


        TTTR::read_file
        Reads the TTTR data contained in a file into the TTTR object  

        Parameters
        ----------
        * `fn` :  
            The filename that is read. If fn is a nullptr (default value is nullptr) the
            filename attribute of the TTTR object is used as filename.  
        * `container_type` :  
            The container type.  

        Returns
        -------
        Returns 1 in case the file was read without errors. Otherwise 0 is returned.  

        """
        return _tttrlib.TTTR_read_file(self, fn, container_type)

    @staticmethod
    def get_number_of_records_by_file_size(fp, offset, bytes_per_record):
        r"""
        get_number_of_records_by_file_size(fp, offset, bytes_per_record) -> size_t

        Parameters
        ----------
        fp: std::FILE *
        offset: size_t
        bytes_per_record: size_t


        TTTR::get_number_of_records_by_file_size
        Determines the number of records in a TTTR files (not for use with HDF5)  

        Calculates the number of records in the file based on the file size. if  

        Parameters
        ----------
        * `offset` :  
            is passed the number of records is calculated by the file size the number of
            bytes in the file - offset and  
        * `bytes_per_record.` :  
            If  
        * `offset` :  
            is not specified the current location of the file pointer is used as an
            offset. If  
        * `bytes_per_record` :  
            is not specified the attribute value bytes_per_record of the class instance
            is used.  
        * `offset` :  
        * `bytes_per_record` :  

        """
        return _tttrlib.TTTR_get_number_of_records_by_file_size(fp, offset, bytes_per_record)

    def append_events(self, macro_times, micro_times, routing_channels, event_types, shift_macro_time=True, macro_time_offset=0):
        r"""
        append_events(self, macro_times, micro_times, routing_channels, event_types, shift_macro_time=True, macro_time_offset=0)

        Parameters
        ----------
        macro_times: unsigned long long *
        micro_times: unsigned short *
        routing_channels: signed char *
        event_types: signed char *
        shift_macro_time: bool
        macro_time_offset: long long


        TTTR::append_events
        """
        return _tttrlib.TTTR_append_events(self, macro_times, micro_times, routing_channels, event_types, shift_macro_time, macro_time_offset)

    def append_event(self, macro_time, micro_time, routing_channel, event_type, shift_macro_time=True, macro_time_offset=0):
        r"""
        append_event(self, macro_time, micro_time, routing_channel, event_type, shift_macro_time=True, macro_time_offset=0)

        Parameters
        ----------
        macro_time: unsigned long long
        micro_time: unsigned short
        routing_channel: signed char
        event_type: signed char
        shift_macro_time: bool
        macro_time_offset: long long


        TTTR::append_event
        """
        return _tttrlib.TTTR_append_event(self, macro_time, micro_time, routing_channel, event_type, shift_macro_time, macro_time_offset)

    def append(self, other, shift_macro_time=True, macro_time_offset=0):
        r"""
        append(self, other, shift_macro_time=True, macro_time_offset=0)

        Parameters
        ----------
        other: TTTR const *
        shift_macro_time: bool
        macro_time_offset: long long


        TTTR::append
        """
        return _tttrlib.TTTR_append(self, other, shift_macro_time, macro_time_offset)

    def size(self):
        r"""
        size(self) -> size_t

        TTTR::size
        """
        return _tttrlib.TTTR_size(self)

    def get_used_routing_channels(self):
        r"""
        get_used_routing_channels(self)

        TTTR::get_used_routing_channels
        Returns an array containing the routing channel numbers that are contained
        (used) in the TTTR file.  

        Parameters
        ----------
        * `output` :  
            Pointer to the output array  
        * `n_output` :  
            Pointer to the number of elements in the output array  

        """
        return _tttrlib.TTTR_get_used_routing_channels(self)

    def get_macro_times(self):
        r"""
        get_macro_times(self)

        TTTR::get_macro_times
        Returns an array containing the macro times of the valid TTTR events.  

        Parameters
        ----------
        * `output` :  
            Pointer to the output array  
        * `n_output` :  
            Pointer to the number of elements in the output array  

        """
        return _tttrlib.TTTR_get_macro_times(self)

    def get_micro_times(self):
        r"""
        get_micro_times(self)

        TTTR::get_micro_times
        Returns an array containing the micro times of the valid TTTR events.  

        Parameters
        ----------
        * `output` :  
            Pointer to the output array  
        * `n_output` :  
            Pointer to the number of elements in the output array  

        """
        return _tttrlib.TTTR_get_micro_times(self)

    def get_intensity_trace(self, time_window_length=1.0):
        r"""
        get_intensity_trace(self, time_window_length=1.0)

        Parameters
        ----------
        time_window_length: double


        TTTR::get_intensity_trace
        Returns a intensity trace that is computed for a specified integration window  

        Parameters
        ----------
        * `output` :  
            the returned intensity trace  
        * `n_output` :  
            the number of points in the intensity trace  
        * `time_window_length` :  
            the length of the integration time windows in units of milliseconds.  

        """
        return _tttrlib.TTTR_get_intensity_trace(self, time_window_length)

    def get_routing_channel(self):
        r"""
        get_routing_channel(self)

        TTTR::get_routing_channel
        Returns an array containing the routing channel numbers of the valid TTTR
        events.  

        Parameters
        ----------
        * `output` :  
            Pointer to the output array  
        * `n_output` :  
            Pointer to the number of elements in the output array  

        """
        return _tttrlib.TTTR_get_routing_channel(self)

    def get_event_type(self):
        r"""
        get_event_type(self)

        TTTR::get_event_type
        Parameters
        ----------
        * `output` :  
            Pointer to the output array  
        * `n_output` :  
            Pointer to the number of elements in the output array  

        """
        return _tttrlib.TTTR_get_event_type(self)

    def get_number_of_micro_time_channels(self):
        r"""
        get_number_of_micro_time_channels(self) -> unsigned int

        TTTR::get_number_of_micro_time_channels
        Returns the number of micro time channels that fit between two macro time
        clocks.  

        Returns
        -------
        maximum valid number of micro time channels  

        """
        return _tttrlib.TTTR_get_number_of_micro_time_channels(self)

    def get_n_valid_events(self):
        r"""
        get_n_valid_events(self) -> size_t

        TTTR::get_n_valid_events
        Returns
        -------
        number of valid events in the TTTR file  

        """
        return _tttrlib.TTTR_get_n_valid_events(self)

    def get_tttr_container_type(self):
        r"""
        get_tttr_container_type(self) -> std::string

        TTTR::get_tttr_container_type
        Returns
        -------
        the container type that was used to open the file  

        """
        return _tttrlib.TTTR_get_tttr_container_type(self)

    def select(self, selection):
        r"""
        select(self, selection) -> std::shared_ptr< TTTR >

        Parameters
        ----------
        selection: int *


        TTTR::select
        """
        return _tttrlib.TTTR_select(self, selection)

    def __init__(self, *args):
        r"""
        __init__(self) -> TTTR
        __init__(self, p2) -> TTTR

        Parameters
        ----------
        p2: TTTR const &

        __init__(self, filename, container_type, read_input) -> TTTR

        Parameters
        ----------
        filename: char const *
        container_type: int
        read_input: bool

        __init__(self, filename) -> TTTR

        Parameters
        ----------
        filename: char const *

        __init__(self, filename, container_type) -> TTTR

        Parameters
        ----------
        filename: char const *
        container_type: int

        __init__(self, filename, container_type) -> TTTR

        Parameters
        ----------
        filename: char const *
        container_type: char const *

        __init__(self, macro_times, micro_times, routing_channels, event_types, find_used_channels=True) -> TTTR

        Parameters
        ----------
        macro_times: unsigned long long *
        micro_times: unsigned short *
        routing_channels: signed char *
        event_types: signed char *
        find_used_channels: bool

        __init__(self, parent, selection, find_used_channels=True) -> TTTR

        Parameters
        ----------
        parent: TTTR const &
        selection: int *
        find_used_channels: bool


        TTTR::TTTR
        This constructor can be used to create a new TTTR object that only contains
        records that are specified in the selection array.  

        The selection array is an array of indices. The events with indices in the
        selection array are copied in the order of the selection array to a new TTTR
        object.  

        Parameters
        ----------
        * `parent` :  
        * `selection` :  
        * `n_selection` :  
        * `find_used_channels` :  
            if set to true (default) searches all indices to find the used routing
            channels  

        """
        _tttrlib.TTTR_swiginit(self, _tttrlib.new_TTTR(*args))
    __swig_destroy__ = _tttrlib.delete_TTTR

    def get_filename(self):
        r"""
        get_filename(self) -> std::string

        TTTR::get_filename
        getFilename Getter for the filename of the TTTR file  

        Returns
        -------
        The filename of the TTTR file  

        """
        return _tttrlib.TTTR_get_filename(self)

    def get_tttr_by_selection(self, selection):
        r"""
        get_tttr_by_selection(self, selection) -> std::shared_ptr< TTTR >

        Parameters
        ----------
        selection: int *


        TTTR::get_tttr_by_selection
        Get a ptr to a TTTR object that is based on a selection on the current TTTR
        object. A selection is an array of indices of the TTTR events.  

        Parameters
        ----------
        * `selection` :  
        * `n_selection` :  

        Returns
        -------  

        """
        return _tttrlib.TTTR_get_tttr_by_selection(self, selection)

    def get_ranges_by_time_window(self, minimum_window_length, maximum_window_length=-1, minimum_number_of_photons_in_time_window=-1, maximum_number_of_photons_in_time_window=-1, macro_time_calibration=-1, invert=False):
        r"""
        get_ranges_by_time_window(self, minimum_window_length, maximum_window_length=-1, minimum_number_of_photons_in_time_window=-1, maximum_number_of_photons_in_time_window=-1, macro_time_calibration=-1, invert=False)

        Parameters
        ----------
        minimum_window_length: double
        maximum_window_length: double
        minimum_number_of_photons_in_time_window: int
        maximum_number_of_photons_in_time_window: int
        macro_time_calibration: double
        invert: bool


        TTTR::get_ranges_by_time_window
        Returns time windows (tw), i.e., the start and the stop indices for a minimum tw
        size, a minimum number of photons in a tw.  

        Parameters
        ----------
        * `output` :  
            [out] Array containing the interleaved start and stop indices of the tws in
            the TTTR object.  
        * `n_output` :  
            [out] Length of the output array  
        * `minimum_window_length` :  
            [in] Minimum length of a tw (mandatory).  
        * `maximum_window_length` :  
            [in] Maximum length of a tw (optional).  
        * `minimum_number_of_photons_in_time_window` :  
            [in] Minimum number of photons a selected tw contains (optional)  
        * `maximum_number_of_photons_in_time_window` :  
            [in] Maximum number of photons a selected tw contains (optional)  
        * `invert` :  
            [in] If set to true, the selection criteria are inverted.  

        """
        return _tttrlib.TTTR_get_ranges_by_time_window(self, minimum_window_length, maximum_window_length, minimum_number_of_photons_in_time_window, maximum_number_of_photons_in_time_window, macro_time_calibration, invert)

    def get_selection_by_channel(self, input):
        r"""
        get_selection_by_channel(self, input)

        Parameters
        ----------
        input: signed char *


        TTTR::get_selection_by_channel
        Get events indices by the routing channel number  

        This method returns an array that contains the event / photon indices of events
        with routing channel numbers that are found in the selection input array.  

        Parameters
        ----------
        * `output` :  
            indices of the events  
        * `n_output` :  
            number of selected events  
        * `input` :  
            routing channel number for selection of events  
        * `n_input` :  
            number of routing channels for selection of events  

        """
        return _tttrlib.TTTR_get_selection_by_channel(self, input)

    def get_tttr_by_channel(self, input):
        r"""
        get_tttr_by_channel(self, input) -> std::shared_ptr< TTTR >

        Parameters
        ----------
        input: signed char *


        TTTR::get_tttr_by_channel
        """
        return _tttrlib.TTTR_get_tttr_by_channel(self, input)

    def get_selection_by_count_rate(self, time_window, n_ph_max, invert=False, make_mask=False):
        r"""
        get_selection_by_count_rate(self, time_window, n_ph_max, invert=False, make_mask=False)

        Parameters
        ----------
        time_window: double
        n_ph_max: int
        invert: bool
        make_mask: bool


        TTTR::get_selection_by_count_rate
        List of indices where the count rate is smaller than a maximum count rate  

        The count rate is specified by providing a time window that slides over the time
        array and the maximum number of photons within the time window.  

        Parameters
        ----------
        * `output` :  
            the output array that will contain the selected indices  
        * `n_output` :  
            the number of elements in the output array  
        * `time_window` :  
            the length of the time window in milliseconds  
        * `n_ph_max` :  
            the maximum number of photons within a time window  

        """
        return _tttrlib.TTTR_get_selection_by_count_rate(self, time_window, n_ph_max, invert, make_mask)

    def get_tttr_by_count_rate(self, time_window, n_ph_max, invert=False, make_mask=False):
        r"""
        get_tttr_by_count_rate(self, time_window, n_ph_max, invert=False, make_mask=False) -> std::shared_ptr< TTTR >

        Parameters
        ----------
        time_window: double
        n_ph_max: int
        invert: bool
        make_mask: bool


        TTTR::get_tttr_by_count_rate
        """
        return _tttrlib.TTTR_get_tttr_by_count_rate(self, time_window, n_ph_max, invert, make_mask)

    def get_time_window_ranges(self, minimum_window_length, minimum_number_of_photons_in_time_window, maximum_number_of_photons_in_time_window=-1, maximum_window_length=-1.0, macro_time_calibration=-1, invert=False):
        r"""
        get_time_window_ranges(self, minimum_window_length, minimum_number_of_photons_in_time_window, maximum_number_of_photons_in_time_window=-1, maximum_window_length=-1.0, macro_time_calibration=-1, invert=False)

        Parameters
        ----------
        minimum_window_length: double
        minimum_number_of_photons_in_time_window: int
        maximum_number_of_photons_in_time_window: int
        maximum_window_length: double
        macro_time_calibration: double
        invert: bool


        TTTR::get_time_window_ranges
        Returns time windows (tw), i.e., the start and the stop indices for a minimum tw
        size, a minimum number of photons in a tw.  

        Parameters
        ----------
        * `output[out]` :  
            Array containing the interleaved start and stop indices of the tws in the
            TTTR object.  
        * `n_output[out]` :  
            Length of the output array  
        * `minimum_window_length[in]` :  
            Minimum length of a tw in units of ms (mandatory).  
        * `maximum_window_length[in]` :  
            Maximum length of a tw (optional).  
        * `minimum_number_of_photons_in_time_window[in]` :  
            Minimum number of photons a selected tw contains (optional) in units of
            seconds  
        * `maximum_number_of_photons_in_time_window[in]` :  
            Maximum number of photons a selected tw contains (optional)  
        * `invert[in]` :  
            If set to true, the selection criteria are inverted.  

        """
        return _tttrlib.TTTR_get_time_window_ranges(self, minimum_window_length, minimum_number_of_photons_in_time_window, maximum_number_of_photons_in_time_window, maximum_window_length, macro_time_calibration, invert)

    def get_header(self):
        r"""
        get_header(self) -> TTTRHeader

        TTTR::get_header
        Get header returns the header (if present) as a map of strings.  

        """
        return _tttrlib.TTTR_get_header(self)

    def set_header(self, v):
        r"""
        set_header(self, v)

        Parameters
        ----------
        v: TTTRHeader *


        TTTR::set_header
        Set header.  

        """
        return _tttrlib.TTTR_set_header(self, v)

    def get_n_events(self):
        r"""
        get_n_events(self) -> size_t

        TTTR::get_n_events
        Returns the number of events in the TTTR file for cases no selection is
        specified otherwise the number of selected events is returned.  

        Returns
        -------  

        """
        return _tttrlib.TTTR_get_n_events(self)

    def write(self, filename, header=None):
        r"""
        write(self, filename, header=None) -> bool

        Parameters
        ----------
        filename: std::string
        header: TTTRHeader *


        TTTR::write
        Write the contents of a opened TTTR file to a new TTTR file.  

        Parameters
        ----------
        * `fn` :  
            filename  
        * `container_type` :  
            container type (PTU; HT3; SPC-130; SPC-600_256; SPC-600_4096; PHOTON-HDF5)
            @oaram write_a_header if set to false no header is written - Writing correct
            headers is not implemented. Therefore, the default value is false.  

        Returns
        -------  

        """
        return _tttrlib.TTTR_write(self, filename, header)

    def write_spc132_events(self, fp, tttr):
        r"""
        write_spc132_events(self, fp, tttr)

        Parameters
        ----------
        fp: FILE *
        tttr: TTTR *


        TTTR::write_spc132_events
        """
        return _tttrlib.TTTR_write_spc132_events(self, fp, tttr)

    def write_hht3v2_events(self, fp, tttr):
        r"""
        write_hht3v2_events(self, fp, tttr)

        Parameters
        ----------
        fp: FILE *
        tttr: TTTR *


        TTTR::write_hht3v2_events
        """
        return _tttrlib.TTTR_write_hht3v2_events(self, fp, tttr)

    def write_header(self, fn, header=None):
        r"""
        write_header(self, fn, header=None)

        Parameters
        ----------
        fn: std::string &
        header: TTTRHeader *


        TTTR::write_header
        """
        return _tttrlib.TTTR_write_header(self, fn, header)

    def shift_macro_time(self, shift):
        r"""
        shift_macro_time(self, shift)

        Parameters
        ----------
        shift: int


        TTTR::shift_macro_time
        Shift the macro time by a constant  

        Parameters
        ----------
        * `shift` :  

        """
        return _tttrlib.TTTR_shift_macro_time(self, shift)

    def __add__(self, other):
        r"""
        __add__(self, other) -> TTTR

        Parameters
        ----------
        other: TTTR const *

        """
        return _tttrlib.TTTR___add__(self, other)

    @staticmethod
    def compute_microtime_histogram(tttr_data, micro_time_coarsening=1, tttr_indices=None):
        r"""
        compute_microtime_histogram(tttr_data, micro_time_coarsening=1, tttr_indices=None)

        Parameters
        ----------
        tttr_data: TTTR *
        micro_time_coarsening: unsigned short
        tttr_indices: std::vector< int,std::allocator< int > > *


        TTTR::compute_microtime_histogram
        Computes a histogram of the TTTR data's micro times  

        Parameters
        ----------
        * `tttr_data` :  
            a pointer to the TTTR data  
        * `histogram` :  
            pointer to which the histogram will be written (the memory is allocated but
            the method)  
        * `n_histogram` :  
            the number of points in the histogram  
        * `time` :  
            pointer to the time axis of the histogram (the memory is allocated by the
            method)  
        * `n_time` :  
            the number of points in the time axis  
        * `micro_time_coarsening` :  
            a factor by which the micro times in the TTTR object are divided (default
            value is 1).  

        """
        return _tttrlib.TTTR_compute_microtime_histogram(tttr_data, micro_time_coarsening, tttr_indices)

    def get_microtime_histogram(self, micro_time_coarsening=1):
        r"""
        get_microtime_histogram(self, micro_time_coarsening=1)

        Parameters
        ----------
        micro_time_coarsening: unsigned short


        TTTR::get_microtime_histogram
        """
        return _tttrlib.TTTR_get_microtime_histogram(self, micro_time_coarsening)

    @staticmethod
    def compute_mean_lifetime(tttr_data, tttr_irf=None, m0_irf=1, m1_irf=0, tttr_indices=None, dt=-1.0, minimum_number_of_photons=1, background=None, m0_bg=0.0, m1_bg=0.0, background_fraction=-1.0):
        r"""
        compute_mean_lifetime(tttr_data, tttr_irf=None, m0_irf=1, m1_irf=0, tttr_indices=None, dt=-1.0, minimum_number_of_photons=1, background=None, m0_bg=0.0, m1_bg=0.0, background_fraction=-1.0) -> double

        Parameters
        ----------
        tttr_data: TTTR *
        tttr_irf: TTTR *
        m0_irf: double
        m1_irf: double
        tttr_indices: std::vector< int,std::allocator< int > > *
        dt: double
        minimum_number_of_photons: int
        background: std::vector< double,std::allocator< double > > *
        m0_bg: double
        m1_bg: double
        background_fraction: double


        TTTR::compute_mean_lifetime
        Compute a mean lifetime by the moments of the decay and the instrument response
        function.  

        The computed lifetime is the first lifetime determined by the method of moments
        (Irvin Isenberg, 1973, Biophysical journal).  

        Parameters
        ----------
        * `tttr_data` :  
            TTTR object for which the lifetime is computed  
        * `tttr_irf` :  
            TTTR object that is used as IRF  
        * `m0_irf[in]` :  
            Number of counts in the IRF (used if no TTTR object for IRF provided.  
        * `m1_irf[in]` :  
            First moment of the IRF (used if no TTTR object for IRF provided.  
        * `tttr_indices[in]` :  
            Optional list of indices for selecting a subset of the TTTR  
        * `dt[in]` :  
            Time resolution of the micro time. If not provided extracted from the header
            (slow)  
        * `minimum_number_of_photons[in]` :  
            Minimum number of photons. If less photons are in the dataset returns -1 as
            computed lifetime  
        * `background` :  
            background pattern  
        * `m0_bg` :  
            sum of background photons (overwritten if background pattern not empty)  
        * `m1_bg` :  
            first moment of background pattern (overwritten if background pattern not
            empty)  
        * `background_fraction` :  
            background fraction (if negative background is not scaled)  

        Returns
        -------
        The computed lifetime  

        """
        return _tttrlib.TTTR_compute_mean_lifetime(tttr_data, tttr_irf, m0_irf, m1_irf, tttr_indices, dt, minimum_number_of_photons, background, m0_bg, m1_bg, background_fraction)

    def mean_lifetime(self, tttr_irf=None, m0_irf=1, m1_irf=1, tttr_indices=None, dt=-1.0, min_ph=1):
        r"""
        mean_lifetime(self, tttr_irf=None, m0_irf=1, m1_irf=1, tttr_indices=None, dt=-1.0, min_ph=1) -> double

        Parameters
        ----------
        tttr_irf: TTTR *
        m0_irf: int
        m1_irf: int
        tttr_indices: std::vector< int,std::allocator< int > > *
        dt: double
        min_ph: int


        TTTR::mean_lifetime
        Compute the mean lifetime by the moments of the decay and the instrument
        response function.  

        """
        return _tttrlib.TTTR_mean_lifetime(self, tttr_irf, m0_irf, m1_irf, tttr_indices, dt, min_ph)

    @staticmethod
    def compute_count_rate(tttr_data, tttr_indices=None, macrotime_resolution=-1.0):
        r"""
        compute_count_rate(tttr_data, tttr_indices=None, macrotime_resolution=-1.0) -> double

        Parameters
        ----------
        tttr_data: TTTR *
        tttr_indices: std::vector< int,std::allocator< int > > *
        macrotime_resolution: double


        TTTR::compute_count_rate
        Compute the count rate  

        Parameters
        ----------
        * `tttr_data[in]` :  
            TTTR object for which the lifetime is computed  
        * `macrotime_resolution[in]` :  
            If negative (default) reads macrotime resolution from header (slow)  

        Returns
        -------
        Count rate  

        """
        return _tttrlib.TTTR_compute_count_rate(tttr_data, tttr_indices, macrotime_resolution)

    def get_count_rate(self, tttr_indices=None, macrotime_resolution=-1.0):
        r"""
        get_count_rate(self, tttr_indices=None, macrotime_resolution=-1.0) -> double

        Parameters
        ----------
        tttr_indices: std::vector< int,std::allocator< int > > *
        macrotime_resolution: double


        TTTR::get_count_rate
        """
        return _tttrlib.TTTR_get_count_rate(self, tttr_indices, macrotime_resolution)

    @staticmethod
    def compute_mean_microtime(tttr_data, tttr_indices=None, microtime_resolution=-1.0, minimum_number_of_photons=1):
        r"""
        compute_mean_microtime(tttr_data, tttr_indices=None, microtime_resolution=-1.0, minimum_number_of_photons=1) -> double

        Parameters
        ----------
        tttr_data: TTTR *
        tttr_indices: std::vector< int,std::allocator< int > > *
        microtime_resolution: double
        minimum_number_of_photons: int


        TTTR::compute_mean_microtime
        """
        return _tttrlib.TTTR_compute_mean_microtime(tttr_data, tttr_indices, microtime_resolution, minimum_number_of_photons)

    def get_mean_microtime(self, tttr_indices=None, microtime_resolution=-1.0, minimum_number_of_photons=1):
        r"""
        get_mean_microtime(self, tttr_indices=None, microtime_resolution=-1.0, minimum_number_of_photons=1) -> double

        Parameters
        ----------
        tttr_indices: std::vector< int,std::allocator< int > > *
        microtime_resolution: double
        minimum_number_of_photons: int


        TTTR::get_mean_microtime
        """
        return _tttrlib.TTTR_get_mean_microtime(self, tttr_indices, microtime_resolution, minimum_number_of_photons)


    @property
    def routing_channels(self):
        return self.get_routing_channel()

    @property
    def event_types(self):
        return self.get_event_type()

    def __getattr__(self, item):
        """
        If an attribute `attribute` is accesses that does not exist
        the corresponding getter by calling 'get_attribute' is called

        :param self:
        :param item:
        :return:
        """
        item = "get_" + str(item)
        if hasattr(self.__class__, item):
            call = getattr(self, item)
            return call()
        else:
            raise AttributeError

    def __len__(self):
        return self.get_n_valid_events()

    def __getitem__(self, key):
        if isinstance(key, tuple):
            key = np.array(key)
        if isinstance(key, slice):
            sel = np.arange(*key.indices(self.get_n_valid_events()), dtype=np.int32)
        elif isinstance(key, np.ndarray):
            sel = key.astype(np.int32)
        else:
            sel = np.array([key], dtype=np.int32)
        return TTTR(self, sel)

    def __add__(self, value):
        t = TTTR(self)
        t.append(value)
        return t

    def __init__(self, *args, **kwargs):
        if len(args) > 0:
            import pathlib
            if isinstance(args[0], str) or isinstance(args[0], pathlib.Path):
                if len(args) == 1:
                    obj = str(pathlib.Path(args[0]).absolute().as_posix())
                    this = _tttrlib.new_TTTR(obj)
                else:
                    this = _tttrlib.new_TTTR(*args, **kwargs)
            else:
                this = _tttrlib.new_TTTR(*args, **kwargs)
        else:
            this = _tttrlib.new_TTTR(*args, **kwargs)
        self.this = this

    def __repr__(self):
        return 'TTTR("%s", "%s")' % (
            self.get_filename(),
            self.get_tttr_container_type()
        )

    def __str__(self):
        s = "Filename: %s \n" % self.get_filename()
        s += "Number of valid events: %d \n" % self.get_n_events()
        s += "Number of micro time channels: %d \n" % self.get_number_of_micro_time_channels()
        s += "Used routing channels: %s " % self.get_used_routing_channels()
        return s



# Register TTTR in _tttrlib:
_tttrlib.TTTR_swigregister(TTTR)
class TTTRMask(object):
    r"""


    C++ includes: TTTRMask.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _tttrlib.delete_TTTRMask

    def __init__(self, *args):
        r"""
        __init__(self) -> TTTRMask
        __init__(self, data) -> TTTRMask

        Parameters
        ----------
        data: TTTR *


        TTTRMask::TTTRMask
        """
        _tttrlib.TTTRMask_swiginit(self, _tttrlib.new_TTTRMask(*args))

    def size(self):
        r"""
        size(self) -> int

        TTTRMask::size
        """
        return _tttrlib.TTTRMask_size(self)

    def flip(self):
        r"""flip(self)"""
        return _tttrlib.TTTRMask_flip(self)

    def set_mask(self, mask):
        r"""
        set_mask(self, mask)

        Parameters
        ----------
        mask: std::vector< bool,std::allocator< bool > >


        TTTRMask::set_mask
        """
        return _tttrlib.TTTRMask_set_mask(self, mask)

    def get_mask(self):
        r"""
        get_mask(self) -> VectorBool

        TTTRMask::get_mask
        """
        return _tttrlib.TTTRMask_get_mask(self)

    def set_tttr(self, tttr):
        r"""
        set_tttr(self, tttr)

        Parameters
        ----------
        tttr: TTTR *


        TTTRMask::set_tttr
        """
        return _tttrlib.TTTRMask_set_tttr(self, tttr)

    def select_channels(self, tttr, routing_channels, mask=False):
        r"""
        select_channels(self, tttr, routing_channels, mask=False)

        Parameters
        ----------
        tttr: TTTR *
        routing_channels: signed char *
        mask: bool


        TTTRMask::select_channels
        Selects a subset of indices by a list of routing channel numbers.  

        The returned set of indices will have routing channel numbers that are in the
        list of the provided routing channel numbers.  

        Parameters
        ----------
        * `tttr` :  
            pointer to TTTR object  
        * `routing_channels[int]` :  
            routing channel numbers. A subset of this array will be selected by the
            input.  
        * `n_routing_channels[int]` :  
            length of the routing channel number array.  

        """
        return _tttrlib.TTTRMask_select_channels(self, tttr, routing_channels, mask)

    def select_count_rate(self, tttr, time_window, n_ph_max, invert):
        r"""
        select_count_rate(self, tttr, time_window, n_ph_max, invert)

        Parameters
        ----------
        tttr: TTTR *
        time_window: double
        n_ph_max: int
        invert: bool


        TTTRMask::select_count_rate
        Selects a subset of indices a count rate of a sliding time-window  

        Parameters
        ----------
        * `tttr` :  
            pointer to TTTR object  
        * `time_window` :  
            time window size in units of seconds  
        * `n_ph_max` :  
            maximum number of photons in time window  
        * `invert` :  
            boolean used to invert selection  

        """
        return _tttrlib.TTTRMask_select_count_rate(self, tttr, time_window, n_ph_max, invert)

    def select_microtime_ranges(self, *args, **kwargs):
        r"""
        select_microtime_ranges(self, tttr, micro_time_ranges=std::vector< std::pair< int,int > >())

        Parameters
        ----------
        tttr: TTTR *
        micro_time_ranges: std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > >


        TTTRMask::select_microtime_ranges
        Masks outside the provides micro time ranges  

        Parameters
        ----------
        * `tttr` :  
        * `micro_time_ranges` :  
        * `mask` :  

        """
        return _tttrlib.TTTRMask_select_microtime_ranges(self, *args, **kwargs)

    def get_indices(self, selected=True):
        r"""
        get_indices(self, selected=True) -> VectorInt32

        Parameters
        ----------
        selected: bool


        TTTRMask::get_indices
        Parameters
        ----------
        * `selected` :  
            if selected is true returns selected (unmasked) indices otherwise masked
            indices are returned  

        Returns
        -------  

        """
        return _tttrlib.TTTRMask_get_indices(self, selected)

    def get_selected_ranges(self):
        r"""
        get_selected_ranges(self) -> VectorInt32

        TTTRMask::get_selected_ranges
        """
        return _tttrlib.TTTRMask_get_selected_ranges(self)

    def __getattr__(self, item):
        """
        If an attribute `attribute` is accesses that does not exist
        the corresponding getter by calling 'get_attribute' is called

        :param self:
        :param item:
        :return:
        """
        item = "get_" + str(item)
        if hasattr(self.__class__, item):
            call = getattr(self, item)
            return call()
        else:
            raise AttributeError

    def __len__(self):
        return len(self.get_indices())



# Register TTTRMask in _tttrlib:
_tttrlib.TTTRMask_swigregister(TTTRMask)

def bincount1D(data, bins, n_bins):
    r"""
    bincount1D(data, bins, n_bins)

    Parameters
    ----------
    data: int *
    bins: int *
    n_bins: int



    """
    return _tttrlib.bincount1D(data, bins, n_bins)

def histogram1D_int(data, weights, bin_edges, hist, axis_type, use_weights):
    r"""
    histogram1D_int(data, weights, bin_edges, hist, axis_type, use_weights)

    Parameters
    ----------
    data: int *
    weights: double *
    bin_edges: int *
    hist: double *
    axis_type: char const *
    use_weights: bool



    templateparam
    -------------
    * `T` :  

    Parameters
    ----------
    * `data` :  
    * `n_data` :  
    * `weights` :  
    * `n_weights` :  
    * `bin_edges` :  
        contains the edges of the histogram in ascending order (from small to large)  
    * `n_bins` :  
        the number of bins in the histogram  
    * `hist` :  
    * `n_hist` :  
    * `axis_type` :  
    * `use_weights` :  
        if true the weights specified by  
    * `weights` :  
        are used for the calculation of the histogram instead of simply counting the
        frequency.  

    """
    return _tttrlib.histogram1D_int(data, weights, bin_edges, hist, axis_type, use_weights)

def histogram1D_double(data, weights, bin_edges, hist, axis_type, use_weights):
    r"""
    histogram1D_double(data, weights, bin_edges, hist, axis_type, use_weights)

    Parameters
    ----------
    data: double *
    weights: double *
    bin_edges: double *
    hist: double *
    axis_type: char const *
    use_weights: bool



    templateparam
    -------------
    * `T` :  

    Parameters
    ----------
    * `data` :  
    * `n_data` :  
    * `weights` :  
    * `n_weights` :  
    * `bin_edges` :  
        contains the edges of the histogram in ascending order (from small to large)  
    * `n_bins` :  
        the number of bins in the histogram  
    * `hist` :  
    * `n_hist` :  
    * `axis_type` :  
    * `use_weights` :  
        if true the weights specified by  
    * `weights` :  
        are used for the calculation of the histogram instead of simply counting the
        frequency.  

    """
    return _tttrlib.histogram1D_double(data, weights, bin_edges, hist, axis_type, use_weights)
class doubleAxis(object):
    r"""


    C++ includes: HistogramAxis.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def update(self):
        r"""
        update(self)

        HistogramAxis::update
        Recalculates the bin edges of the axis  

        """
        return _tttrlib.doubleAxis_update(self)

    def setAxisType(self, axis_type):
        r"""
        setAxisType(self, axis_type)

        Parameters
        ----------
        axis_type: std::string const &


        HistogramAxis::setAxisType
        """
        return _tttrlib.doubleAxis_setAxisType(self, axis_type)

    def getNumberOfBins(self):
        r"""
        getNumberOfBins(self) -> int

        HistogramAxis::getNumberOfBins
        """
        return _tttrlib.doubleAxis_getNumberOfBins(self)

    def getBinIdx(self, value):
        r"""
        getBinIdx(self, value) -> int

        Parameters
        ----------
        value: double


        HistogramAxis::getBinIdx
        """
        return _tttrlib.doubleAxis_getBinIdx(self, value)

    def getBins(self, *args):
        r"""
        getBins(self) -> double
        getBins(self, bin_edges)

        Parameters
        ----------
        bin_edges: double *


        HistogramAxis::getBins
        """
        return _tttrlib.doubleAxis_getBins(self, *args)

    def getName(self):
        r"""
        getName(self) -> std::string const &

        HistogramAxis::getName
        """
        return _tttrlib.doubleAxis_getName(self)

    def setName(self, name):
        r"""
        setName(self, name)

        Parameters
        ----------
        name: std::string const &


        HistogramAxis::setName
        """
        return _tttrlib.doubleAxis_setName(self, name)

    def __init__(self, *args):
        r"""
        __init__(self) -> doubleAxis
        __init__(self, name, begin, end, n_bins, axis_type) -> doubleAxis

        Parameters
        ----------
        name: std::string
        begin: double
        end: double
        n_bins: int
        axis_type: std::string


        HistogramAxis::HistogramAxis
        """
        _tttrlib.doubleAxis_swiginit(self, _tttrlib.new_doubleAxis(*args))
    __swig_destroy__ = _tttrlib.delete_doubleAxis

# Register doubleAxis in _tttrlib:
_tttrlib.doubleAxis_swigregister(doubleAxis)
class doubleHistogram(object):
    r"""


    C++ includes: Histogram.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def update(self, data):
        r"""
        update(self, data)

        Parameters
        ----------
        data: double *


        Histogram::update
        """
        return _tttrlib.doubleHistogram_update(self, data)

    def get_histogram(self):
        r"""
        get_histogram(self)

        Histogram::get_histogram
        """
        return _tttrlib.doubleHistogram_get_histogram(self)

    def set_axis(self, *args):
        r"""
        set_axis(self, data_column, new_axis)

        Parameters
        ----------
        data_column: size_t
        new_axis: HistogramAxis< double > &

        set_axis(self, data_column, name, begin, end, n_bins, axis_type)

        Parameters
        ----------
        data_column: size_t
        name: std::string
        begin: double
        end: double
        n_bins: int
        axis_type: std::string


        Histogram::set_axis
        """
        return _tttrlib.doubleHistogram_set_axis(self, *args)

    def get_axis(self, axis_index):
        r"""
        get_axis(self, axis_index) -> doubleAxis

        Parameters
        ----------
        axis_index: size_t


        Histogram::get_axis
        """
        return _tttrlib.doubleHistogram_get_axis(self, axis_index)

    def __init__(self):
        r"""
        __init__(self) -> doubleHistogram

        Histogram::Histogram
        """
        _tttrlib.doubleHistogram_swiginit(self, _tttrlib.new_doubleHistogram())
    __swig_destroy__ = _tttrlib.delete_doubleHistogram

# Register doubleHistogram in _tttrlib:
_tttrlib.doubleHistogram_swigregister(doubleHistogram)
class TTTRPair(object):
    r"""Proxy of C++ std::pair< std::shared_ptr< TTTR >,std::shared_ptr< TTTR > > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> TTTRPair
        __init__(self, first, second) -> TTTRPair

        Parameters
        ----------
        first: std::shared_ptr< TTTR >
        second: std::shared_ptr< TTTR >

        __init__(self, other) -> TTTRPair

        Parameters
        ----------
        other: std::pair< std::shared_ptr< TTTR >,std::shared_ptr< TTTR > > const &

        """
        _tttrlib.TTTRPair_swiginit(self, _tttrlib.new_TTTRPair(*args))
    first = property(_tttrlib.TTTRPair_first_get, _tttrlib.TTTRPair_first_set, doc=r"""first""")
    second = property(_tttrlib.TTTRPair_second_get, _tttrlib.TTTRPair_second_set, doc=r"""second""")
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _tttrlib.delete_TTTRPair

# Register TTTRPair in _tttrlib:
_tttrlib.TTTRPair_swigregister(TTTRPair)
class CorrelatorPhotonStream(object):
    r"""


    CorrelatorPhotonStream gathers event times and weights.  

    C++ includes: CorrelatorPhotonStream.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(self) -> CorrelatorPhotonStream
        __init__(self, a) -> CorrelatorPhotonStream

        Parameters
        ----------
        a: CorrelatorPhotonStream const &


        CorrelatorPhotonStream::CorrelatorPhotonStream
        """
        _tttrlib.CorrelatorPhotonStream_swiginit(self, _tttrlib.new_CorrelatorPhotonStream(*args))
    __swig_destroy__ = _tttrlib.delete_CorrelatorPhotonStream
    times = property(_tttrlib.CorrelatorPhotonStream_times_get, _tttrlib.CorrelatorPhotonStream_times_set, doc=r"""times""")
    weights = property(_tttrlib.CorrelatorPhotonStream_weights_get, _tttrlib.CorrelatorPhotonStream_weights_set, doc=r"""weights""")

    def empty(self):
        r"""
        empty(self) -> bool

        CorrelatorPhotonStream::empty
        """
        return _tttrlib.CorrelatorPhotonStream_empty(self)

    def size(self):
        r"""
        size(self) -> size_t

        CorrelatorPhotonStream::size
        """
        return _tttrlib.CorrelatorPhotonStream_size(self)

    def clear(self):
        r"""
        clear(self)

        CorrelatorPhotonStream::clear
        """
        return _tttrlib.CorrelatorPhotonStream_clear(self)

    def resize(self, n, x=1.0):
        r"""
        resize(self, n, x=1.0)

        Parameters
        ----------
        n: size_t
        x: double


        CorrelatorPhotonStream::resize
        Parameters
        ----------
        * `n` :  
        * `x` :  
            initial value of the weights  

        """
        return _tttrlib.CorrelatorPhotonStream_resize(self, n, x)

    @staticmethod
    def make_fine_times(t, n_times, tac, n_tac):
        r"""
        make_fine_times(t, n_times, tac, n_tac)

        Parameters
        ----------
        t: unsigned long long *
        n_times: unsigned int
        tac: unsigned short *
        n_tac: unsigned int


        CorrelatorPhotonStream::make_fine_times
        Changes the time events by adding the micro time to the macro time  

        Changes the time events by adding the micro time to the macro time. The micro
        times should match the macro time, i.e., the length of the micro time array
        should be the at least the same length as the macro time array.  

        Parameters
        ----------
        * `t` :  
            An array containing the time events (macro times)  
        * `n_times` :  
            The number of macro times.  
        * `tac` :  
            An array containing the micro times of the corresponding macro times !  

        """
        return _tttrlib.CorrelatorPhotonStream_make_fine_times(t, n_times, tac, n_tac)

    def make_fine(self, tac, number_of_microtime_channels):
        r"""
        make_fine(self, tac, number_of_microtime_channels)

        Parameters
        ----------
        tac: unsigned short *
        number_of_microtime_channels: unsigned int


        CorrelatorPhotonStream::make_fine
        """
        return _tttrlib.CorrelatorPhotonStream_make_fine(self, tac, number_of_microtime_channels)

    def set_weights(self, *args, **kwargs):
        r"""
        set_weights(self, filter, micro_times=std::vector< unsigned int >(), routing_channels=std::vector< signed char >())

        Parameters
        ----------
        filter: std::map< short,std::vector< double,std::allocator< double > >,std::less< short >,std::allocator< std::pair< short const,std::vector< double,std::allocator< double > > > > > const &
        micro_times: std::vector< unsigned int,std::allocator< unsigned int > >
        routing_channels: std::vector< signed char,std::allocator< signed char > >


        CorrelatorPhotonStream::set_weights
        """
        return _tttrlib.CorrelatorPhotonStream_set_weights(self, *args, **kwargs)

    def set_events(self, t, n_t, weight, n_weight):
        r"""
        set_events(self, t, n_t, weight, n_weight)

        Parameters
        ----------
        t: unsigned long long *
        n_t: int
        weight: double *
        n_weight: int


        CorrelatorPhotonStream::set_events
        """
        return _tttrlib.CorrelatorPhotonStream_set_events(self, t, n_t, weight, n_weight)

    def coarsen(self):
        r"""
        coarsen(self)

        CorrelatorPhotonStream::coarsen
        Coarsens the time events  

        This method coarsens the time events by dividing the times by two. In case two
        consecutive time events in the array have the same time, the weights of the two
        events are added to the following weight element and the value of the previous
        weight is set to zero.  

        """
        return _tttrlib.CorrelatorPhotonStream_coarsen(self)

    def dt(self):
        r"""
        dt(self) -> unsigned long long

        CorrelatorPhotonStream::dt
        """
        return _tttrlib.CorrelatorPhotonStream_dt(self)

    def sum_of_weights(self):
        r"""
        sum_of_weights(self) -> double

        CorrelatorPhotonStream::sum_of_weights
        """
        return _tttrlib.CorrelatorPhotonStream_sum_of_weights(self)

    def mean_count_rate(self):
        r"""
        mean_count_rate(self) -> double

        CorrelatorPhotonStream::mean_count_rate
        """
        return _tttrlib.CorrelatorPhotonStream_mean_count_rate(self)

    def set_time_axis_calibration(self, v):
        r"""
        set_time_axis_calibration(self, v)

        Parameters
        ----------
        v: double


        CorrelatorPhotonStream::set_time_axis_calibration
        Set time axis calibration. The time axis calibration if the duration of between
        two sync signals (macro time clock)  

        Parameters
        ----------
        * `v` :  
            time axis calibration (duration between sync clock signals) in seconds  

        """
        return _tttrlib.CorrelatorPhotonStream_set_time_axis_calibration(self, v)

    def get_time_axis_calibration(self):
        r"""
        get_time_axis_calibration(self) -> double

        CorrelatorPhotonStream::get_time_axis_calibration
        Returns
        -------
        The calibration of the time axis in seconds. The time axis calibration is the
        duration of a sync signal (macro time clock).  

        """
        return _tttrlib.CorrelatorPhotonStream_get_time_axis_calibration(self)

    def set_tttr(self, tttr, make_fine=False):
        r"""
        set_tttr(self, tttr, make_fine=False)

        Parameters
        ----------
        tttr: std::shared_ptr< TTTR >
        make_fine: bool


        CorrelatorPhotonStream::set_tttr
        """
        return _tttrlib.CorrelatorPhotonStream_set_tttr(self, tttr, make_fine)

    def get_tttr(self):
        r"""
        get_tttr(self) -> std::shared_ptr< TTTR >

        CorrelatorPhotonStream::get_tttr
        """
        return _tttrlib.CorrelatorPhotonStream_get_tttr(self)

# Register CorrelatorPhotonStream in _tttrlib:
_tttrlib.CorrelatorPhotonStream_swigregister(CorrelatorPhotonStream)
class CorrelationCurveSettings(object):
    r"""


    C++ includes: CorrelatorCurve.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    macro_time_duration = property(_tttrlib.CorrelationCurveSettings_macro_time_duration_get, _tttrlib.CorrelationCurveSettings_macro_time_duration_set, doc=r"""macro_time_duration""")
    n_casc = property(_tttrlib.CorrelationCurveSettings_n_casc_get, _tttrlib.CorrelationCurveSettings_n_casc_set, doc=r"""n_casc""")
    n_bins = property(_tttrlib.CorrelationCurveSettings_n_bins_get, _tttrlib.CorrelationCurveSettings_n_bins_set, doc=r"""n_bins""")

    def get_ncorr(self):
        r"""
        get_ncorr(self) -> unsigned int

        CorrelationCurveSettings::get_ncorr
        The number of points in a correlation curve.  

        """
        return _tttrlib.CorrelationCurveSettings_get_ncorr(self)
    correlation_method = property(_tttrlib.CorrelationCurveSettings_correlation_method_get, _tttrlib.CorrelationCurveSettings_correlation_method_set, doc=r"""correlation_method""")

    def __init__(self):
        r"""
        __init__(self) -> CorrelationCurveSettings


        C++ includes: CorrelatorCurve.h

        """
        _tttrlib.CorrelationCurveSettings_swiginit(self, _tttrlib.new_CorrelationCurveSettings())
    __swig_destroy__ = _tttrlib.delete_CorrelationCurveSettings

# Register CorrelationCurveSettings in _tttrlib:
_tttrlib.CorrelationCurveSettings_swigregister(CorrelationCurveSettings)
class CorrelatorCurve(object):
    r"""


    C++ includes: CorrelatorCurve.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    settings = property(_tttrlib.CorrelatorCurve_settings_get, _tttrlib.CorrelatorCurve_settings_set, doc=r"""settings""")

    def size(self):
        r"""
        size(self) -> size_t

        CorrelatorCurve::size
        """
        return _tttrlib.CorrelatorCurve_size(self)

    def get_x_axis(self):
        r"""
        get_x_axis(self)

        CorrelatorCurve::get_x_axis
        Get the x-axis of the correlation.  

        Parameters
        ----------
        * `x_axis` :  
            a pointer to an array that will contain the x-axis  
        * `n_out` :  
            a pointer to the an integer that will contain the number of elements of the
            x-axis  

        """
        return _tttrlib.CorrelatorCurve_get_x_axis(self)

    def set_x_axis(self, input):
        r"""
        set_x_axis(self, input)

        Parameters
        ----------
        input: std::vector< unsigned long long,std::allocator< unsigned long long > >


        CorrelatorCurve::set_x_axis
        Set the x-axis to arbitray bin values.  

        Attention: Make sure that the correlation method supports arbitray bin spacing  

        """
        return _tttrlib.CorrelatorCurve_set_x_axis(self, input)

    def get_corr(self):
        r"""
        get_corr(self)

        CorrelatorCurve::get_corr
        """
        return _tttrlib.CorrelatorCurve_get_corr(self)

    def get_corr_normalized(self):
        r"""
        get_corr_normalized(self)

        CorrelatorCurve::get_corr_normalized
        """
        return _tttrlib.CorrelatorCurve_get_corr_normalized(self)
    n_bins = property(_tttrlib.CorrelatorCurve_n_bins_get, _tttrlib.CorrelatorCurve_n_bins_set, doc=r"""n_bins""")
    n_casc = property(_tttrlib.CorrelatorCurve_n_casc_get, _tttrlib.CorrelatorCurve_n_casc_set, doc=r"""n_casc""")
    @property
    def x(self):
        return self.get_x_axis()

    @property
    def y(self):
        return self.get_corr_normalized()




    def __init__(self):
        r"""
        __init__(self) -> CorrelatorCurve


        C++ includes: CorrelatorCurve.h

        """
        _tttrlib.CorrelatorCurve_swiginit(self, _tttrlib.new_CorrelatorCurve())
    __swig_destroy__ = _tttrlib.delete_CorrelatorCurve

# Register CorrelatorCurve in _tttrlib:
_tttrlib.CorrelatorCurve_swigregister(CorrelatorCurve)
class Correlator(object):
    r"""


    C++ includes: Correlator.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    p1 = property(_tttrlib.Correlator_p1_get, _tttrlib.Correlator_p1_set, doc=r"""p1""")
    p2 = property(_tttrlib.Correlator_p2_get, _tttrlib.Correlator_p2_set, doc=r"""p2""")
    curve = property(_tttrlib.Correlator_curve_get, _tttrlib.Correlator_curve_set, doc=r"""curve""")

    def dt(self):
        r"""
        dt(self) -> uint64_t

        Correlator::dt
        Computes the the time difference in macro time units the first and the last
        event.  

        """
        return _tttrlib.Correlator_dt(self)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(self, tttr=0, method="wahl", n_bins=17, n_casc=25, make_fine=False) -> Correlator

        Parameters
        ----------
        tttr: std::shared_ptr< TTTR >
        method: std::string
        n_bins: int
        n_casc: int
        make_fine: bool


        Correlator::Correlator
        Parameters
        ----------
        * `tttr` :  
            optional TTTR object. If provided, the macro and micro time calibration of
            the TTTR object header calibrate the correlator.  
        * `method` :  
            name of correlation method that is used by the correlator  
        * `n_bins` :  
            number of equally spaced correlation bins per block (determines correlation
            bins)  
        * `n_casc` :  
            number of blocks (determines correlation bins)  
        * `make_fine` :  
            if true macro and micro time are combined.  

        """
        _tttrlib.Correlator_swiginit(self, _tttrlib.new_Correlator(*args, **kwargs))
    __swig_destroy__ = _tttrlib.delete_Correlator

    def get_curve(self):
        r"""
        get_curve(self) -> CorrelatorCurve

        Correlator::get_curve
        get correlation  

        computes correlation (if necessary) and returns correlation curve  

        Returns
        -------
        correlation curve STOP STOP  

        """
        return _tttrlib.Correlator_get_curve(self)

    def set_microtimes(self, tac_1, tac_2, number_of_microtime_channels):
        r"""
        set_microtimes(self, tac_1, tac_2, number_of_microtime_channels)

        Parameters
        ----------
        tac_1: unsigned short *
        tac_2: unsigned short *
        number_of_microtime_channels: unsigned int


        Correlator::set_microtimes
        Add microtime information to event stream.  

        Parameters
        ----------
        * `tac_1` :  
            The micro times of the first correlation channel  
        * `n_tac_1` :  
            The number of events in the first correlation channel  
        * `tac_2` :  
            The micro times of the second correlation channel  
        * `n_tac_2` :  
            The number of events in the second correlation channel  
        * `number_of_microtime_channels` :  
            The maximum number of TAC channels of the micro times.  

        """
        return _tttrlib.Correlator_set_microtimes(self, tac_1, tac_2, number_of_microtime_channels)

    def set_macrotimes(self, t1, t2):
        r"""
        set_macrotimes(self, t1, t2)

        Parameters
        ----------
        t1: unsigned long long *
        t2: unsigned long long *


        Correlator::set_macrotimes
        Parameters
        ----------
        * `t1` :  
            time events in the the first correlation channel  
        * `n_t1` :  
            The number of time events in the first channel  
        * `t1` :  
            time events in the the second correlation channel  
        * `n_t2` :  
            The number of time events in the second channel  

        """
        return _tttrlib.Correlator_set_macrotimes(self, t1, t2)

    def get_macrotimes(self):
        r"""
        get_macrotimes(self) -> PairVectorInt64

        Correlator::get_macrotimes
        get event times of first and second correlation channel  

        Returns
        -------
        event times of first and second correlation channel  

        """
        return _tttrlib.Correlator_get_macrotimes(self)

    def set_events(self, t1, weight_ch1, t2, weight_ch2):
        r"""
        set_events(self, t1, weight_ch1, t2, weight_ch2)

        Parameters
        ----------
        t1: unsigned long long *
        weight_ch1: double *
        t2: unsigned long long *
        weight_ch2: double *


        Correlator::set_events
        Parameters
        ----------
        * `time` :  
            events of the first correlation channel  
        * `n_t1` :  
            The number of time events in the first channel  
        * `w1` :  
            A vector of weights for the time events of the first channel  
        * `n_weights_ch1` :  
            The number of weights of the first channel  
        * `t2` :  
            A vector of the time events of the second channel  
        * `n_t2` :  
            The number of time events in the second channel  
        * `w2` :  
            A vector of weights for the time events of the second channel  
        * `n_weights_ch2` :  
            The number of weights of the second channel  

        """
        return _tttrlib.Correlator_set_events(self, t1, weight_ch1, t2, weight_ch2)

    def set_weights(self, weight_ch1, weight_ch2):
        r"""
        set_weights(self, weight_ch1, weight_ch2)

        Parameters
        ----------
        weight_ch1: double *
        weight_ch2: double *


        Correlator::set_weights
        Set weights used for correlation.  

        Set and update weights of the events in first and second correlation channel  

        Parameters
        ----------
        * `w1` :  
            A vector of weights for the time events of the first channel  
        * `n_weights_ch1` :  
            The number of weights of the first channel  
        * `w2` :  
            A vector of weights for the time events of the second channel  
        * `n_weights_ch2` :  
            The number of weights of the second channel  

        """
        return _tttrlib.Correlator_set_weights(self, weight_ch1, weight_ch2)

    def get_weights(self):
        r"""
        get_weights(self) -> PairVectorDouble

        Correlator::get_weights
        Returns
        -------
        weights in first and second correlation channel  

        """
        return _tttrlib.Correlator_get_weights(self)

    def get_x_axis(self):
        r"""
        get_x_axis(self)

        Correlator::get_x_axis
        Get correlation bins (axis)  

        Parameters
        ----------
        * `output` :  
            x_axis / time axis of the correlation  
        * `n_out` :  
            number of elements in the axis of the x-axis  

        """
        return _tttrlib.Correlator_get_x_axis(self)

    def get_corr_normalized(self):
        r"""
        get_corr_normalized(self)

        Correlator::get_corr_normalized
        Get the normalized correlation.  

        Parameters
        ----------
        * `output` :  
            an array that containing normalized correlation  
        * `n_output` :  
            the number of elements of output  

        """
        return _tttrlib.Correlator_get_corr_normalized(self)

    def get_corr(self):
        r"""
        get_corr(self)

        Correlator::get_corr
        Get the (unnormalized) correlation.  

        Parameters
        ----------
        * `output` :  
            a pointer to an array that will contain the correlation  
        * `n_output` :  
            a pointer to the an integer that will contain the number of elements of the
            x-axis  

        """
        return _tttrlib.Correlator_get_corr(self)

    def run(self):
        r"""
        run(self)

        Correlator::run
        compute the correlation  

        Compute the correlation function. Usually calling this method is not necessary
        the the validity of the correlation function is tracked by the attribute
        is_valid.  

        """
        return _tttrlib.Correlator_run(self)

    def set_tttr(self, tttr_1, tttr_2=0, make_fine=False):
        r"""
        set_tttr(self, tttr_1, tttr_2=0, make_fine=False)

        Parameters
        ----------
        tttr_1: std::shared_ptr< TTTR >
        tttr_2: std::shared_ptr< TTTR >
        make_fine: bool


        Correlator::set_tttr
        Sets the time and the weights using TTTR objects.  

        Set the event times (and weights) using TTTR objects. By default the weights are
        all set to one.  

        The header of the first TTTR object is used for calibration. Both TTTR objects
        should have the same calibration (this is not checked).  

        Parameters
        ----------
        * `tttr_1` :  
        * `tttr_2` :  
        * `make_fine` :  
            if true a full correlation is computed that uses the micro time in the TTTR
            objects (default is false).  

        """
        return _tttrlib.Correlator_set_tttr(self, tttr_1, tttr_2, make_fine)

    def get_tttr(self):
        r"""
        get_tttr(self) -> TTTRPair

        Correlator::get_tttr
        """
        return _tttrlib.Correlator_get_tttr(self)

    def set_filter(self, filter, micro_times_1, routing_channels_1, micro_times_2, routing_channels_2):
        r"""
        set_filter(self, filter, micro_times_1, routing_channels_1, micro_times_2, routing_channels_2)

        Parameters
        ----------
        filter: std::map< short,std::vector< double,std::allocator< double > >,std::less< short >,std::allocator< std::pair< short const,std::vector< double,std::allocator< double > > > > > const &
        micro_times_1: std::vector< unsigned int,std::allocator< unsigned int > > const &
        routing_channels_1: std::vector< signed char,std::allocator< signed char > > const &
        micro_times_2: std::vector< unsigned int,std::allocator< unsigned int > > const &
        routing_channels_2: std::vector< signed char,std::allocator< signed char > > const &


        Correlator::set_filter
        Updates the weights. Non-zero weights are assigned a filter value that is
        defined by a filter map and the micro time of the event.  

        Parameters
        ----------
        * `micro_times[in]` :  
        * `routing_channels[in]` :  
        * `filter[in]` :  
            map of filters the first element in the map is the routing channel number,
            the second element of the map is a vector that maps a micro time to a filter
            value.  

        """
        return _tttrlib.Correlator_set_filter(self, filter, micro_times_1, routing_channels_1, micro_times_2, routing_channels_2)
    n_bins = property(_tttrlib.Correlator_n_bins_get, _tttrlib.Correlator_n_bins_set, doc=r"""n_bins""")
    n_casc = property(_tttrlib.Correlator_n_casc_get, _tttrlib.Correlator_n_casc_set, doc=r"""n_casc""")
    method = property(_tttrlib.Correlator_method_get, _tttrlib.Correlator_method_set, doc=r"""method""")
    def __getattr__(self, item):
        """
        If an attribute `attribute` is accesses that does not exist
        the corresponding getter by calling 'get_attribute' is called

        :param self:
        :param item:
        :return:
        """
        item = "get_" + str(item)
        if hasattr(self.__class__, item):
            call = getattr(self, item)
            return call()
        else:
            raise AttributeError

    @property
    def correlation(self):
        return self.get_corr_normalized()

    @property
    def y(self):
        return self.correlation

    @property
    def x_axis(self):
        return self.get_x_axis()

    @property
    def x(self):
        return self.x_axis

    @property
    def tttr(self):
        return self.get_tttr()

    @tttr.setter
    def tttr(self, v):
        if isinstance(v, TTTR):
            self.set_tttr(v, v)
        else:
            self.set_tttr(*v)

    @property
    def times(self):
        return self.get_macrotimes()

    @times.setter
    def times(self, v):
        return self.set_macrotimes(*v)

    @property
    def weights(self):
        return self.get_weights()

    @weights.setter
    def weights(self, v):
        return self.set_weights(*v)

    def __repr__(self):
        return 'Correlator()'

    def __str__(self):
        s = "Number of evenly spaced correlation channels: %d \n" % self.get_n_bins()
        s += "Number of correlation blocks: %d \n" % self.get_n_casc()
        return s

    def __init__(
            self,
            tttr=None,
            macro_times=None,
            weights=None,
            channels=None,
            **kwargs
    ):
    # prepare kwargs
        make_fine = kwargs.get('make_fine', False)
        if isinstance(tttr, TTTR):
            kwargs['tttr'] = tttr
        this = _tttrlib.new_Correlator(**kwargs)
        try:
            self.this.append(this)
        except:
            self.this = this
        if weights:
            w1, w2 = weights
            self.set_weights(w1, w2)
        if macro_times:
            t1, t2 = macro_times
            self.set_macrotimes(t1, t2)
        if isinstance(tttr, tuple):
            t1, t2 = tttr
            self.set_tttr(t1, t2, make_fine)
    # The channels argument can contain the channel numbers in
    # the TTTR object that should be correlated.
        if isinstance(channels, tuple):
            ch1, ch2 = channels
    # use the indices to create new TTTR objects these
            self.set_tttr(
                TTTR(tttr, tttr.get_selection_by_channel(ch1)),
                TTTR(tttr, tttr.get_selection_by_channel(ch2)),
                make_fine
            )


# Register Correlator in _tttrlib:
_tttrlib.Correlator_swigregister(Correlator)
class vector_CLSMFrame(object):
    r"""Proxy of C++ std::vector< CLSMFrame * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.vector_CLSMFrame_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.vector_CLSMFrame___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.vector_CLSMFrame___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< CLSMFrame * >::size_type"""
        return _tttrlib.vector_CLSMFrame___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> vector_CLSMFrame

        Parameters
        ----------
        i: std::vector< CLSMFrame * >::difference_type
        j: std::vector< CLSMFrame * >::difference_type

        """
        return _tttrlib.vector_CLSMFrame___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< CLSMFrame * >::difference_type
        j: std::vector< CLSMFrame * >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< CLSMFrame * >::difference_type
        j: std::vector< CLSMFrame * >::difference_type
        v: std::vector< CLSMFrame *,std::allocator< CLSMFrame * > > const &

        """
        return _tttrlib.vector_CLSMFrame___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< CLSMFrame * >::difference_type
        j: std::vector< CLSMFrame * >::difference_type

        """
        return _tttrlib.vector_CLSMFrame___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< CLSMFrame * >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _tttrlib.vector_CLSMFrame___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> vector_CLSMFrame

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(self, i) -> CLSMFrame

        Parameters
        ----------
        i: std::vector< CLSMFrame * >::difference_type

        """
        return _tttrlib.vector_CLSMFrame___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< CLSMFrame *,std::allocator< CLSMFrame * > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< CLSMFrame * >::difference_type
        x: std::vector< CLSMFrame * >::value_type

        """
        return _tttrlib.vector_CLSMFrame___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> CLSMFrame"""
        return _tttrlib.vector_CLSMFrame_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< CLSMFrame * >::value_type

        """
        return _tttrlib.vector_CLSMFrame_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.vector_CLSMFrame_empty(self)

    def size(self):
        r"""size(self) -> std::vector< CLSMFrame * >::size_type"""
        return _tttrlib.vector_CLSMFrame_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< CLSMFrame * > &

        """
        return _tttrlib.vector_CLSMFrame_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< CLSMFrame * >::iterator"""
        return _tttrlib.vector_CLSMFrame_begin(self)

    def end(self):
        r"""end(self) -> std::vector< CLSMFrame * >::iterator"""
        return _tttrlib.vector_CLSMFrame_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< CLSMFrame * >::reverse_iterator"""
        return _tttrlib.vector_CLSMFrame_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< CLSMFrame * >::reverse_iterator"""
        return _tttrlib.vector_CLSMFrame_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.vector_CLSMFrame_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< CLSMFrame * >::allocator_type"""
        return _tttrlib.vector_CLSMFrame_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _tttrlib.vector_CLSMFrame_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< CLSMFrame * >::iterator

        Parameters
        ----------
        pos: std::vector< CLSMFrame * >::iterator

        erase(self, first, last) -> std::vector< CLSMFrame * >::iterator

        Parameters
        ----------
        first: std::vector< CLSMFrame * >::iterator
        last: std::vector< CLSMFrame * >::iterator

        """
        return _tttrlib.vector_CLSMFrame_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> vector_CLSMFrame
        __init__(self, other) -> vector_CLSMFrame

        Parameters
        ----------
        other: std::vector< CLSMFrame * > const &

        __init__(self, size) -> vector_CLSMFrame

        Parameters
        ----------
        size: std::vector< CLSMFrame * >::size_type

        __init__(self, size, value) -> vector_CLSMFrame

        Parameters
        ----------
        size: std::vector< CLSMFrame * >::size_type
        value: std::vector< CLSMFrame * >::value_type

        """
        _tttrlib.vector_CLSMFrame_swiginit(self, _tttrlib.new_vector_CLSMFrame(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< CLSMFrame * >::value_type

        """
        return _tttrlib.vector_CLSMFrame_push_back(self, x)

    def front(self):
        r"""front(self) -> CLSMFrame"""
        return _tttrlib.vector_CLSMFrame_front(self)

    def back(self):
        r"""back(self) -> CLSMFrame"""
        return _tttrlib.vector_CLSMFrame_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< CLSMFrame * >::size_type
        x: std::vector< CLSMFrame * >::value_type

        """
        return _tttrlib.vector_CLSMFrame_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< CLSMFrame * >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< CLSMFrame * >::size_type
        x: std::vector< CLSMFrame * >::value_type

        """
        return _tttrlib.vector_CLSMFrame_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< CLSMFrame * >::iterator

        Parameters
        ----------
        pos: std::vector< CLSMFrame * >::iterator
        x: std::vector< CLSMFrame * >::value_type

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< CLSMFrame * >::iterator
        n: std::vector< CLSMFrame * >::size_type
        x: std::vector< CLSMFrame * >::value_type

        """
        return _tttrlib.vector_CLSMFrame_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< CLSMFrame * >::size_type

        """
        return _tttrlib.vector_CLSMFrame_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< CLSMFrame * >::size_type"""
        return _tttrlib.vector_CLSMFrame_capacity(self)
    __swig_destroy__ = _tttrlib.delete_vector_CLSMFrame

# Register vector_CLSMFrame in _tttrlib:
_tttrlib.vector_CLSMFrame_swigregister(vector_CLSMFrame)
class vector_CLSMLine(object):
    r"""Proxy of C++ std::vector< CLSMLine * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.vector_CLSMLine_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.vector_CLSMLine___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.vector_CLSMLine___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< CLSMLine * >::size_type"""
        return _tttrlib.vector_CLSMLine___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> vector_CLSMLine

        Parameters
        ----------
        i: std::vector< CLSMLine * >::difference_type
        j: std::vector< CLSMLine * >::difference_type

        """
        return _tttrlib.vector_CLSMLine___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< CLSMLine * >::difference_type
        j: std::vector< CLSMLine * >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< CLSMLine * >::difference_type
        j: std::vector< CLSMLine * >::difference_type
        v: std::vector< CLSMLine *,std::allocator< CLSMLine * > > const &

        """
        return _tttrlib.vector_CLSMLine___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< CLSMLine * >::difference_type
        j: std::vector< CLSMLine * >::difference_type

        """
        return _tttrlib.vector_CLSMLine___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< CLSMLine * >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _tttrlib.vector_CLSMLine___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> vector_CLSMLine

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(self, i) -> CLSMLine

        Parameters
        ----------
        i: std::vector< CLSMLine * >::difference_type

        """
        return _tttrlib.vector_CLSMLine___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< CLSMLine *,std::allocator< CLSMLine * > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< CLSMLine * >::difference_type
        x: std::vector< CLSMLine * >::value_type

        """
        return _tttrlib.vector_CLSMLine___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> CLSMLine"""
        return _tttrlib.vector_CLSMLine_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< CLSMLine * >::value_type

        """
        return _tttrlib.vector_CLSMLine_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.vector_CLSMLine_empty(self)

    def size(self):
        r"""size(self) -> std::vector< CLSMLine * >::size_type"""
        return _tttrlib.vector_CLSMLine_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< CLSMLine * > &

        """
        return _tttrlib.vector_CLSMLine_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< CLSMLine * >::iterator"""
        return _tttrlib.vector_CLSMLine_begin(self)

    def end(self):
        r"""end(self) -> std::vector< CLSMLine * >::iterator"""
        return _tttrlib.vector_CLSMLine_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< CLSMLine * >::reverse_iterator"""
        return _tttrlib.vector_CLSMLine_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< CLSMLine * >::reverse_iterator"""
        return _tttrlib.vector_CLSMLine_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.vector_CLSMLine_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< CLSMLine * >::allocator_type"""
        return _tttrlib.vector_CLSMLine_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _tttrlib.vector_CLSMLine_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< CLSMLine * >::iterator

        Parameters
        ----------
        pos: std::vector< CLSMLine * >::iterator

        erase(self, first, last) -> std::vector< CLSMLine * >::iterator

        Parameters
        ----------
        first: std::vector< CLSMLine * >::iterator
        last: std::vector< CLSMLine * >::iterator

        """
        return _tttrlib.vector_CLSMLine_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> vector_CLSMLine
        __init__(self, other) -> vector_CLSMLine

        Parameters
        ----------
        other: std::vector< CLSMLine * > const &

        __init__(self, size) -> vector_CLSMLine

        Parameters
        ----------
        size: std::vector< CLSMLine * >::size_type

        __init__(self, size, value) -> vector_CLSMLine

        Parameters
        ----------
        size: std::vector< CLSMLine * >::size_type
        value: std::vector< CLSMLine * >::value_type

        """
        _tttrlib.vector_CLSMLine_swiginit(self, _tttrlib.new_vector_CLSMLine(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< CLSMLine * >::value_type

        """
        return _tttrlib.vector_CLSMLine_push_back(self, x)

    def front(self):
        r"""front(self) -> CLSMLine"""
        return _tttrlib.vector_CLSMLine_front(self)

    def back(self):
        r"""back(self) -> CLSMLine"""
        return _tttrlib.vector_CLSMLine_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< CLSMLine * >::size_type
        x: std::vector< CLSMLine * >::value_type

        """
        return _tttrlib.vector_CLSMLine_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< CLSMLine * >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< CLSMLine * >::size_type
        x: std::vector< CLSMLine * >::value_type

        """
        return _tttrlib.vector_CLSMLine_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< CLSMLine * >::iterator

        Parameters
        ----------
        pos: std::vector< CLSMLine * >::iterator
        x: std::vector< CLSMLine * >::value_type

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< CLSMLine * >::iterator
        n: std::vector< CLSMLine * >::size_type
        x: std::vector< CLSMLine * >::value_type

        """
        return _tttrlib.vector_CLSMLine_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< CLSMLine * >::size_type

        """
        return _tttrlib.vector_CLSMLine_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< CLSMLine * >::size_type"""
        return _tttrlib.vector_CLSMLine_capacity(self)
    __swig_destroy__ = _tttrlib.delete_vector_CLSMLine

# Register vector_CLSMLine in _tttrlib:
_tttrlib.vector_CLSMLine_swigregister(vector_CLSMLine)
class vector_CLSMPixel(object):
    r"""Proxy of C++ std::vector< CLSMPixel * > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        r"""iterator(self) -> SwigPyIterator"""
        return _tttrlib.vector_CLSMPixel_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        r"""__nonzero__(self) -> bool"""
        return _tttrlib.vector_CLSMPixel___nonzero__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _tttrlib.vector_CLSMPixel___bool__(self)

    def __len__(self):
        r"""__len__(self) -> std::vector< CLSMPixel * >::size_type"""
        return _tttrlib.vector_CLSMPixel___len__(self)

    def __getslice__(self, i, j):
        r"""
        __getslice__(self, i, j) -> vector_CLSMPixel

        Parameters
        ----------
        i: std::vector< CLSMPixel * >::difference_type
        j: std::vector< CLSMPixel * >::difference_type

        """
        return _tttrlib.vector_CLSMPixel___getslice__(self, i, j)

    def __setslice__(self, *args):
        r"""
        __setslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< CLSMPixel * >::difference_type
        j: std::vector< CLSMPixel * >::difference_type

        __setslice__(self, i, j, v)

        Parameters
        ----------
        i: std::vector< CLSMPixel * >::difference_type
        j: std::vector< CLSMPixel * >::difference_type
        v: std::vector< CLSMPixel *,std::allocator< CLSMPixel * > > const &

        """
        return _tttrlib.vector_CLSMPixel___setslice__(self, *args)

    def __delslice__(self, i, j):
        r"""
        __delslice__(self, i, j)

        Parameters
        ----------
        i: std::vector< CLSMPixel * >::difference_type
        j: std::vector< CLSMPixel * >::difference_type

        """
        return _tttrlib.vector_CLSMPixel___delslice__(self, i, j)

    def __delitem__(self, *args):
        r"""
        __delitem__(self, i)

        Parameters
        ----------
        i: std::vector< CLSMPixel * >::difference_type

        __delitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        """
        return _tttrlib.vector_CLSMPixel___delitem__(self, *args)

    def __getitem__(self, *args):
        r"""
        __getitem__(self, slice) -> vector_CLSMPixel

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __getitem__(self, i) -> CLSMPixel

        Parameters
        ----------
        i: std::vector< CLSMPixel * >::difference_type

        """
        return _tttrlib.vector_CLSMPixel___getitem__(self, *args)

    def __setitem__(self, *args):
        r"""
        __setitem__(self, slice, v)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *
        v: std::vector< CLSMPixel *,std::allocator< CLSMPixel * > > const &

        __setitem__(self, slice)

        Parameters
        ----------
        slice: SWIGPY_SLICEOBJECT *

        __setitem__(self, i, x)

        Parameters
        ----------
        i: std::vector< CLSMPixel * >::difference_type
        x: std::vector< CLSMPixel * >::value_type

        """
        return _tttrlib.vector_CLSMPixel___setitem__(self, *args)

    def pop(self):
        r"""pop(self) -> CLSMPixel"""
        return _tttrlib.vector_CLSMPixel_pop(self)

    def append(self, x):
        r"""
        append(self, x)

        Parameters
        ----------
        x: std::vector< CLSMPixel * >::value_type

        """
        return _tttrlib.vector_CLSMPixel_append(self, x)

    def empty(self):
        r"""empty(self) -> bool"""
        return _tttrlib.vector_CLSMPixel_empty(self)

    def size(self):
        r"""size(self) -> std::vector< CLSMPixel * >::size_type"""
        return _tttrlib.vector_CLSMPixel_size(self)

    def swap(self, v):
        r"""
        swap(self, v)

        Parameters
        ----------
        v: std::vector< CLSMPixel * > &

        """
        return _tttrlib.vector_CLSMPixel_swap(self, v)

    def begin(self):
        r"""begin(self) -> std::vector< CLSMPixel * >::iterator"""
        return _tttrlib.vector_CLSMPixel_begin(self)

    def end(self):
        r"""end(self) -> std::vector< CLSMPixel * >::iterator"""
        return _tttrlib.vector_CLSMPixel_end(self)

    def rbegin(self):
        r"""rbegin(self) -> std::vector< CLSMPixel * >::reverse_iterator"""
        return _tttrlib.vector_CLSMPixel_rbegin(self)

    def rend(self):
        r"""rend(self) -> std::vector< CLSMPixel * >::reverse_iterator"""
        return _tttrlib.vector_CLSMPixel_rend(self)

    def clear(self):
        r"""clear(self)"""
        return _tttrlib.vector_CLSMPixel_clear(self)

    def get_allocator(self):
        r"""get_allocator(self) -> std::vector< CLSMPixel * >::allocator_type"""
        return _tttrlib.vector_CLSMPixel_get_allocator(self)

    def pop_back(self):
        r"""pop_back(self)"""
        return _tttrlib.vector_CLSMPixel_pop_back(self)

    def erase(self, *args):
        r"""
        erase(self, pos) -> std::vector< CLSMPixel * >::iterator

        Parameters
        ----------
        pos: std::vector< CLSMPixel * >::iterator

        erase(self, first, last) -> std::vector< CLSMPixel * >::iterator

        Parameters
        ----------
        first: std::vector< CLSMPixel * >::iterator
        last: std::vector< CLSMPixel * >::iterator

        """
        return _tttrlib.vector_CLSMPixel_erase(self, *args)

    def __init__(self, *args):
        r"""
        __init__(self) -> vector_CLSMPixel
        __init__(self, other) -> vector_CLSMPixel

        Parameters
        ----------
        other: std::vector< CLSMPixel * > const &

        __init__(self, size) -> vector_CLSMPixel

        Parameters
        ----------
        size: std::vector< CLSMPixel * >::size_type

        __init__(self, size, value) -> vector_CLSMPixel

        Parameters
        ----------
        size: std::vector< CLSMPixel * >::size_type
        value: std::vector< CLSMPixel * >::value_type

        """
        _tttrlib.vector_CLSMPixel_swiginit(self, _tttrlib.new_vector_CLSMPixel(*args))

    def push_back(self, x):
        r"""
        push_back(self, x)

        Parameters
        ----------
        x: std::vector< CLSMPixel * >::value_type

        """
        return _tttrlib.vector_CLSMPixel_push_back(self, x)

    def front(self):
        r"""front(self) -> CLSMPixel"""
        return _tttrlib.vector_CLSMPixel_front(self)

    def back(self):
        r"""back(self) -> CLSMPixel"""
        return _tttrlib.vector_CLSMPixel_back(self)

    def assign(self, n, x):
        r"""
        assign(self, n, x)

        Parameters
        ----------
        n: std::vector< CLSMPixel * >::size_type
        x: std::vector< CLSMPixel * >::value_type

        """
        return _tttrlib.vector_CLSMPixel_assign(self, n, x)

    def resize(self, *args):
        r"""
        resize(self, new_size)

        Parameters
        ----------
        new_size: std::vector< CLSMPixel * >::size_type

        resize(self, new_size, x)

        Parameters
        ----------
        new_size: std::vector< CLSMPixel * >::size_type
        x: std::vector< CLSMPixel * >::value_type

        """
        return _tttrlib.vector_CLSMPixel_resize(self, *args)

    def insert(self, *args):
        r"""
        insert(self, pos, x) -> std::vector< CLSMPixel * >::iterator

        Parameters
        ----------
        pos: std::vector< CLSMPixel * >::iterator
        x: std::vector< CLSMPixel * >::value_type

        insert(self, pos, n, x)

        Parameters
        ----------
        pos: std::vector< CLSMPixel * >::iterator
        n: std::vector< CLSMPixel * >::size_type
        x: std::vector< CLSMPixel * >::value_type

        """
        return _tttrlib.vector_CLSMPixel_insert(self, *args)

    def reserve(self, n):
        r"""
        reserve(self, n)

        Parameters
        ----------
        n: std::vector< CLSMPixel * >::size_type

        """
        return _tttrlib.vector_CLSMPixel_reserve(self, n)

    def capacity(self):
        r"""capacity(self) -> std::vector< CLSMPixel * >::size_type"""
        return _tttrlib.vector_CLSMPixel_capacity(self)
    __swig_destroy__ = _tttrlib.delete_vector_CLSMPixel

# Register vector_CLSMPixel in _tttrlib:
_tttrlib.vector_CLSMPixel_swigregister(vector_CLSMPixel)
class CLSMPixel(TTTRRange):
    r"""


    C++ includes: CLSMPixel.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __swig_destroy__ = _tttrlib.delete_CLSMPixel

    def __init__(self, *args):
        r"""
        __init__(self, p2) -> CLSMPixel

        Parameters
        ----------
        p2: CLSMPixel const &

        __init__(self, p2=None) -> CLSMPixel

        Parameters
        ----------
        p2: CLSMPixel *


        CLSMPixel::CLSMPixel
        """
        _tttrlib.CLSMPixel_swiginit(self, _tttrlib.new_CLSMPixel(*args))

# Register CLSMPixel in _tttrlib:
_tttrlib.CLSMPixel_swigregister(CLSMPixel)
class CLSMLine(TTTRSelection):
    r"""


    C++ includes: CLSMLine.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def get_pixels(self):
        r"""
        get_pixels(self) -> std::vector< CLSMPixel,std::allocator< CLSMPixel > > &

        CLSMLine::get_pixels
        """
        return _tttrlib.CLSMLine_get_pixels(self)

    def set_pixel_duration(self, v):
        r"""
        set_pixel_duration(self, v)

        Parameters
        ----------
        v: int


        CLSMLine::set_pixel_duration
        """
        return _tttrlib.CLSMLine_set_pixel_duration(self, v)

    def __init__(self, *args):
        r"""
        __init__(self) -> CLSMLine
        __init__(self, old_line, fill=True) -> CLSMLine

        Parameters
        ----------
        old_line: CLSMLine const &
        fill: bool

        __init__(self, line_start) -> CLSMLine

        Parameters
        ----------
        line_start: unsigned int

        __init__(self, line_start, n_pixel) -> CLSMLine

        Parameters
        ----------
        line_start: int
        n_pixel: unsigned int


        CLSMLine::CLSMLine
        """
        _tttrlib.CLSMLine_swiginit(self, _tttrlib.new_CLSMLine(*args))
    __swig_destroy__ = _tttrlib.delete_CLSMLine

    def append(self, pixel):
        r"""
        append(self, pixel)

        Parameters
        ----------
        pixel: CLSMPixel &


        CLSMLine::append
        """
        return _tttrlib.CLSMLine_append(self, pixel)

    def crop(self, pixel_start, pixel_stop):
        r"""
        crop(self, pixel_start, pixel_stop)

        Parameters
        ----------
        pixel_start: int
        pixel_stop: int


        CLSMLine::crop
        """
        return _tttrlib.CLSMLine_crop(self, pixel_start, pixel_stop)

    def __iadd__(self, rhs):
        r"""
        __iadd__(self, rhs) -> CLSMLine

        Parameters
        ----------
        rhs: CLSMLine const &

        """
        return _tttrlib.CLSMLine___iadd__(self, rhs)
    n_pixel = property(_tttrlib.CLSMLine_n_pixel_get, doc=r"""n_pixel""")
    pixel_duration = property(_tttrlib.CLSMLine_pixel_duration_get, doc=r"""pixel_duration""")

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> CLSMPixel

        Parameters
        ----------
        i: int

        """
        return _tttrlib.CLSMLine___getitem__(self, i)

    def __len__(self):
        r"""__len__(self) -> size_t"""
        return _tttrlib.CLSMLine___len__(self)

# Register CLSMLine in _tttrlib:
_tttrlib.CLSMLine_swigregister(CLSMLine)
class CLSMFrame(TTTRSelection):
    r"""


    C++ includes: CLSMFrame.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def get_lines(self):
        r"""
        get_lines(self) -> vector_CLSMLine

        CLSMFrame::get_lines
        """
        return _tttrlib.CLSMFrame_get_lines(self)
    __swig_destroy__ = _tttrlib.delete_CLSMFrame

    def __init__(self, *args):
        r"""
        __init__(self) -> CLSMFrame
        __init__(self, old_frame, fill=True) -> CLSMFrame

        Parameters
        ----------
        old_frame: CLSMFrame const &
        fill: bool

        __init__(self, frame_start, frame_stop, tttr) -> CLSMFrame

        Parameters
        ----------
        frame_start: size_t
        frame_stop: size_t
        tttr: TTTR *


        CLSMFrame::CLSMFrame
        """
        _tttrlib.CLSMFrame_swiginit(self, _tttrlib.new_CLSMFrame(*args))

    def append(self, line):
        r"""
        append(self, line)

        Parameters
        ----------
        line: CLSMLine *


        CLSMFrame::append
        Append a line to the current frame  

        Parameters
        ----------
        * `line` :  

        """
        return _tttrlib.CLSMFrame_append(self, line)

    def __iadd__(self, rhs):
        r"""
        __iadd__(self, rhs) -> CLSMFrame

        Parameters
        ----------
        rhs: CLSMFrame const &

        """
        return _tttrlib.CLSMFrame___iadd__(self, rhs)

    def crop(self, line_start, line_stop, pixel_start, pixel_stop):
        r"""
        crop(self, line_start, line_stop, pixel_start, pixel_stop)

        Parameters
        ----------
        line_start: int
        line_stop: int
        pixel_start: int
        pixel_stop: int


        CLSMFrame::crop
        Crops a frame  

        """
        return _tttrlib.CLSMFrame_crop(self, line_start, line_stop, pixel_start, pixel_stop)
    n_lines = property(_tttrlib.CLSMFrame_n_lines_get, doc=r"""n_lines""")

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> CLSMLine

        Parameters
        ----------
        i: int

        """
        return _tttrlib.CLSMFrame___getitem__(self, i)

    def __len__(self):
        r"""__len__(self) -> size_t"""
        return _tttrlib.CLSMFrame___len__(self)

# Register CLSMFrame in _tttrlib:
_tttrlib.CLSMFrame_swigregister(CLSMFrame)
CLSM_DEFAULT = _tttrlib.CLSM_DEFAULT

CLSM_SP5 = _tttrlib.CLSM_SP5

CLSM_SP8 = _tttrlib.CLSM_SP8

class CLSMSettings(object):
    r"""


    C++ includes: CLSMImage.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        r"""
        __init__(self, skip_before_first_frame_marker=False, skip_after_last_frame_marker=False, reading_routine=CLSM_DEFAULT, marker_line_start=3, marker_line_stop=2, marker_frame_start=std::vector< int >({1}), marker_event_type=1, n_pixel_per_line=1, n_lines=-1) -> CLSMSettings

        Parameters
        ----------
        skip_before_first_frame_marker: bool
        skip_after_last_frame_marker: bool
        reading_routine: int
        marker_line_start: int
        marker_line_stop: int
        marker_frame_start: std::vector< int,std::allocator< int > >
        marker_event_type: int
        n_pixel_per_line: int
        n_lines: int


        CLSMSettings::CLSMSettings
        Parameters
        ----------
        * `marker_frame_start` :  
            routing channel numbers (default reading routine) or micro time channel
            number (SP8 reading routine) that serves as a marker informing on a new
            frame in the TTTR data stream.  
        * `marker_line_start` :  
            routing channel number (default reading routine) or micro time channel
            number (SP8 reading routine) that serves as a marker informing on the start
            of a new line in a frame within the TTTR data stream  
        * `marker_line_stop` :  
            routing channel number (default reading routine) or micro time channel
            number (SP8 reading routine) that serves as a marker informing on the stop
            of a new line in a frame within the TTTR data stream  
        * `marker_event` :  
            event types that are interpreted as markers for frames and lines.  
        * `n_pixel_per_line` :  
            number of pixels into which each line is separated. If the number of pixels
            per line is set to zero. The number of pixels per line will correspond to
            the number of lines in the first frame.  
        * `macro_time_shift` :  
            Number of macro time counts a line start is shifted relative to the line
            start marker in the TTTR object (default 0)  
        * `reading_routine` :  
            an integer that specifies the reading routine used to read a CLSM image out
            of a TTTR data stream. A CLSM image can be encoded by several ways in a TTTR
            stream. Leica encodes frame and line markers in micro time channel numbers.
            PicoQuant and others use a more 'traditional' encoding for frame and line
            markers marking TTTR events as marker events and using the channel number to
            differentiate the different marker types.  

        """
        _tttrlib.CLSMSettings_swiginit(self, _tttrlib.new_CLSMSettings(*args, **kwargs))
    __swig_destroy__ = _tttrlib.delete_CLSMSettings

# Register CLSMSettings in _tttrlib:
_tttrlib.CLSMSettings_swigregister(CLSMSettings)
class CLSMImage(object):
    r"""


    C++ includes: CLSMImage.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def get_tttr(self):
        r"""
        get_tttr(self) -> std::shared_ptr< TTTR >

        CLSMImage::get_tttr
        """
        return _tttrlib.CLSMImage_get_tttr(self)

    def set_tttr(self, v):
        r"""
        set_tttr(self, v)

        Parameters
        ----------
        v: std::shared_ptr< TTTR >


        CLSMImage::set_tttr
        """
        return _tttrlib.CLSMImage_set_tttr(self, v)

    def get_settings(self):
        r"""
        get_settings(self) -> CLSMSettings

        CLSMImage::get_settings
        """
        return _tttrlib.CLSMImage_get_settings(self)

    def size(self):
        r"""
        size(self) -> size_t

        CLSMImage::size
        Get the number of frames in the CLSMImage.  

        """
        return _tttrlib.CLSMImage_size(self)
    marker_frame = property(_tttrlib.CLSMImage_marker_frame_get, _tttrlib.CLSMImage_marker_frame_set, doc=r"""marker_frame""")
    marker_line_start = property(_tttrlib.CLSMImage_marker_line_start_get, _tttrlib.CLSMImage_marker_line_start_set, doc=r"""marker_line_start""")
    marker_line_stop = property(_tttrlib.CLSMImage_marker_line_stop_get, _tttrlib.CLSMImage_marker_line_stop_set, doc=r"""marker_line_stop""")
    marker_event = property(_tttrlib.CLSMImage_marker_event_get, _tttrlib.CLSMImage_marker_event_set, doc=r"""marker_event""")
    reading_routine = property(_tttrlib.CLSMImage_reading_routine_get, _tttrlib.CLSMImage_reading_routine_set, doc=r"""reading_routine""")
    skip_before_first_frame_marker = property(_tttrlib.CLSMImage_skip_before_first_frame_marker_get, _tttrlib.CLSMImage_skip_before_first_frame_marker_set, doc=r"""skip_before_first_frame_marker""")
    skip_after_last_frame_marker = property(_tttrlib.CLSMImage_skip_after_last_frame_marker_get, _tttrlib.CLSMImage_skip_after_last_frame_marker_set, doc=r"""skip_after_last_frame_marker""")

    def fill(self, *args, **kwargs):
        r"""
        fill(self, tttr_data=None, channels=std::vector< int >(), clear=True, micro_time_ranges=std::vector< std::pair< int,int > >())

        Parameters
        ----------
        tttr_data: TTTR *
        channels: std::vector< int,std::allocator< int > >
        clear: bool
        micro_time_ranges: std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > > const &


        CLSMImage::fill
        Fill the tttr_indices of the pixels with the indices of the channels that are
        within a pixel  

        Parameters
        ----------
        * `channels[in]` :  
            list of routing channels. Events that have routing channels in this vector
            are added to pixels of corresponding time.  
        * `clear_pixel[in]` :  
            if set to true (default) the pixels are cleared before they are filled. If
            set to false new tttr indices are added to the pixels  

        """
        return _tttrlib.CLSMImage_fill(self, *args, **kwargs)

    def fill_pixels(self, *args, **kwargs):
        r"""
        fill_pixels(self, tttr_data, channels, clear_pixel=True, micro_time_ranges=std::vector< std::pair< int,int > >())

        Parameters
        ----------
        tttr_data: TTTR *
        channels: std::vector< int,std::allocator< int > >
        clear_pixel: bool
        micro_time_ranges: std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > >


        CLSMImage::fill_pixels
        """
        return _tttrlib.CLSMImage_fill_pixels(self, *args, **kwargs)

    def clear(self):
        r"""
        clear(self)

        CLSMImage::clear
        Clear tttr_indices stored in the pixels  

        """
        return _tttrlib.CLSMImage_clear(self)

    def clear_pixels(self):
        r"""
        clear_pixels(self)

        CLSMImage::clear_pixels
        """
        return _tttrlib.CLSMImage_clear_pixels(self)

    def strip(self, tttr_indices, offset=0):
        r"""
        strip(self, tttr_indices, offset=0)

        Parameters
        ----------
        tttr_indices: std::vector< int,std::allocator< int > > const &
        offset: int


        CLSMImage::strip
        Strips tttr_indices from all pixels in Image assumes that each tttr index is
        only once in an image  

        """
        return _tttrlib.CLSMImage_strip(self, tttr_indices, offset)

    def get_fcs_image(self, *args, **kwargs):
        r"""
        get_fcs_image(self, tttr, clsm_other=None, correlation_method="default", n_bins=50, n_casc=1, stack_frames=False, normalized_correlation=False, min_photons=2)

        Parameters
        ----------
        tttr: std::shared_ptr< TTTR >
        clsm_other: CLSMImage *
        correlation_method: std::string
        n_bins: int
        n_casc: int
        stack_frames: bool
        normalized_correlation: bool
        min_photons: int


        CLSMImage::get_fcs_image
        Computes the an image where pixels are correlation curves  

        Parameters
        ----------
        * `output[out]` :  
        * `dim1[out]` :  
        * `dim2[out]` :  
        * `dim3[out]` :  
        * `dim4[out]` :  
        * `tttr_self` :  
        * `tac_coarsening` :  
        * `stack_frames` :  

        """
        return _tttrlib.CLSMImage_get_fcs_image(self, *args, **kwargs)

    def get_frames(self):
        r"""
        get_frames(self) -> vector_CLSMFrame

        CLSMImage::get_frames
        Get the frames in the CLSMImage.  

        """
        return _tttrlib.CLSMImage_get_frames(self)

    def get_intensity(self):
        r"""
        get_intensity(self)

        CLSMImage::get_intensity
        Intensity image.  

        """
        return _tttrlib.CLSMImage_get_intensity(self)

    def get_fluorescence_decay(self, tttr_data, micro_time_coarsening=1, stack_frames=False):
        r"""
        get_fluorescence_decay(self, tttr_data, micro_time_coarsening=1, stack_frames=False)

        Parameters
        ----------
        tttr_data: TTTR *
        micro_time_coarsening: int
        stack_frames: bool


        CLSMImage::get_fluorescence_decay
        Computes an image stack where the value of each pixel corresponds to a histogram
        of micro times in each pixel. The micro times can be coarsened by integer
        numbers.  

        Parameters
        ----------
        * `tttr_data` :  
            pointer to a TTTR object  
        * `out` :  
            pointer to output array of unsigned chars that will contain the image stack  
        * `dim1` :  
            number of frames  
        * `dim2` :  
            number of lines  
        * `dim3` :  
            number of pixels  
        * `dim4` :  
            number of micro time channels in the histogram  
        * `micro_time_coarsening` :  
            constant used to coarsen the micro times. The default value is 1 and the
            micro times are binned without coarsening.  
        * `stack_frames` :  
            if True the frames are stacked.  

        """
        return _tttrlib.CLSMImage_get_fluorescence_decay(self, tttr_data, micro_time_coarsening, stack_frames)

    def get_decay_of_pixels(self, tttr_data, mask, tac_coarsening, stack_frames):
        r"""
        get_decay_of_pixels(self, tttr_data, mask, tac_coarsening, stack_frames)

        Parameters
        ----------
        tttr_data: TTTR *
        mask: uint8_t *
        tac_coarsening: int
        stack_frames: bool


        CLSMImage::get_decay_of_pixels
        Computes micro time histograms for the stacks of images and a selection of
        pixels. Photons in pixels that are selected by the selection array contribute to
        the returned array of micro time histograms.  

        Parameters
        ----------
        * `tttr_data` :  
            pointer to a TTTR object  
        * `mask` :  
            a stack of images used as a mask to select pixels  
        * `dmask1` :  
            number of frames  
        * `dmask2` :  
            number of lines  
        * `dmask3` :  
            number of pixels per line  
        * `out` :  
            pointer to output array of unsigned int contains the micro time histograms  
        * `dim1` :  
            dimension of the output array, i.e., the number of stacks  
        * `dim1` :  
            dimension the number of micro time channels  
        * `tac_coarsening` :  
            constant used to coarsen the micro times  
        * `stack_frames` :  
            if True the frames are stacked.  

        """
        return _tttrlib.CLSMImage_get_decay_of_pixels(self, tttr_data, mask, tac_coarsening, stack_frames)

    def get_mean_micro_time(self, tttr_data, microtime_resolution=-1.0, minimum_number_of_photons=2, stack_frames=False):
        r"""
        get_mean_micro_time(self, tttr_data, microtime_resolution=-1.0, minimum_number_of_photons=2, stack_frames=False)

        Parameters
        ----------
        tttr_data: TTTR *
        microtime_resolution: double
        minimum_number_of_photons: int
        stack_frames: bool


        CLSMImage::get_mean_micro_time
        Calculates an image stack where the value of each pixel corresponds to the mean
        micro time (in units of the micro channel resolution).  

        Pixels with few photons can be discriminated. Discriminated pixels will be
        filled with zeros.  

        Parameters
        ----------
        * `tttr_data[in]` :  
            pointer to a TTTR object  
        * `out[out]` :  
            pointer to output array that will contain the image stack  
        * `dim1[out]` :  
            returns the number of frames  
        * `dim2[out]` :  
            returns the number of lines  
        * `dim3[out]` :  
            returns the number of pixels per line  
        * `minimum_number_of_photons[in]` :  
            the minimum number of photons in a micro time  
        * `stack_frames[in]` :  
            if true the frames are stacked (default value is false). If stack frames is
            set to true the mean arrival time is computed using the tttr indices of all
            pixels (this corresponds to the photon weighted mean arrival time).  

        """
        return _tttrlib.CLSMImage_get_mean_micro_time(self, tttr_data, microtime_resolution, minimum_number_of_photons, stack_frames)

    def get_phasor(self, tttr_data, tttr_irf=None, frequency=-1, minimum_number_of_photons=2, stack_frames=False):
        r"""
        get_phasor(self, tttr_data, tttr_irf=None, frequency=-1, minimum_number_of_photons=2, stack_frames=False)

        Parameters
        ----------
        tttr_data: TTTR *
        tttr_irf: TTTR *
        frequency: double
        minimum_number_of_photons: int
        stack_frames: bool


        CLSMImage::get_phasor
        Computes the phasor values for every pixel  

        Pixels with few photons can be discriminated. Discriminated pixels will be
        filled with zeros.  

        Parameters
        ----------
        * `tttr_data[in]` :  
            pointer to a TTTR object  
        * `out[out]` :  
            pointer to output array that will contain the image stack  
        * `dim1[out]` :  
            returns the number of frames  
        * `dim2[out]` :  
            returns the number of lines  
        * `dim3[out]` :  
            returns the number of pixels per line  
        * `dim4[out]` :  
            returns 2 (first is the g phasor value (cos), second the s phasor (sin)  
        * `minimum_number_of_photons[in]` :  
            the minimum number of photons in a micro time (only used if frames are not
            stacked)  
        * `stack_frames[in]` :  
            if true the frames are stacked (default value is false). If stack frames is
            set to true the mean arrival time is computed using the tttr indices of all
            pixels (this corresponds to the photon weighted mean arrival time).  

        """
        return _tttrlib.CLSMImage_get_phasor(self, tttr_data, tttr_irf, frequency, minimum_number_of_photons, stack_frames)

    def get_mean_lifetime(self, *args, **kwargs):
        r"""
        get_mean_lifetime(self, tttr_data, minimum_number_of_photons=3, tttr_irf=None, m0_irf=1.0, m1_irf=1.0, stack_frames=False, background=std::vector< double >(), m0_bg=0.0, m1_bg=0.0, background_fraction=-1.0)

        Parameters
        ----------
        tttr_data: TTTR *
        minimum_number_of_photons: int
        tttr_irf: TTTR *
        m0_irf: double
        m1_irf: double
        stack_frames: bool
        background: std::vector< double,std::allocator< double > >
        m0_bg: double
        m1_bg: double
        background_fraction: double


        CLSMImage::get_mean_lifetime
        Computes an image of average lifetimes  

        The average lifetimes are computed (not fitted) by the methods of moments (Irvin
        Isenberg, 1973, Biophysical journal). This approach does not consider scattered
        light.  

        Pixels with few photons can be discriminated. Discriminated pixels are filled
        with zeros.  

        By default the fluorescence lifetimes of the pixels are computed in units of
        nanoseconds.  

        Parameters
        ----------
        * `tttr_data[in]` :  
            pointer to a TTTR object  
        * `tttr_irf[in]` :  
            pointer to a TTTR object of the IRF  
        * `out[out]` :  
            pointer to output array that will contain the image stack  
        * `dim1[out]` :  
            returns the number of frames  
        * `dim2[out]` :  
            returns the number of lines  
        * `dim3[out]` :  
            returns the number of pixels per line  
        * `minimum_number_of_photons[in]` :  
            the minimum number of photons in a micro time  
        * `m0_irf` :  
            is the zero moment of the IRF (optional, default=1)  
        * `m1_irf` :  
            is the first moment of the IRF (optional, default=1)  

        """
        return _tttrlib.CLSMImage_get_mean_lifetime(self, *args, **kwargs)

    def to1D(self, frame, line, pixel):
        r"""
        to1D(self, frame, line, pixel) -> int

        Parameters
        ----------
        frame: int
        line: int
        pixel: int


        CLSMImage::to1D
        Convert frame, line, and pixel to 1D index.  

        """
        return _tttrlib.CLSMImage_to1D(self, frame, line, pixel)

    def to3D(self, idx):
        r"""
        to3D(self, idx) -> VectorInt32

        Parameters
        ----------
        idx: int


        CLSMImage::to3D
        Convert 1D index to frame, line, and pixel.  

        """
        return _tttrlib.CLSMImage_to3D(self, idx)

    def getPixel(self, idx):
        r"""
        getPixel(self, idx) -> CLSMPixel

        Parameters
        ----------
        idx: unsigned int


        CLSMImage::getPixel
        """
        return _tttrlib.CLSMImage_getPixel(self, idx)

    def copy(self, p2, fill=False):
        r"""
        copy(self, p2, fill=False)

        Parameters
        ----------
        p2: CLSMImage const &
        fill: bool


        CLSMImage::copy
        Copy the information from another CLSMImage object  

        Parameters
        ----------
        * `p2` :  
            The information from this object is copied.  
        * `fill` :  
            If this is set to true (default is false) the tttr indices of the pixels are
            copied.  

        Returns
        -------  

        """
        return _tttrlib.CLSMImage_copy(self, p2, fill)

    def append(self, frame):
        r"""
        append(self, frame)

        Parameters
        ----------
        frame: CLSMFrame *


        CLSMImage::append
        Append a frame to the CLSM image.  

        Parameters
        ----------
        * `frame` :  

        """
        return _tttrlib.CLSMImage_append(self, frame)

    def transform(self, input):
        r"""
        transform(self, input)

        Parameters
        ----------
        input: unsigned int *


        CLSMImage::transform
        Moves the content of the Pixels  

        The input is an interleaved array or source and target pixel indices. A pixel
        index is a mapping from a frames, lines, and pixel combination to an index.  

        Parameters
        ----------
        * `index` :  
        * `n_index` :  

        """
        return _tttrlib.CLSMImage_transform(self, input)

    def rebin(self, bin_line, bin_pixel):
        r"""
        rebin(self, bin_line, bin_pixel)

        Parameters
        ----------
        bin_line: int
        bin_pixel: int


        CLSMImage::rebin
        Rebin a CLSMImage  

        Note, rebinning redistributes photons and thus the macro times in pixels.  

        Parameters
        ----------
        * `bin_line` :  
            binning factor for lines  
        * `bin_pixel` :  
            binning factor for pixel in lines  

        """
        return _tttrlib.CLSMImage_rebin(self, bin_line, bin_pixel)

    def distribute(self, pixel_id, target, target_pixel_ids, target_probabilities):
        r"""
        distribute(self, pixel_id, target, target_pixel_ids, target_probabilities)

        Parameters
        ----------
        pixel_id: unsigned int
        target: CLSMImage *
        target_pixel_ids: std::vector< int,std::allocator< int > > &
        target_probabilities: std::vector< int,std::allocator< int > > &


        CLSMImage::distribute
        Distribute the photons of a pixel_id to a set of pixel ids in a target image
        according to provided probabilities  

        """
        return _tttrlib.CLSMImage_distribute(self, pixel_id, target, target_pixel_ids, target_probabilities)

    def crop(self, frame_start, frame_stop, line_start, line_stop, pixel_start, pixel_stop):
        r"""
        crop(self, frame_start, frame_stop, line_start, line_stop, pixel_start, pixel_stop)

        Parameters
        ----------
        frame_start: int
        frame_stop: int
        line_start: int
        line_stop: int
        pixel_start: int
        pixel_stop: int


        CLSMImage::crop
        Crop the image  

        Parameters
        ----------
        * `frame_start` :  
        * `frame_stop` :  
        * `line_start` :  
        * `line_stop` :  
        * `pixel_start` :  
        * `pixel_stop` :  

        """
        return _tttrlib.CLSMImage_crop(self, frame_start, frame_stop, line_start, line_stop, pixel_start, pixel_stop)

    def stack_frames(self):
        r"""
        stack_frames(self)

        CLSMImage::stack_frames
        """
        return _tttrlib.CLSMImage_stack_frames(self)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(self, tttr_data=0, settings=CLSMSettings(), source=None, fill=True, channels=std::vector< int >(), micro_time_ranges=std::vector< std::pair< int,int > >()) -> CLSMImage

        Parameters
        ----------
        tttr_data: std::shared_ptr< TTTR >
        settings: CLSMSettings
        source: CLSMImage *
        fill: bool
        channels: std::vector< int,std::allocator< int > >
        micro_time_ranges: std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > >


        CLSMImage::CLSMImage
        Parameters
        ----------
        * `tttr_data` :  
            pointer to TTTR object  
        * `marker_frame_start` :  
            routing channel numbers (default reading routine) or micro time channel
            number (SP8 reading routine) that serves as a marker informing on a new
            frame in the TTTR data stream.  
        * `marker_line_start` :  
            routing channel number (default reading routine) or micro time channel
            number (SP8 reading routine) that serves as a marker informing on the start
            of a new line in a frame within the TTTR data stream  
        * `marker_line_stop` :  
            routing channel number (default reading routine) or micro time channel
            number (SP8 reading routine) that serves as a marker informing on the stop
            of a new line in a frame within the TTTR data stream  
        * `marker_event_type` :  
            event types that are interpreted as markers for frames and lines.  
        * `n_pixel_per_line` :  
            number of pixels into which each line is separated. If the number of pixels
            per line is set to zero. The number of pixels per line will correspond to
            the number of lines in the first frame.  
        * `reading_routine` :  
            an integer that specifies the reading routine used to read a CLSM image out
            of a TTTR data stream. A CLSM image can be encoded by several ways in a TTTR
            stream. Leica encodes frame and line markers in micro time channel numbers.
            PicoQuant and others use a more 'traditional' encoding for frame and line
            markers marking TTTR events as marker events and using the channel number to
            differentiate the different marker types.  
        * `source` :  
            A CLSMImage object that is used as a template for the created object. All
            frames and lines are copied and empty pixels are created. If the parameter
            fill is set to true moreover the content of the pixels is copied.  
        * `fill` :  
            if set to true (default) is false the lines are filled with pixels that will
            contain either the photons of the specified channels or the photons from the
            source CLSMImage instance.  
        * `channels` :  
            The channel number of the events that will be used to fill the pixels.  
        * `stack_frames` :  
            If set to true (default is false) the frames in the CLSM image are stacked
            and the resulting CLSMImage will hava a single frame.  

        """
        _tttrlib.CLSMImage_swiginit(self, _tttrlib.new_CLSMImage(*args, **kwargs))
    __swig_destroy__ = _tttrlib.delete_CLSMImage

    @staticmethod
    def compute_ics(*args, **kwargs):
        r"""
        compute_ics(tttr_data=0, clsm=None, images=None, x_range=std::vector< int >({0, -1}), y_range=std::vector< int >({0, -1}), frames_index_pairs=std::vector< std::pair< int,int > >(), subtract_average="", mask=None)

        Parameters
        ----------
        tttr_data: std::shared_ptr< TTTR >
        clsm: CLSMImage *
        images: double *
        x_range: std::vector< int,std::allocator< int > >
        y_range: std::vector< int,std::allocator< int > >
        frames_index_pairs: std::vector< std::pair< int,int >,std::allocator< std::pair< int,int > > >
        subtract_average: std::string
        mask: uint8_t *


        CLSMImage::compute_ics
        Computes an image correlation via FFTs for a set of frames  

        This function computes the image correlation for a set of frames. The frames can
        be either specified by an array or by a CLSMImage object. This function can
        compute image cross-correlation and image auto-correlations. The type of the
        correlation is specified by a set of pairs that are cross- correlated.  

        Parameters
        ----------
        * `output` :  
            the array that will contain the ICS  
        * `dim1` :  
            number of frames in the ICS  
        * `dim2` :  
            number of lines (line shifts) in the ICS  
        * `dim3` :  
            number of pixel (pixel shifts) in the ICS  
        * `tttr_data` :  
        * `clsm` :  
            an optional pointer to a CLSMImage object  
        * `images` :  
            an optional pointer to an image array  
        * `input_frames` :  
            number of frames in the image array  
        * `input_lines` :  
            number of lines in the image array  
        * `input_pixel` :  
            number of pixel in the image array  
        * `x_range` :  
            defines the region of interest (ROI) in the image (pixel). This parameter is
            optional. The default value is [0,-1]. This means that the entire input
            pixel range is used  
        * `y_range` :  
            region defines the ROI in y-direction (lines). The default value is [0,-1].
            By default all lines in the image are used.  
        * `frames_index_pairs` :  
            A vector of integer pairs. The pairs correspond to the frame numbers in the
            input that will be cross-correlated. If no vector of frame pairs is
            specified the image auto-correlation will be computed  
        * `subtract_average` :  
            the input image can be corrected for the background, i.e., a constant
            background can be subtracted from the frames. If this parameter is set to
            "stack" the average over all frames is computed and subtracted pixel-wise
            from each frame. If this parameter is set to "frame" the average of each
            frame is computed and subtracted from the each frame. By default no
            correction is applied.  
        * `mask` :  
            a stack of images used as a to select pixels  
        * `dmask1` :  
            number of frames  
        * `dmask2` :  
            number of lines  
        * `dmask3` :  
            number of pixels per line  

        """
        return _tttrlib.CLSMImage_compute_ics(*args, **kwargs)

    @staticmethod
    def get_roi(*args, **kwargs):
        r"""
        get_roi(clsm=None, x_range=std::vector< int >({0,-1}), y_range=std::vector< int >({0,-1}), subtract_average="", background=0.0, clip=False, clip_max=1e6, clip_min=-1e6, images=None, n_frames=-1, n_lines=-1, n_pixels=1, mask=None, selected_frames=std::vector< int >())

        Parameters
        ----------
        clsm: CLSMImage *
        x_range: std::vector< int,std::allocator< int > >
        y_range: std::vector< int,std::allocator< int > >
        subtract_average: std::string
        background: double
        clip: bool
        clip_max: double
        clip_min: double
        images: double *
        n_frames: int
        n_lines: int
        n_pixels: int
        mask: uint8_t *
        selected_frames: std::vector< int,std::allocator< int > >


        CLSMImage::get_roi
        Copies a region of interest (ROI) into a new image and does some background
        correction.  

        The ROI is defined by defining a range for the pixels and lines. The ROI can be
        corrected by a constant background value, clipped to limit the range of the
        output values, and corrected by the mean intensity of the frames.  

        Parameters
        ----------
        * `output` :  
            the array that will contain the ROI. The array is allocated by the function  
        * `dim1` :  
            the number of frames in the output ROI  
        * `dim2` :  
            the number of lines per frame in the output  
        * `dim3` :  
            the number of pixels per line in the output ROI  
        * `clsm` :  
            a pointer to a CLSMImage object  
        * `x_range` :  
            the range (selection) of the pixels  
        * `y_range` :  
            the range (selection) of the lines  
        * `subtract_average` :  
            If this parameter is set to "stack" the mean image of the ROIs that is
            computed by the average over all frames is subtracted from each frame and
            the mean intensity of all frames and pixels is added to the pixels. If this
            parameter is set to "frame" the average of each frame is subtracted from
            each frame. The default behaviour is to do nothing.  
        * `background` :  
            A constant number that is subtracted from each pixel.  
        * `clip` :  
            If set to true (the default value is false) the values in the ROI are
            clipped to the range [clip_min, clip_max]  
        * `clip_max` :  
            the maximum value when output ROIs are clipped  
        * `clip_min` :  
            the minimum value when output ROIs are clipped  
        * `images` :  
            Input array of images that are used to defined ROIs. If no CLSMImage object
            is specified. This array is used as an input.  
        * `n_frames` :  
            The number of frames in the input array images  
        * `n_lines` :  
            The number of lines in the input array images  
        * `n_pixel` :  
            The number of pixel in the input array images  
        * `selected_frames` :  
            A list of frames that is used to define the ROIs. If no frames are defined
            by this list, all frames in the input are used.  
        * `mask` :  
            a stack of images used as a to select pixels  
        * `dmask1` :  
            number of frames if the number of frames in the mask is smaller then the ROI
            the first mask frame will be applied to all ROI frames that are greater than
            dmask1  
        * `dmask2` :  
            number of lines if smaller then ROI the outside region will be selected and
            the mask will be applied to all lines smaller than dmask2  
        * `dmask3` :  
            number of pixels per line in the mask.  

        """
        return _tttrlib.CLSMImage_get_roi(*args, **kwargs)

    @staticmethod
    def get_frame_edges(*args, **kwargs):
        r"""
        get_frame_edges(tttr=None, start_event=0, stop_event=-1, marker_frame_start=std::vector< int >({4, 6}), marker_event_type=15, reading_routine=CLSM_SP8, skip_before_first_frame_marker=False, skip_after_last_frame_marker=False) -> VectorInt32

        Parameters
        ----------
        tttr: TTTR *
        start_event: int
        stop_event: int
        marker_frame_start: std::vector< int,std::allocator< int > >
        marker_event_type: int
        reading_routine: int
        skip_before_first_frame_marker: bool
        skip_after_last_frame_marker: bool


        CLSMImage::get_frame_edges
        Get the tttr indices of frame markers for a SP8  

        Parameters
        ----------
        * `tttr` :  
            pointer to the TTTR object that is inspected  
        * `marker_frame` :  
            vector of  
        * `marker_event` :  
        * `start_event` :  
        * `stop_event` :  

        Returns
        -------  

        """
        return _tttrlib.CLSMImage_get_frame_edges(*args, **kwargs)

    @staticmethod
    def get_line_edges(tttr, start_event, stop_event, marker_line_start=1, marker_line_stop=2, marker_event_type=15, reading_routine=CLSM_SP8):
        r"""
        get_line_edges(tttr, start_event, stop_event, marker_line_start=1, marker_line_stop=2, marker_event_type=15, reading_routine=CLSM_SP8) -> VectorInt32

        Parameters
        ----------
        tttr: TTTR *
        start_event: int
        stop_event: int
        marker_line_start: int
        marker_line_stop: int
        marker_event_type: int
        reading_routine: int


        CLSMImage::get_line_edges
        Read start stop marker to identify line edges.  

        """
        return _tttrlib.CLSMImage_get_line_edges(tttr, start_event, stop_event, marker_line_start, marker_line_stop, marker_event_type, reading_routine)

    @staticmethod
    def get_line_edges_by_duration(tttr, start_event, stop_event, marker_line_start=1, line_duration=2, marker_event_type=15, reading_routine=CLSM_SP8):
        r"""
        get_line_edges_by_duration(tttr, start_event, stop_event, marker_line_start=1, line_duration=2, marker_event_type=15, reading_routine=CLSM_SP8) -> VectorInt32

        Parameters
        ----------
        tttr: TTTR *
        start_event: int
        stop_event: int
        marker_line_start: int
        line_duration: int
        marker_event_type: int
        reading_routine: int


        CLSMImage::get_line_edges_by_duration
        Read start marker and use line duration as stop.  

        """
        return _tttrlib.CLSMImage_get_line_edges_by_duration(tttr, start_event, stop_event, marker_line_start, line_duration, marker_event_type, reading_routine)

    def get_line_duration(self, frame=0, line=0):
        r"""
        get_line_duration(self, frame=0, line=0) -> double

        Parameters
        ----------
        frame: int
        line: int


        CLSMImage::get_line_duration
        Obtain line duration (in milliseconds)  

        Parameters
        ----------
        * `frame` :  
            number of frame in image  
        * `line` :  
            number of line in image  

        Returns
        -------
        duration of line in selected frame  

        """
        return _tttrlib.CLSMImage_get_line_duration(self, frame, line)

    def get_pixel_duration(self, frame=0, line=0):
        r"""
        get_pixel_duration(self, frame=0, line=0) -> double

        Parameters
        ----------
        frame: int
        line: int


        CLSMImage::get_pixel_duration
        Obtain pixel duration in milliseconds.  

        Parameters
        ----------
        * `frame` :  
            Selected frame number  
        * `line` :  
            selected line number  

        Returns
        -------
        duration of pixel in selected frame  

        """
        return _tttrlib.CLSMImage_get_pixel_duration(self, frame, line)
    n_frames = property(_tttrlib.CLSMImage_n_frames_get, doc=r"""n_frames""")
    n_lines = property(_tttrlib.CLSMImage_n_lines_get, doc=r"""n_lines""")
    n_pixel = property(_tttrlib.CLSMImage_n_pixel_get, doc=r"""n_pixel""")

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> CLSMFrame

        Parameters
        ----------
        i: int

        """
        return _tttrlib.CLSMImage___getitem__(self, i)

    def __len__(self):
        r"""__len__(self) -> size_t"""
        return _tttrlib.CLSMImage___len__(self)
    @property
    def shape(self):
        return self.n_frames, self.n_lines, self.n_pixel

    def __repr__(self):
        return 'tttrlib.CLSMImage(%s, %s, %s)' % (
            self.n_frames,
            self.n_lines,
            self.n_pixel
        )

    def __getattr__(self, item):
        """
        If an attribute `attribute` is accesses that does not exist
        the corresponding getter by calling 'get_attribute' is called

        :param self:
        :param item:
        :return:
        """
        item = "get_" + str(item)
        if hasattr(self.__class__, item):
            call = getattr(self, item)
            return call()
        else:
            raise AttributeError
    @staticmethod
    def read_clsm_settings(tttr_data):
        settings = dict()
        if tttr_data is not None:
            header = tttr_data.header
            if tttr_data.get_tttr_container_type() == 'PTU':
                try:
                    settings["marker_frame_start"] = [2**(int(header.tag('ImgHdr_Frame')["value"])-1)]
                except:
                    settings["marker_frame_start"] = [8]
                settings.update(
                    {
                        "marker_line_start": 2**(int(header.tag('ImgHdr_LineStart')["value"])-1),
                        "marker_line_stop": 2**(int(header.tag('ImgHdr_LineStop')["value"])-1),
                        "n_pixel_per_line": int(header.tag('ImgHdr_PixX')["value"]),
                        "n_lines": int(header.tag('ImgHdr_PixY')["value"]),
                        "marker_event_type": 1
                    }
                )
            elif tttr_data.get_tttr_container_type() == 'HT3':
                settings.update(
                    {
                        "marker_line_start": int(header.tag('ImgHdr_LineStart')["value"]),
                        "marker_line_stop": int(header.tag('ImgHdr_LineStop')["value"]),
                        "n_pixel_per_line": int(header.tag('ImgHdr_PixX')["value"]),
                        "n_lines": int(header.tag('ImgHdr_PixY')["value"]),
                        "marker_frame_start": [int(header.tag('ImgHdr_Frame')["value"])],
                        "marker_event_type": 1
                    }
                )
        return settings

    def __init__(
            self,
            tttr_data=None,
            marker_frame_start=None,
            marker_line_start=None,
            marker_line_stop=None,
            marker_event_type=1,
            n_pixel_per_line=None,
            reading_routine='default',
            skip_before_first_frame_marker=False,
            skip_after_last_frame_marker=False,
            **kwargs
    ):
        source = kwargs.get('source', None)
        rt = {
            'SP8': CLSM_SP8,
            'SP5': CLSM_SP5,
            'default': CLSM_DEFAULT
        }

        settings_kwargs = {
            "skip_before_first_frame_marker": skip_before_first_frame_marker,
            "skip_after_last_frame_marker": skip_after_last_frame_marker,
            "reading_routine": rt[reading_routine],
            "marker_line_start": marker_line_start,
            "marker_line_stop": marker_line_stop,
            "marker_frame_start": marker_frame_start,
            "marker_event_type": marker_event_type,
            "n_pixel_per_line": n_pixel_per_line
        }

        if not isinstance(source, CLSMImage):
            settings_kwargs.update(
                {
                    "marker_frame_start": marker_frame_start,
                    "marker_line_start": marker_line_start,
                    "marker_line_stop": marker_line_stop,
                    "marker_event_type": marker_event_type,
                    "n_pixel_per_line": n_pixel_per_line,
                    "reading_routine": rt[reading_routine],
                    "skip_before_first_frame_marker": skip_before_first_frame_marker
                }
            )
            if tttr_data is not None:
                header = tttr_data.header
                self.header = header
                try:
                    settings_kwargs.update(self.read_clsm_settings(tttr_data))
                except:
                    print("Error reading TTTR CLSM header")
    # Overwrite if user defined inputs make sense
            if isinstance(marker_frame_start, int):
                settings_kwargs['marker_frame_start'] = [marker_frame_start]
            if isinstance(marker_frame_start, list):
                settings_kwargs['marker_frame_start'] = marker_frame_start
            if isinstance(marker_line_start, int):
                settings_kwargs['marker_line_start'] = marker_line_start
            if isinstance(marker_line_stop, int):
                settings_kwargs['marker_line_stop'] = marker_line_stop
            if isinstance(marker_event_type, int):
                settings_kwargs['marker_event_type'] = marker_event_type
            if isinstance(n_pixel_per_line, int):
                settings_kwargs['n_pixel_per_line'] = n_pixel_per_line
            kwargs['tttr_data'] = tttr_data

    # Defined setups overrule all setting
            if reading_routine == 'SP5':
                settings_kwargs["marker_event_type"] = 1
                settings_kwargs["marker_frame_start"] = [4, 6]
                settings_kwargs["marker_line_start"] = 1
                settings_kwargs["marker_line_stop"] = 2
            elif reading_routine == 'SP8':
                settings_kwargs["marker_event_type"] = 15
                settings_kwargs["marker_frame_start"] = [4, 6]
                settings_kwargs["marker_line_start"] = 1
                settings_kwargs["marker_line_stop"] = 2
                if tttr_data is not None:
                    header = tttr_data.header
                    settings_kwargs["marker_line_start"] = int(header.tag('ImgHdr_LineStart')["value"])
                    settings_kwargs["marker_line_stop"] = int(header.tag('ImgHdr_LineStop')["value"])
            clsm_settings = CLSMSettings(**settings_kwargs)
        else:
            clsm_settings = source.get_settings()
        kwargs['settings'] = clsm_settings
        this = _tttrlib.new_CLSMImage(**kwargs)
        try:
            self.this.append(this)
        except:
            self.this = this

    @staticmethod
    def compute_frc(image_1, image_2, bin_width = 2.0):
    # type: (np.ndarray, np.ndarray, int) -> (np.ndarray, np.ndarray)
        """ Computes the Fourier Ring/Shell Correlation of two 2-D images

        :param image_1:
        :param image_2:
        :param bin_width:
        :return:
        """
        image_1 = image_1 / np.sum(image_1)
        image_2 = image_2 / np.sum(image_2)
        f1, f2 = np.fft.fft2(image_1), np.fft.fft2(image_2)
        af1f2 = np.real(f1 * np.conj(f2))
        af1_2, af2_2 = np.abs(f1)**2, np.abs(f2)**2
        nx, ny = af1f2.shape
        x = np.arange(-np.floor(nx / 2.0), np.ceil(nx / 2.0))
        y = np.arange(-np.floor(ny / 2.0), np.ceil(ny / 2.0))
        distances = list()
        wf1f2 = list()
        wf1 = list()
        wf2 = list()
        for xi, yi in np.array(np.meshgrid(x,y)).T.reshape(-1, 2):
            distances.append(np.sqrt(xi**2 + xi**2))
            xi = int(xi)
            yi = int(yi)
            wf1f2.append(af1f2[xi, yi])
            wf1.append(af1_2[xi, yi])
            wf2.append(af2_2[xi, yi])

        bins = np.arange(0, np.sqrt((nx//2)**2 + (ny//2)**2), bin_width)
        f1f2_r, bin_edges = np.histogram(
            distances,
            bins=bins,
            weights=wf1f2
        )
        f12_r, bin_edges = np.histogram(
            distances,
            bins=bins,
            weights=wf1
        )
        f22_r, bin_edges = np.histogram(
            distances,
            bins=bins,
            weights=wf2
        )
        density = f1f2_r / np.sqrt(f12_r * f22_r)
        return density, bin_edges


    def get_frc(
            self,                 # type: tttrlib.CLSMImage,
            other = None,         # type: tttrlib.CLSMImage
            bin_width = 2.0,      # type: int
            attribute="intensity" # type: str
    ):
        img1 = getattr(self, attribute)
        if other is None:
            im1 = img1[::2].sum(axis=0)
            im2 = img1[1::2].sum(axis=0)
        else:
            img2 = getattr(other, attribute)
            im1 = img1.sum(axis=0)
            im2 = img2.sum(axis=0)
        return CLSMImage.compute_frc(im1, im2, bin_width)


# Register CLSMImage in _tttrlib:
_tttrlib.CLSMImage_swigregister(CLSMImage)
class DecayPhasor(object):
    r"""


    C++ includes: DecayPhasor.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def compute_phasor(microtimes, n_microtimes, frequency=1.0, minimum_number_of_photons=1, g_irf=1.0, s_irf=0.0, idxs=None):
        r"""
        compute_phasor(microtimes, n_microtimes, frequency=1.0, minimum_number_of_photons=1, g_irf=1.0, s_irf=0.0, idxs=None) -> VectorDouble

        Parameters
        ----------
        microtimes: unsigned short *
        n_microtimes: int
        frequency: double
        minimum_number_of_photons: int
        g_irf: double
        s_irf: double
        idxs: std::vector< int,std::allocator< int > > *


        DecayPhasor::compute_phasor
        Compute the phasor (g,s) for a selection of micro times  

        This function computes the phasor (g,s) for a set of micro times that are
        selected out of an vector. The microtimes are selected by a second vector. The
        second vector speciefies which indices of the microtime vector are used to
        compute the phasor.  

        Parameters
        ----------
        * `micro_times` :  
            vector of micro times  
        * `idxs` :  
            vector of selected indices  
        * `minimum_number_of_photons` :  
        * `frequency` :  
            the frequency of the phasor  
        * `g_irf` :  
            g-value of instrument response phasor  
        * `s_irf` :  
            s-value of instrument response phasor  

        Returns
        -------
        vector of length 2: first element g-value, second element s-value  

        """
        return _tttrlib.DecayPhasor_compute_phasor(microtimes, n_microtimes, frequency, minimum_number_of_photons, g_irf, s_irf, idxs)

    @staticmethod
    def compute_phasor_bincounts(bincounts, frequency, minimum_number_of_photons, g_irf, s_irf):
        r"""
        compute_phasor_bincounts(bincounts, frequency, minimum_number_of_photons, g_irf, s_irf) -> VectorDouble

        Parameters
        ----------
        bincounts: std::vector< int,std::allocator< int > > &
        frequency: double
        minimum_number_of_photons: int
        g_irf: double
        s_irf: double


        DecayPhasor::compute_phasor_bincounts
        Compute the phasor (g,s) for a histogram / bincounts  

        This function computes the phasor (g,s) for bincounted micro times  

        Parameters
        ----------
        * `bincounts` :  
            vector bincounts  
        * `minimum_number_of_photons` :  
        * `frequency` :  
            the frequency of the phasor  
        * `g_irf` :  
            g-value of instrument response phasor  
        * `s_irf` :  
            s-value of instrument response phasor  

        Returns
        -------
        vector of length 2: first element g-value, second element s-value  

        """
        return _tttrlib.DecayPhasor_compute_phasor_bincounts(bincounts, frequency, minimum_number_of_photons, g_irf, s_irf)

    @staticmethod
    def g(g_irf, s_irf, g_exp, s_exp):
        r"""
        g(g_irf, s_irf, g_exp, s_exp) -> double

        Parameters
        ----------
        g_irf: double
        s_irf: double
        g_exp: double
        s_exp: double


        DecayPhasor::g
        https://journals.plos.org/plosone/article/file?type=supplementary&id=info:doi/10.1371/journal.pone.0194578.s001  

        Parameters
        ----------
        * `g_irf` :  
            g-value of instrument response phasor  
        * `s_irf` :  
            s-value of instrument response phasor  
        * `g_exp` :  
        * `s_exp` :  

        Returns
        -------  

        """
        return _tttrlib.DecayPhasor_g(g_irf, s_irf, g_exp, s_exp)

    @staticmethod
    def s(g_irf, s_irf, g_exp, s_exp):
        r"""
        s(g_irf, s_irf, g_exp, s_exp) -> double

        Parameters
        ----------
        g_irf: double
        s_irf: double
        g_exp: double
        s_exp: double


        DecayPhasor::s
        https://journals.plos.org/plosone/article/file?type=supplementary&id=info:doi/10.1371/journal.pone.0194578.s001  

        Parameters
        ----------
        * `g_irf` :  
        * `s_irf` :  
        * `g_exp` :  
        * `s_exp` :  

        Returns
        -------  

        """
        return _tttrlib.DecayPhasor_s(g_irf, s_irf, g_exp, s_exp)

    def __init__(self):
        r"""
        __init__(self) -> DecayPhasor


        C++ includes: DecayPhasor.h

        """
        _tttrlib.DecayPhasor_swiginit(self, _tttrlib.new_DecayPhasor())
    __swig_destroy__ = _tttrlib.delete_DecayPhasor

# Register DecayPhasor in _tttrlib:
_tttrlib.DecayPhasor_swigregister(DecayPhasor)
class Pda(object):
    r"""


    C++ includes: Pda.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def evaluate(self):
        r"""
        evaluate(self)

        Pda::evaluate
        Computes the S1S2 histogram.  

        """
        return _tttrlib.Pda_evaluate(self)

    def __init__(self, *args, **kwargs):
        r"""
        __init__(self, hist2d_nmax=300, hist2d_nmin=5, background_ch1=0.0, background_ch2=0.0, pF=std::vector< double >()) -> Pda

        Parameters
        ----------
        hist2d_nmax: int
        hist2d_nmin: int
        background_ch1: double
        background_ch2: double
        pF: std::vector< double,std::allocator< double > >


        Pda::Pda
        Constructor creating a new Pda object  

        A Pda object can be used to compute Photon Distribution Analysis histograms.  

        Parameters
        ----------
        * `hist2d_nmax` :  
            the maximum number of photons  
        * `hist2d_nmin` :  
            the minimum number of photons considered  

        """
        _tttrlib.Pda_swiginit(self, _tttrlib.new_Pda(*args, **kwargs))
    __swig_destroy__ = _tttrlib.delete_Pda

    def append(self, amplitude, probability_ch1):
        r"""
        append(self, amplitude, probability_ch1)

        Parameters
        ----------
        amplitude: double
        probability_ch1: double


        Pda::append
        Appends a species.  

        A species is defined by the probability of detecting a photon in the first
        detection channel.  

        Parameters
        ----------
        * `amplitude` :  
            the amplitude (fraction) of the species  
        * `probability_ch1` :  
            the probability of detecting the species in the first detection channel  

        """
        return _tttrlib.Pda_append(self, amplitude, probability_ch1)

    def clear_probability_ch1(self):
        r"""
        clear_probability_ch1(self)

        Pda::clear_probability_ch1
        Clears the model and removes all species.  

        """
        return _tttrlib.Pda_clear_probability_ch1(self)

    def get_amplitudes(self):
        r"""
        get_amplitudes(self)

        Pda::get_amplitudes
        Returns the amplitudes of the species  

        Parameters
        ----------
        * `output[out]` :  
            A C type array containing the amplitude of the species  
        * `n_output[out]` :  
            The number of species  

        """
        return _tttrlib.Pda_get_amplitudes(self)

    def set_amplitudes(self, input):
        r"""
        set_amplitudes(self, input)

        Parameters
        ----------
        input: double *


        Pda::set_amplitudes
        Sets the amplitudes of the species.  

        Parameters
        ----------
        * `input[in]` :  
            A C type array that contains the amplitude of the species  
        * `n_input[in]` :  
            The number of species  

        """
        return _tttrlib.Pda_set_amplitudes(self, input)

    def set_callback(self, cb):
        r"""
        set_callback(self, cb)

        Parameters
        ----------
        cb: PdaCallback *


        Pda::set_callback
        Set the callback (cb) for the computation of a 1D histogram.  

        The cb function recudes two dimensional values, i.e., the intensity in channel
        (ch1) and ch2 to a one dimensional number. The cb is used to compute either FRET
        efficiencies, etc.  

        Parameters
        ----------
        * `callback[in]` :  
            object that computes the value on a 1D histogram.  

        """
        return _tttrlib.Pda_set_callback(self, cb)

    def get_S1S2_matrix(self):
        r"""
        get_S1S2_matrix(self)

        Pda::get_S1S2_matrix
        Returns the S1S2 matrix that contains the photon counts in the two channels  

        Parameters
        ----------
        * `output[out]` :  
            the S1S2 matrix  
        * `n_output1[out]` :  
            dimension 1 of the matrix  
        * `n_output2[out]` :  
            dimension 2 of the matrix  

        """
        return _tttrlib.Pda_get_S1S2_matrix(self)

    def set_probability_spectrum_ch1(self, input):
        r"""
        set_probability_spectrum_ch1(self, input)

        Parameters
        ----------
        input: double *


        Pda::set_probability_spectrum_ch1
        Set the theoretical probability spectrum of detecting a photon in the first
        channel  

        The probability spectrum is an interleaved array of the amplitudes and the
        probabilities of detecting a photon in the first channel  

        Parameters
        ----------
        * `input[in]` :  
            a C type array containing the probability spectrum  
        * `n_input[in]` :  
            the number of array elements  

        """
        return _tttrlib.Pda_set_probability_spectrum_ch1(self, input)

    def get_probabilities_ch1(self):
        r"""
        get_probabilities_ch1(self)

        Pda::get_probabilities_ch1
        Returns the amplitudes of the species  

        Parameters
        ----------
        * `output[out]` :  
            A C type array containing the amplitude of the species  
        * `n_output[out]` :  
            The number of species  

        """
        return _tttrlib.Pda_get_probabilities_ch1(self)

    def set_probabilities_ch1(self, input):
        r"""
        set_probabilities_ch1(self, input)

        Parameters
        ----------
        input: double *


        Pda::set_probabilities_ch1
        Sets the theoretical probabilities for detecting a the species in the first
        channel.  

        Parameters
        ----------
        * `input[in]` :  
            A C type array that contains the probabilities of the species  
        * `n_input[in]` :  
            The number of species  

        """
        return _tttrlib.Pda_set_probabilities_ch1(self, input)

    def get_probability_spectrum_ch1(self):
        r"""
        get_probability_spectrum_ch1(self)

        Pda::get_probability_spectrum_ch1
        Get the theoretical probability spectrum of detecting a photon in the first
        channel  

        The probability spectrum is an interleaved array of the amplitudes and the
        probabilities of detecting a photon in the first channel  

        Parameters
        ----------
        * `output[out]` :  
            array containing the probability spectrum  
        * `n_output[out]` :  
            number of elements in the output array  

        """
        return _tttrlib.Pda_get_probability_spectrum_ch1(self)

    def setPF(self, input):
        r"""
        setPF(self, input)

        Parameters
        ----------
        input: double *


        Pda::setPF
        Set the probability P(F)  

        Parameters
        ----------
        * `input[in]` :  
        * `n_input[in]` :  

        """
        return _tttrlib.Pda_setPF(self, input)

    def getPF(self):
        r"""
        getPF(self)

        Pda::getPF
        Set the probability P(F)  

        """
        return _tttrlib.Pda_getPF(self)

    def get_1dhistogram(self, *args, **kwargs):
        r"""
        get_1dhistogram(self, x_max=1000.0, x_min=0.01, n_bins=81, log_x=True, s1s2=std::vector< double >(), n_min=-1, skip_zero_photon=True, amplitudes=std::vector< double >(), probabilities_ch1=std::vector< double >())

        Parameters
        ----------
        x_max: double
        x_min: double
        n_bins: int
        log_x: bool
        s1s2: std::vector< double,std::allocator< double > >
        n_min: int
        skip_zero_photon: bool
        amplitudes: std::vector< double,std::allocator< double > >
        probabilities_ch1: std::vector< double,std::allocator< double > >


        Pda::get_1dhistogram
        Returns a one dimensional histogram of the 2D counting array of the two
        channels.  

        Parameters
        ----------
        * `histogram_x[out]` :  
            histogram X axis  
        * `n_histogram_x[out]` :  
            dimension of the x-axis  
        * `histogram_y[out]` :  
            array containing the computed histogram  
        * `n_histogram_y[out]` :  
            dimension of the histogram  
        * `x_max[in]` :  
            maximum x value of the histogram  
        * `x_min[in]` :  
            minimum x value of the histogram  
        * `nbins[int]` :  
            number of histogram bins  
        * `log_x[in]` :  
            If set to true (default is true) the values on the x-axis are
            logarithmically spaced otherwise they have a linear spacing.  
        * `s1s2[in]` :  
            Optional input for the S1S2 matrix. If this is set to a nullptr (default)
            the S1S2 matrix of the Pda object is used to compute the 1D histogram. If
            this is not set to nullptr and both dimensions set by n_input1 and n_input2
            are larger than zero. The input is used as S1S2 matrix. The input matrix
            must be quadratic.  
        * `n_min[in]` :  
            Minimum number of photons in the histogram. If set to -1 the number set when
            the Pda object was instancitated is used.  
        * `skip_zero_photon[in]` :  
            When this option is set to true only elements of the s1s2 matrix i,j (i>0
            and j>0) are considered.  
        * `amplitudes[in]` :  
            The species amplitudes (optional). This updates the s1s2 matrix of the
            object.  
        * `probabilities_ch1[in]` :  
            The theoretical probabilities of detecting the species in channel
            1(optional)This updates the s1s2 matrix of the object.  

        """
        return _tttrlib.Pda_get_1dhistogram(self, *args, **kwargs)

    @staticmethod
    def compute_experimental_histograms(tttr_data, channels_1, channels_2, maximum_number_of_photons, minimum_number_of_photons, minimum_time_window_length):
        r"""
        compute_experimental_histograms(tttr_data, channels_1, channels_2, maximum_number_of_photons, minimum_number_of_photons, minimum_time_window_length)

        Parameters
        ----------
        tttr_data: TTTR *
        channels_1: std::vector< int,std::allocator< int > >
        channels_2: std::vector< int,std::allocator< int > >
        maximum_number_of_photons: int
        minimum_number_of_photons: int
        minimum_time_window_length: double


        Pda::compute_experimental_histograms
        Parameters
        ----------
        * `tttr_data[in]` :  
        * `s1s2[out]` :  
        * `dim1[out]` :  
        * `dim2[out]` :  
        * `ps[out]` :  
        * `dim_ps[out]` :  
        * `channels_1` :  
            routing channel numbers that are used for the first channel in the S1S2
            matrix. Photons with this channel number are counted and increment values in
            the S1S2 matrix.  
        * `channels_2` :  
            routing channel numbers that are used for the second channel in the S1S2
            matrix.Photons with this channel number are counted and increment values in
            the S1S2 matrix.  
        * `maximum_number_of_photons` :  
            The maximum number of photons in the computed S1S2 matrix  
        * `minimum_number_of_photons` :  
            The minimum number of photons in a time window and in the S1S2 matrix  
        * `minimum_time_window_length` :  
            The minimum length of a time windows in units of milli seconds.  

        """
        return _tttrlib.Pda_compute_experimental_histograms(tttr_data, channels_1, channels_2, maximum_number_of_photons, minimum_number_of_photons, minimum_time_window_length)

    @staticmethod
    def S1S2_pF(S1S2, pF, Nmax, background_ch1, background_ch2, p_ch1, amplitudes):
        r"""
        S1S2_pF(S1S2, pF, Nmax, background_ch1, background_ch2, p_ch1, amplitudes)

        Parameters
        ----------
        S1S2: std::vector< double,std::allocator< double > > &
        pF: std::vector< double,std::allocator< double > > &
        Nmax: unsigned int
        background_ch1: double
        background_ch2: double
        p_ch1: std::vector< double,std::allocator< double > > &
        amplitudes: std::vector< double,std::allocator< double > > &


        Pda::S1S2_pF
        calculating p(G,R), several ratios using the same same P(F)  

        Parameters
        ----------
        * `S1S2[]` :  
            see sgsr_pN  
        * `pF[in]` :  
            input: p(F)  
        * `Nmax[in]` :  
        * `background_ch1[in]` :  
        * `background_ch2[in]` :  
        * `p_ch1[in]` :  
        * `amplitudes[in]` :  
            corresponding amplitudes  

        """
        return _tttrlib.Pda_S1S2_pF(S1S2, pF, Nmax, background_ch1, background_ch2, p_ch1, amplitudes)

    @staticmethod
    def conv_pF(S1S2, F1F2, Nmax, background_ch1, background_ch2):
        r"""
        conv_pF(S1S2, F1F2, Nmax, background_ch1, background_ch2)

        Parameters
        ----------
        S1S2: std::vector< double,std::allocator< double > > &
        F1F2: std::vector< double,std::allocator< double > > const &
        Nmax: unsigned int
        background_ch1: double
        background_ch2: double


        Pda::conv_pF
        Convolves the Fluorescence matrix F1F2 with the background to yield the signal
        matrix S1S2  

        Parameters
        ----------
        * `S1S2[out]` :  
        * `F1F2[in]` :  
        * `Nmax` :  
        * `background_ch1` :  
        * `background_ch2` :  

        """
        return _tttrlib.Pda_conv_pF(S1S2, F1F2, Nmax, background_ch1, background_ch2)

    @staticmethod
    def poisson_0toN(return_p, start_idx, lam, return_dim):
        r"""
        poisson_0toN(return_p, start_idx, lam, return_dim)

        Parameters
        ----------
        return_p: std::vector< double,std::allocator< double > > &
        start_idx: int
        lam: double
        return_dim: int


        Pda::poisson_0toN
        Writes a Poisson distribution with an average lam, for 0..N into a vector
        starting at a specified index.  

        Parameters
        ----------
        * `return_p[in`, `out]` :  
        * `lam[in]` :  
        * `return_dim[in]` :  

        """
        return _tttrlib.Pda_poisson_0toN(return_p, start_idx, lam, return_dim)
    hist_sgsr_valid = property(_tttrlib.Pda_hist_sgsr_valid_get, _tttrlib.Pda_hist_sgsr_valid_set, doc=r"""hist_sgsr_valid""")
    background_ch2 = property(_tttrlib.Pda_background_ch2_get, _tttrlib.Pda_background_ch2_set, doc=r"""background_ch2""")
    background_ch1 = property(_tttrlib.Pda_background_ch1_get, _tttrlib.Pda_background_ch1_set, doc=r"""background_ch1""")
    hist2d_nmin = property(_tttrlib.Pda_hist2d_nmin_get, _tttrlib.Pda_hist2d_nmin_set, doc=r"""hist2d_nmin""")
    hist2d_nmax = property(_tttrlib.Pda_hist2d_nmax_get, _tttrlib.Pda_hist2d_nmax_set, doc=r"""hist2d_nmax""")
    hist2d_valid = property(_tttrlib.Pda_hist2d_valid_get, _tttrlib.Pda_hist2d_valid_set, doc=r"""hist2d_valid""")


    def histogram_function(self, cb):
    # type: (Callable) -> None
        """Set the callback function that is used to compute 1D histograms

        :param cb: the callback function
        :return: None
        """
        class PdaCallbackPython(PdaCallback):
            def __init__(
                    self,
                    cb_function,
                    *args, **kwargs
            ):
    # type: (typing.Callable) -> None
                super().__init__(*args, **kwargs)
                self._cb = cb_function

            def run(self, *args, **kwargs):
                return self._cb(*args, **kwargs)
        cb_instance = PdaCallbackPython(cb_function=cb)
        cb_instance.__disown__()
        self.set_callback(cb_instance)


    histogram_function = property(None, histogram_function)

    @property
    def pf(self):
        return self.getPF()

    @pf.setter
    def pf(self, v):
        self.setPF(v)

    @property
    def spectrum_ch1(self):
        return self.get_probability_spectrum_ch1()

    @spectrum_ch1.setter
    def spectrum_ch1(self, v):
        self.set_probability_spectrum_ch1(v)

    @property
    def species_amplitudes(self):
        return self.get_amplitudes()

    @species_amplitudes.setter
    def species_amplitudes(self, v):
        self.set_amplitudes(v)

    @property
    def probabilities_ch1(self):
        return self.get_probabilities_ch1()

    @probabilities_ch1.setter
    def probabilities_ch1(self, v):
        self.set_probabilities_ch1(v)

    @property
    def s1s2(self):
        return self.get_S1S2_matrix()

    def __repr__(self):
        return 'Pda("n_species: %s")' % (
            len(self.get_amplitudes())
        )

    def __str__(self):
        s = "Pda: \n"
        s += "Number of species: %d \n" % len(self.get_amplitudes())
        s += "Probability spectrum: %s \n" % self.spectrum_ch1()
        s += "Background Channel 1:" + self.background_ch1
        s += "Background Channel 2:" + self.background_ch2
        s += "Histogram 2D valid:" + self.hist2d_valid
        s += "Maximum number of photons:" + self.hist2d_nmax
        s += "Minimum number of photons:" + self.hist2d_nmin
        s += "P(F):" + self.pf
        return s



# Register Pda in _tttrlib:
_tttrlib.Pda_swigregister(Pda)
class PdaCallback(object):
    r"""


    C++ includes: PdaCallback.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def run(self, ch1, ch2):
        r"""
        run(self, ch1, ch2) -> double

        Parameters
        ----------
        ch1: double
        ch2: double


        PdaCallback::run
        """
        return _tttrlib.PdaCallback_run(self, ch1, ch2)

    def __init__(self):
        r"""
        __init__(self) -> PdaCallback

        Parameters
        ----------
        self: PyObject *


        PdaCallback::PdaCallback
        """
        if self.__class__ == PdaCallback:
            _self = None
        else:
            _self = self
        _tttrlib.PdaCallback_swiginit(self, _tttrlib.new_PdaCallback(_self, ))
    __swig_destroy__ = _tttrlib.delete_PdaCallback
    def __disown__(self):
        self.this.disown()
        _tttrlib.disown_PdaCallback(self)
        return weakref.proxy(self)

# Register PdaCallback in _tttrlib:
_tttrlib.PdaCallback_swigregister(PdaCallback)

def add_pile_up_to_model(*args, **kwargs):
    r"""
    add_pile_up_to_model(model, decay, repetition_rate, instrument_dead_time, measurement_time, pile_up_model="coates", start=0, stop=-1)

    Parameters
    ----------
    model: double *
    decay: double *
    repetition_rate: double
    instrument_dead_time: double
    measurement_time: double
    pile_up_model: std::string
    start: int
    stop: int



    Add a pile-up distortion to the model function.  

    This function adds a pile up distortion to a model fluorescence decay. The model
    used to compute the pile-up distortion follows the description of Coates (1968,
    eq. 2 and eq. 4)  

    Reference: Coates, P.: The correction for photonpile-up in the measurement of
    radiative lifetimes. J. Phys. E: Sci. Instrum. 1(8), 878–879 (1968)  

    Parameters
    ----------
    * `model[in`, `out]` :  
        The array containing the model function  
    * `n_model[in]` :  
        Number of elements in the model array  
    * `data[in]` :  
        The array containing the experimental decay  
    * `n_data[in]` :  
        number of elements in experimental decay  
    * `repetition_rate[in]` :  
        The repetition-rate (excitation rate) in MHz  
    * `instrument_dead_time[in]` :  
        The overall dead-time of the detection system in nanoseconds  
    * `measurement_time[in]` :  
        The measurement time in seconds  
    * `pile_up_model[in]` :  
        The model used to compute the pile up distortion.  
    * `start` :  
        Start index for pile up  
    * `stop` :  
        Stop index for pile up (default "coates")  

    """
    return _tttrlib.add_pile_up_to_model(*args, **kwargs)

def rescale(fit, decay, start=0, stop=-1):
    r"""
    rescale(fit, decay, start=0, stop=-1) -> double

    Parameters
    ----------
    fit: double *
    decay: double *
    start: int
    stop: int

    """
    return _tttrlib.rescale(fit, decay, start, stop)

def rescale_w(fit, decay, w_sq, start=0, stop=-1):
    r"""
    rescale_w(fit, decay, w_sq, start=0, stop=-1) -> double

    Parameters
    ----------
    fit: double *
    decay: double *
    w_sq: double *
    start: int
    stop: int

    """
    return _tttrlib.rescale_w(fit, decay, w_sq, start, stop)

def rescale_w_bg(fit, decay, w_sq, bg, start=0, stop=-1):
    r"""
    rescale_w_bg(fit, decay, w_sq, bg, start=0, stop=-1) -> double

    Parameters
    ----------
    fit: double *
    decay: double *
    w_sq: double *
    bg: double
    start: int
    stop: int

    """
    return _tttrlib.rescale_w_bg(fit, decay, w_sq, bg, start, stop)

def fconv(fit, irf, x, start=0, stop=-1, dt=1.0):
    r"""
    fconv(fit, irf, x, start=0, stop=-1, dt=1.0)

    Parameters
    ----------
    fit: double *
    irf: double *
    x: double *
    start: int
    stop: int
    dt: double

    """
    return _tttrlib.fconv(fit, irf, x, start, stop, dt)

def fconv_avx(fit, irf, x, start=0, stop=-1, dt=1.0):
    r"""
    fconv_avx(fit, irf, x, start=0, stop=-1, dt=1.0)

    Parameters
    ----------
    fit: double *
    irf: double *
    x: double *
    start: int
    stop: int
    dt: double

    """
    return _tttrlib.fconv_avx(fit, irf, x, start, stop, dt)

def fconv_per(fit, irf, x, period, start=0, stop=-1, dt=1.0):
    r"""
    fconv_per(fit, irf, x, period, start=0, stop=-1, dt=1.0)

    Parameters
    ----------
    fit: double *
    irf: double *
    x: double *
    period: double
    start: int
    stop: int
    dt: double

    """
    return _tttrlib.fconv_per(fit, irf, x, period, start, stop, dt)

def fconv_per_avx(fit, irf, x, period, start=0, stop=-1, dt=1.0):
    r"""
    fconv_per_avx(fit, irf, x, period, start=0, stop=-1, dt=1.0)

    Parameters
    ----------
    fit: double *
    irf: double *
    x: double *
    period: double
    start: int
    stop: int
    dt: double

    """
    return _tttrlib.fconv_per_avx(fit, irf, x, period, start, stop, dt)

def fconv_per_cs(fit, irf, x, period, conv_stop=-1, stop=-1, dt=1.0):
    r"""
    fconv_per_cs(fit, irf, x, period, conv_stop=-1, stop=-1, dt=1.0)

    Parameters
    ----------
    fit: double *
    irf: double *
    x: double *
    period: double
    conv_stop: int
    stop: int
    dt: double

    """
    return _tttrlib.fconv_per_cs(fit, irf, x, period, conv_stop, stop, dt)

def fconv_ref(fit, irf, x, tauref, start=0, stop=-1, dt=1.0):
    r"""
    fconv_ref(fit, irf, x, tauref, start=0, stop=-1, dt=1.0)

    Parameters
    ----------
    fit: double *
    irf: double *
    x: double *
    tauref: double
    start: int
    stop: int
    dt: double

    """
    return _tttrlib.fconv_ref(fit, irf, x, tauref, start, stop, dt)

def sconv(fit, irf, model, start=0, stop=-1):
    r"""
    sconv(fit, irf, model, start=0, stop=-1)

    Parameters
    ----------
    fit: double *
    irf: double *
    model: double *
    start: int
    stop: int

    """
    return _tttrlib.sconv(fit, irf, model, start, stop)

def shift_lamp(lamp, lampsh, ts=0.0, out_value=0.0):
    r"""
    shift_lamp(lamp, lampsh, ts=0.0, out_value=0.0)

    Parameters
    ----------
    lamp: double *
    lampsh: double *
    ts: double
    out_value: double

    """
    return _tttrlib.shift_lamp(lamp, lampsh, ts, out_value)

def discriminate_small_amplitudes(lifetime_spectrum, amplitude_threshold):
    r"""
    discriminate_small_amplitudes(lifetime_spectrum, amplitude_threshold)

    Parameters
    ----------
    lifetime_spectrum: double *
    amplitude_threshold: double



    Threshold the amplitudes  

    Amplitudes with absolute values smaller than the specified threshold are set to
    zero.  

    Parameters
    ----------
    * `lifetime_spectrum` :  
        interleaved lifetime spectrum (amplitude, lifetime)  
    * `n_lifetime_spectrum` :  
        number of elements in lifetime spectrum  
    * `amplitude_threshold` :  

    """
    return _tttrlib.discriminate_small_amplitudes(lifetime_spectrum, amplitude_threshold)

def fconv_per_cs_time_axis(model, time_axis, irf, lifetime_spectrum, convolution_start=0, convolution_stop=-1, period=100.0):
    r"""
    fconv_per_cs_time_axis(model, time_axis, irf, lifetime_spectrum, convolution_start=0, convolution_stop=-1, period=100.0)

    Parameters
    ----------
    model: double *
    time_axis: double *
    irf: double *
    lifetime_spectrum: double *
    convolution_start: int
    convolution_stop: int
    period: double



    Compute the fluorescence decay for a lifetime spectrum and a instrument response
    function considering periodic excitation.  

    Fills the pre-allocated output array `output_decay` with a fluorescence
    intensity decay defined by a set of fluorescence lifetimes defined by the
    parameter `lifetime_handler`. The fluorescence decay will be convolved (non-
    periodically) with an instrumental response function that is defined by
    `instrument_response_function`.  

    This function calculates a fluorescence intensity model_decay that is convolved
    with an instrument response function (IRF). The fluorescence intensity
    model_decay is specified by its fluorescence lifetime spectrum, i.e., an
    interleaved array containing fluorescence lifetimes with corresponding
    amplitudes.  

    This convolution only works with evenly linear spaced time axes.  

    Parameters
    ----------
    * `inplace_output[in`, `out]` :  
        Inplace output array that is filled with the values of the computed
        fluorescence intensity decay model  
    * `n_output[in]` :  
        Number of elements in the output array  
    * `time_axis[in]` :  
        the time-axis of the model_decay  
    * `n_time_axis[in]` :  
        length of the time axis  
    * `irf[in]` :  
        the instrument response function array  
    * `n_irf[in]` :  
        length of the instrument response function array  
    * `lifetime_spectrum[in]` :  
        Interleaved array of amplitudes and fluorescence lifetimes of the form
        (amplitude, lifetime, amplitude, lifetime, ...)  
    * `n_lifetime_spectrum[in]` :  
        number of elements in the lifetime spectrum  
    * `convolution_start[in]` :  
        Start channel of convolution (position in array of IRF)  
    * `convolution_stop[in]` :  
        convolution stop channel (the index on the time-axis)  
    * `period` :  
        Period of repetition in units of the lifetime (usually, nano-seconds)  

    """
    return _tttrlib.fconv_per_cs_time_axis(model, time_axis, irf, lifetime_spectrum, convolution_start, convolution_stop, period)

def fconv_cs_time_axis(inplace_output, time_axis, instrument_response_function, n_instrument_response_function, lifetime_spectrum, convolution_start=0, convolution_stop=-1):
    r"""
    fconv_cs_time_axis(inplace_output, time_axis, instrument_response_function, n_instrument_response_function, lifetime_spectrum, convolution_start=0, convolution_stop=-1)

    Parameters
    ----------
    inplace_output: double *
    time_axis: double *
    instrument_response_function: double *
    n_instrument_response_function: int
    lifetime_spectrum: double *
    convolution_start: int
    convolution_stop: int



    Compute the fluorescence decay for a lifetime spectrum and a instrument response
    function.  

    Fills the pre-allocated output array `output_decay` with a fluorescence
    intensity decay defined by a set of fluorescence lifetimes defined by the
    parameter `lifetime_handler`. The fluorescence decay will be convolved (non-
    periodically) with an instrumental response function that is defined by
    `instrument_response_function`.  

    This function calculates a fluorescence intensity model_decay that is convolved
    with an instrument response function (IRF). The fluorescence intensity
    model_decay is specified by its fluorescence lifetime spectrum, i.e., an
    interleaved array containing fluorescence lifetimes with corresponding
    amplitudes.  

    This convolution works also with uneven spaced time axes.  

    Parameters
    ----------
    * `inplace_output[in`, `out]` :  
        Inplace output array that is filled with the values of the computed
        fluorescence intensity decay model  
    * `n_output[in]` :  
        Number of elements in the output array  
    * `time_axis[in]` :  
        the time-axis of the model_decay  
    * `n_time_axis[in]` :  
        length of the time axis  
    * `irf[in]` :  
        the instrument response function array  
    * `n_irf[in]` :  
        length of the instrument response function array  
    * `lifetime_spectrum[in]` :  
        Interleaved array of amplitudes and fluorescence lifetimes of the form
        (amplitude, lifetime, amplitude, lifetime, ...)  
    * `n_lifetime_spectrum[in]` :  
        number of elements in the lifetime spectrum  
    * `convolution_start[in]` :  
        Start channel of convolution (position in array of IRF)  
    * `convolution_stop[in]` :  
        convolution stop channel (the index on the time-axis)  
    * `use_amplitude_threshold[in]` :  
        If this value is True (default False) fluorescence lifetimes in the lifetime
        spectrum which have an amplitude with an absolute value of that is smaller
        than `amplitude_threshold` are not omitted in the convolution.  
    * `amplitude_threshold[in]` :  
        Threshold value for the amplitudes  

    """
    return _tttrlib.fconv_cs_time_axis(inplace_output, time_axis, instrument_response_function, n_instrument_response_function, lifetime_spectrum, convolution_start, convolution_stop)
class DecayFitCorrections(object):
    r"""


    C++ includes: DecayFit.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    gamma = property(_tttrlib.DecayFitCorrections_gamma_get, _tttrlib.DecayFitCorrections_gamma_set, doc=r"""gamma""")
    g = property(_tttrlib.DecayFitCorrections_g_get, _tttrlib.DecayFitCorrections_g_set, doc=r"""g""")
    l1 = property(_tttrlib.DecayFitCorrections_l1_get, _tttrlib.DecayFitCorrections_l1_set, doc=r"""l1""")
    l2 = property(_tttrlib.DecayFitCorrections_l2_get, _tttrlib.DecayFitCorrections_l2_set, doc=r"""l2""")
    period = property(_tttrlib.DecayFitCorrections_period_get, _tttrlib.DecayFitCorrections_period_set, doc=r"""period""")
    convolution_stop = property(_tttrlib.DecayFitCorrections_convolution_stop_get, _tttrlib.DecayFitCorrections_convolution_stop_set, doc=r"""convolution_stop""")

    def set_gamma(self, v):
        r"""
        set_gamma(self, v)

        Parameters
        ----------
        v: double


        DecayFitCorrections::set_gamma
        """
        return _tttrlib.DecayFitCorrections_set_gamma(self, v)

    def str(self):
        r"""
        str(self) -> std::string

        DecayFitCorrections::str
        """
        return _tttrlib.DecayFitCorrections_str(self)

    def __init__(self, gamma=0.0, g=1.0, l1=0.0, l2=0.0, period=1000, convolution_stop=0):
        r"""
        __init__(self, gamma=0.0, g=1.0, l1=0.0, l2=0.0, period=1000, convolution_stop=0) -> DecayFitCorrections

        Parameters
        ----------
        gamma: double
        g: double
        l1: double
        l2: double
        period: double
        convolution_stop: int


        DecayFitCorrections::DecayFitCorrections
        """
        _tttrlib.DecayFitCorrections_swiginit(self, _tttrlib.new_DecayFitCorrections(gamma, g, l1, l2, period, convolution_stop))
    __swig_destroy__ = _tttrlib.delete_DecayFitCorrections

# Register DecayFitCorrections in _tttrlib:
_tttrlib.DecayFitCorrections_swigregister(DecayFitCorrections)
class DecayFitSettings(object):
    r"""


    C++ includes: DecayFit.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    fixedrho = property(_tttrlib.DecayFitSettings_fixedrho_get, _tttrlib.DecayFitSettings_fixedrho_set, doc=r"""fixedrho""")
    softbifl = property(_tttrlib.DecayFitSettings_softbifl_get, _tttrlib.DecayFitSettings_softbifl_set, doc=r"""softbifl""")
    p2s_twoIstar = property(_tttrlib.DecayFitSettings_p2s_twoIstar_get, _tttrlib.DecayFitSettings_p2s_twoIstar_set, doc=r"""p2s_twoIstar""")
    firstcall = property(_tttrlib.DecayFitSettings_firstcall_get, _tttrlib.DecayFitSettings_firstcall_set, doc=r"""firstcall""")
    penalty = property(_tttrlib.DecayFitSettings_penalty_get, _tttrlib.DecayFitSettings_penalty_set, doc=r"""penalty""")

    def str(self):
        r"""
        str(self) -> std::string

        DecayFitSettings::str
        """
        return _tttrlib.DecayFitSettings_str(self)

    def __init__(self):
        r"""
        __init__(self) -> DecayFitSettings


        C++ includes: DecayFit.h

        """
        _tttrlib.DecayFitSettings_swiginit(self, _tttrlib.new_DecayFitSettings())
    __swig_destroy__ = _tttrlib.delete_DecayFitSettings

# Register DecayFitSettings in _tttrlib:
_tttrlib.DecayFitSettings_swigregister(DecayFitSettings)
class DecayFitIntegrateSignals(object):
    r"""


    C++ includes: DecayFit.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    corrections = property(_tttrlib.DecayFitIntegrateSignals_corrections_get, _tttrlib.DecayFitIntegrateSignals_corrections_set, doc=r"""corrections""")
    Sp = property(_tttrlib.DecayFitIntegrateSignals_Sp_get, _tttrlib.DecayFitIntegrateSignals_Sp_set, doc=r"""Sp""")
    Ss = property(_tttrlib.DecayFitIntegrateSignals_Ss_get, _tttrlib.DecayFitIntegrateSignals_Ss_set, doc=r"""Ss""")
    Bp = property(_tttrlib.DecayFitIntegrateSignals_Bp_get, _tttrlib.DecayFitIntegrateSignals_Bp_set, doc=r"""Bp""")
    Bs = property(_tttrlib.DecayFitIntegrateSignals_Bs_get, _tttrlib.DecayFitIntegrateSignals_Bs_set, doc=r"""Bs""")
    B = property(_tttrlib.DecayFitIntegrateSignals_B_get, _tttrlib.DecayFitIntegrateSignals_B_set, doc=r"""B""")
    Bexpected = property(_tttrlib.DecayFitIntegrateSignals_Bexpected_get, _tttrlib.DecayFitIntegrateSignals_Bexpected_set, doc=r"""Bexpected""")

    def Fp(self):
        r"""
        Fp(self) -> double

        DecayFitIntegrateSignals::Fp
        """
        return _tttrlib.DecayFitIntegrateSignals_Fp(self)

    def Fs(self):
        r"""
        Fs(self) -> double

        DecayFitIntegrateSignals::Fs
        """
        return _tttrlib.DecayFitIntegrateSignals_Fs(self)

    def r(self):
        r"""
        r(self) -> double

        DecayFitIntegrateSignals::r
        """
        return _tttrlib.DecayFitIntegrateSignals_r(self)

    def rho(self, tau, r0):
        r"""
        rho(self, tau, r0) -> double

        Parameters
        ----------
        tau: double
        r0: double


        DecayFitIntegrateSignals::rho
        """
        return _tttrlib.DecayFitIntegrateSignals_rho(self, tau, r0)

    def rs(self):
        r"""
        rs(self) -> double

        DecayFitIntegrateSignals::rs
        """
        return _tttrlib.DecayFitIntegrateSignals_rs(self)

    def compute_signal_and_background(self, p):
        r"""
        compute_signal_and_background(self, p)

        Parameters
        ----------
        p: MParam *


        DecayFitIntegrateSignals::compute_signal_and_background
        Computes the total number of photons in the parallel and perpendicular detection
        channel for the background and the measured signal. The computed number of
        photons are stored in the static variables Sp, Ss, Bp, Bs.  

        Parameters
        ----------
        * `p[in]` :  
            a pointer to a MParam object  

        """
        return _tttrlib.DecayFitIntegrateSignals_compute_signal_and_background(self, p)

    def normM(self, *args):
        r"""
        normM(self, M, Nchannels)

        Parameters
        ----------
        M: double *
        Nchannels: int

        normM(self, M, s, Nchannels)

        Parameters
        ----------
        M: double *
        s: double
        Nchannels: int


        DecayFitIntegrateSignals::normM
        Normalizes a model function (that is already normalized to a unit area) to the
        total number of photons in parallel and perpendicular,  

        Parameters
        ----------
        * `M[in`, `out]` :  
            array containing the model function in Jordi format  
        * `s[in]` :  
            a scaling factor by which the model function is divided.  
        * `Nchannels[in]` :  
            the number of channels in the model function (half length of M array)  

        """
        return _tttrlib.DecayFitIntegrateSignals_normM(self, *args)

    def normM_p2s(self, M, Nchannels):
        r"""
        normM_p2s(self, M, Nchannels)

        Parameters
        ----------
        M: double *
        Nchannels: int


        DecayFitIntegrateSignals::normM_p2s
        Normalizes the number of photons in the model function for Ss and Sp
        individually to the number of experimental photons in Ss and Sp.  

        Here, the number of experimental photons are global variables that can be
        computed by `compute_signal_and_background`.  

        Parameters
        ----------
        * `M` :  
            array[in,out] containing the model function in Jordi format  
        * `Nchannels[in]` :  
            number of channels in the experiment (half length of M array)  

        """
        return _tttrlib.DecayFitIntegrateSignals_normM_p2s(self, M, Nchannels)

    def str(self):
        r"""
        str(self) -> std::string

        DecayFitIntegrateSignals::str
        """
        return _tttrlib.DecayFitIntegrateSignals_str(self)

    def __init__(self, corrections=None):
        r"""
        __init__(self, corrections=None) -> DecayFitIntegrateSignals

        Parameters
        ----------
        corrections: DecayFitCorrections *


        DecayFitIntegrateSignals::DecayFitIntegrateSignals
        """
        _tttrlib.DecayFitIntegrateSignals_swiginit(self, _tttrlib.new_DecayFitIntegrateSignals(corrections))
    __swig_destroy__ = _tttrlib.delete_DecayFitIntegrateSignals

# Register DecayFitIntegrateSignals in _tttrlib:
_tttrlib.DecayFitIntegrateSignals_swigregister(DecayFitIntegrateSignals)
class DecayFit(object):
    r"""


    C++ includes: DecayFit.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def modelf(param, irf, bg, Nchannels, dt, corrections, mfunction):
        r"""
        modelf(param, irf, bg, Nchannels, dt, corrections, mfunction) -> int

        Parameters
        ----------
        param: double *
        irf: double *
        bg: double *
        Nchannels: int
        dt: double
        corrections: double *
        mfunction: double *


        DecayFit::modelf
        Function to compute a model fluorescence decay.  

        Parameters
        ----------
        * `param` :  
            array containing the model parameters  
        * `irf` :  
            instrument response function in Jordi format (parallel, perpendicular)  
        * `bg[in]` :  
            background pattern in Jordi format (parallel, perpendicular)  
        * `Nchannels[in]` :  
            number of channels (half the length of the Jordi arrays)  
        * `dt[in]` :  
            time difference between two consecutive counting channels  
        * `corrections[in]` :  
            array with corrections (details see implementations)  
        * `mfunction[out]` :  
            output array of the computed decay in Jordi format. The output array has to
            have twice the number of channels. It needs to be allocated by beforehand.  

        Returns
        -------
        integer For reporting failures (default 0)  

        """
        return _tttrlib.DecayFit_modelf(param, irf, bg, Nchannels, dt, corrections, mfunction)

    @staticmethod
    def targetf(x, pv):
        r"""
        targetf(x, pv) -> double

        Parameters
        ----------
        x: double *
        pv: void *


        DecayFit::targetf
        Target function (to minimize)  

        Computes the model function and returns a score that quantifies the discrepancy
        between the data and the model.  

        Parameters
        ----------
        * `x[in`, `out]` :  
            a vector of length that that contains the model parameters  
        * `pv[in]` :  
            a pointer to a MParam structure that contains the data and a set of
            corrections.  

        Returns
        -------
        a normalized chi2  

        """
        return _tttrlib.DecayFit_targetf(x, pv)

    @staticmethod
    def fit(x, fixed, p):
        r"""
        fit(x, fixed, p) -> double

        Parameters
        ----------
        x: double *
        fixed: short *
        p: MParam *


        DecayFit::fit
        Function that optimizes parameters of model23 to data.  

        Parameters
        ----------
        * `x[in`, `out]` :  
            a vector of length that that contains the starting parameters  
        * `fixed` :  
            an array that specifies if a parameter is optimized. If a value is set to 1,
            the parameter is optimized.  
        * `p` :  
            an instance of MParam that contains all relevant information  

        Returns
        -------  

        """
        return _tttrlib.DecayFit_fit(x, fixed, p)

    @staticmethod
    def correct_input(x, xm, corrections, return_r):
        r"""
        correct_input(x, xm, corrections, return_r)

        Parameters
        ----------
        x: double *
        xm: double *
        corrections: LVDoubleArray *
        return_r: int


        DecayFit::correct_input
        Correct input parameters and compute values  

        Parameters
        ----------
        * `x[in`, `out]` :  
            input output array (see implementations of derived classes)  
        * `xm[in`, `out]` :  
            array that will contain the corrected parameters  
        * `corrections[in]` :  
            array with correction parameters  
        * `return_r[in]` :  
            if set to true (positive) computes the anisotropy and returns the scatter
            corrected and the signal (no scatter correction) anisotropy and writes the
            values to the input/output vector x.  

        """
        return _tttrlib.DecayFit_correct_input(x, xm, corrections, return_r)

    def __init__(self):
        r"""
        __init__(self) -> DecayFit


        C++ includes: DecayFit.h

        """
        _tttrlib.DecayFit_swiginit(self, _tttrlib.new_DecayFit())
    __swig_destroy__ = _tttrlib.delete_DecayFit

# Register DecayFit in _tttrlib:
_tttrlib.DecayFit_swigregister(DecayFit)
class LVI32Array(object):
    r"""


    Structures and functions used for LabView interface.  

    fit2x was originally developed as a C backend for LabView software. Therefore,
    the interface with fit2x uses structures that can be accessed by Labview. In
    order to make an interfacing with Python and other languages possible there is a
    this files defines a set of functions that facilitate the creation of the
    LabView structures.  

    C++ includes: LvArrays.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    length = property(_tttrlib.LVI32Array_length_get, _tttrlib.LVI32Array_length_set, doc=r"""length""")
    data = property(_tttrlib.LVI32Array_data_get, _tttrlib.LVI32Array_data_set, doc=r"""data""")
    __swig_destroy__ = _tttrlib.delete_LVI32Array

    def str(self):
        r"""
        str(self) -> std::string

        LVI32Array::str
        """
        return _tttrlib.LVI32Array_str(self)

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> int

        Parameters
        ----------
        i: size_t

        """
        return _tttrlib.LVI32Array___getitem__(self, i)

    def __setitem__(self, i, value):
        r"""
        __setitem__(self, i, value)

        Parameters
        ----------
        i: size_t
        value: int

        """
        return _tttrlib.LVI32Array___setitem__(self, i, value)

    def __len__(self):
        r"""__len__(self) -> size_t"""
        return _tttrlib.LVI32Array___len__(self)

    def insert(self, i, value):
        r"""
        insert(self, i, value)

        Parameters
        ----------
        i: size_t
        value: int

        """
        return _tttrlib.LVI32Array_insert(self, i, value)

    def set_data(self, input):
        r"""
        set_data(self, input)

        Parameters
        ----------
        input: PyObject *

        """
        return _tttrlib.LVI32Array_set_data(self, input)

    def __init__(self):
        r"""
        __init__(self) -> LVI32Array


        Structures and functions used for LabView interface.  

        fit2x was originally developed as a C backend for LabView software. Therefore,
        the interface with fit2x uses structures that can be accessed by Labview. In
        order to make an interfacing with Python and other languages possible there is a
        this files defines a set of functions that facilitate the creation of the
        LabView structures.  

        C++ includes: LvArrays.h

        """
        _tttrlib.LVI32Array_swiginit(self, _tttrlib.new_LVI32Array())

# Register LVI32Array in _tttrlib:
_tttrlib.LVI32Array_swigregister(LVI32Array)
class LVDoubleArray(object):
    r"""


    C++ includes: LvArrays.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    length = property(_tttrlib.LVDoubleArray_length_get, _tttrlib.LVDoubleArray_length_set, doc=r"""length""")
    data = property(_tttrlib.LVDoubleArray_data_get, _tttrlib.LVDoubleArray_data_set, doc=r"""data""")
    __swig_destroy__ = _tttrlib.delete_LVDoubleArray

    def str(self):
        r"""
        str(self) -> std::string

        LVDoubleArray::str
        """
        return _tttrlib.LVDoubleArray_str(self)

    def __getitem__(self, i):
        r"""
        __getitem__(self, i) -> double

        Parameters
        ----------
        i: size_t

        """
        return _tttrlib.LVDoubleArray___getitem__(self, i)

    def __setitem__(self, i, value):
        r"""
        __setitem__(self, i, value)

        Parameters
        ----------
        i: size_t
        value: double

        """
        return _tttrlib.LVDoubleArray___setitem__(self, i, value)

    def __len__(self):
        r"""__len__(self) -> size_t"""
        return _tttrlib.LVDoubleArray___len__(self)

    def insert(self, i, value):
        r"""
        insert(self, i, value)

        Parameters
        ----------
        i: size_t
        value: double

        """
        return _tttrlib.LVDoubleArray_insert(self, i, value)

    def set_data(self, input):
        r"""
        set_data(self, input)

        Parameters
        ----------
        input: PyObject *

        """
        return _tttrlib.LVDoubleArray_set_data(self, input)

    def __init__(self):
        r"""
        __init__(self) -> LVDoubleArray


        C++ includes: LvArrays.h

        """
        _tttrlib.LVDoubleArray_swiginit(self, _tttrlib.new_LVDoubleArray())

# Register LVDoubleArray in _tttrlib:
_tttrlib.LVDoubleArray_swigregister(LVDoubleArray)
class MParam(object):
    r"""


    C++ includes: LvArrays.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    expdata = property(_tttrlib.MParam_expdata_get, _tttrlib.MParam_expdata_set, doc=r"""expdata""")
    irf = property(_tttrlib.MParam_irf_get, _tttrlib.MParam_irf_set, doc=r"""irf""")
    bg = property(_tttrlib.MParam_bg_get, _tttrlib.MParam_bg_set, doc=r"""bg""")
    dt = property(_tttrlib.MParam_dt_get, _tttrlib.MParam_dt_set, doc=r"""dt""")
    corrections = property(_tttrlib.MParam_corrections_get, _tttrlib.MParam_corrections_set, doc=r"""corrections""")
    M = property(_tttrlib.MParam_M_get, _tttrlib.MParam_M_set, doc=r"""M""")
    __swig_destroy__ = _tttrlib.delete_MParam

    def get_irf(self):
        r"""get_irf(self) -> LVDoubleArray"""
        return _tttrlib.MParam_get_irf(self)

    def get_model(self):
        r"""get_model(self) -> LVDoubleArray"""
        return _tttrlib.MParam_get_model(self)

    def get_data(self):
        r"""get_data(self) -> LVI32Array"""
        return _tttrlib.MParam_get_data(self)

    def get_corrections(self):
        r"""get_corrections(self) -> LVDoubleArray"""
        return _tttrlib.MParam_get_corrections(self)

    def get_background(self):
        r"""get_background(self) -> LVDoubleArray"""
        return _tttrlib.MParam_get_background(self)

    def __init__(self):
        r"""
        __init__(self) -> MParam


        C++ includes: LvArrays.h

        """
        _tttrlib.MParam_swiginit(self, _tttrlib.new_MParam())

# Register MParam in _tttrlib:
_tttrlib.MParam_swigregister(MParam)

def CreateLVI32Array(len):
    r"""
    CreateLVI32Array(len) -> LVI32Array

    Parameters
    ----------
    len: size_t



    Parameters
    ----------
    * `len` :  

    Returns
    -------  

    """
    return _tttrlib.CreateLVI32Array(len)

def CreateLVDoubleArray(len):
    r"""
    CreateLVDoubleArray(len) -> LVDoubleArray

    Parameters
    ----------
    len: size_t



    Parameters
    ----------
    * `len` :  

    Returns
    -------  

    """
    return _tttrlib.CreateLVDoubleArray(len)

def CreateMParam(*args, **kwargs):
    r"""
    CreateMParam(dt=1.0, corrections=std::vector< double >(), irf=std::vector< double >(), background=std::vector< double >(), data=std::vector< int >()) -> MParam

    Parameters
    ----------
    dt: double
    corrections: std::vector< double,std::allocator< double > >
    irf: std::vector< double,std::allocator< double > >
    background: std::vector< double,std::allocator< double > >
    data: std::vector< int,std::allocator< int > >



    """
    return _tttrlib.CreateMParam(*args, **kwargs)
class Fit2x(object):

    def __init__(
            self,
            dt,                           # type: float
            irf,                          # type: np.ndarray
            background,                   # type: np.ndarray
            period,                       # type: float
            g_factor = 1.0,               # type: float
            l1 = 0.0,                     # type: float
            l2 = 0.0,                     # type: float
            convolution_stop = -1,        # type: int
            soft_bifl_scatter_flag = True,# type: bool
            verbose = False,              # type: bool
            p2s_twoIstar_flag = False     # type: bool
    ):
        """
        :param dt: time difference between microtime bins
        :param irf: counting histogram of the instrument response function in
        Jordi format
        :param background: background counting histogram in Jordi format
        :param period: excitation period of the light source
        :param g_factor: g-factor, only used for calculation of anisotropy by
        intensity in Ss and Sp
        :param l1: factor correcting mixing between parallel and perpendicular
        detection channel, only used for calculation of anisotropy by
        intensity in Ss and Sp
        :param l2: factor correcting mixing between parallel and perpendicular
        detection channel, only used for calculation of anisotropy by
        intensity in Ss and Sp
        :param convolution_stop: maximum micro time channel for comvolution. If
        no value is provided the length of the IRF is used
        :param soft_bifl_scatter_flag: if set to True the returned Istar value
        is reduced by the background photon contribution (background photons do
        no inform on the fluorescence lifetime)
        :param p2s_twoIstar_flag: If this is set to True the sum decay composed
        by P + 2S (P - Parallel, S - Perpendicular) is optimized. Otherwise
        (default) the decays P and S are optimized individually in a global fit.
        :param verbose: if set to True is more verbose
        """
        if len(irf) != len(background):
            raise ValueError("The IRF and the background differ in size")
        if len(irf) % 2 != 0:
            raise ValueError("The length of the input arrays is not divisible "
                             "by two. Inputs need to be in Jordi format.")
        if convolution_stop < 0:
            convolution_stop = len(irf) // 2 - 1
        self._bifl_scatter = -1 if soft_bifl_scatter_flag else 0
        self._p_2s_flag = p2s_twoIstar_flag
        self._corrections = np.array([period, g_factor, l1, l2, convolution_stop])
        self._irf = irf
        self._background = background
        self._dt = dt
        self._m_param = CreateMParam(
            irf=self._irf,
            background=self._background,
            corrections=self._corrections,
            dt=self._dt
        )
        self._verbose = verbose

    @property
    def model(self):
        return np.array([x for x in self._m_param.get_model()])

    @property
    def data(self):
        return np.array([x for x in self._m_param.get_data()])

    @property
    def irf(self):
        return np.array([x for x in self._m_param.get_irf()])

    @property
    def background(self):
        return np.array([x for x in self._m_param.get_background()])

    def __call__(self, data):
# type: (np.ndarray) -> None
        """Take care of data ana make sure that it is a numpy object
        with appropriate dtype

        :param data:
        :return:
        """
        self._m_param.get_data().set_data(
            np.array(data).astype(dtype=np.int32)
        )



class Fit23(Fit2x):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def __call__(
            self,
            data, # type: np.ndarray
            initial_values, # type: np.ndarray
            fixed = None, # type: np.ndarray
            include_model = False # type: bool
    ):
# type: (...) ->  dict
        """

        :param data: counting histogram containing experimental data
        :param initial_values: initial values of the model parameters that can
        be optimized. [tau, gamma, r0, rho]
        :param fixed: optional array of short (16bit) integers that specifies if
        a parameter is fixed. Parameters that are fixed are not optimized.
        :param include_model: if set to True (default is False) the realization
        of the model that corresponds to the optimized parameters is included in
        the returned dictionary.
        :return: dictionary containing a quality parameter (key: "Istar"), the
        corresponding optimized model parameter values (key: "x"), and an array
        which parameters were fixed (key: "fixed").
        """
        super().__call__(data=data)
        if len(initial_values) < 4:
            raise ValueError(
                "Provide initial values for all for all 4 fitting "
                "parameters."
            )
        if fixed is None:
# lifetime free
            fixed = np.array([0, 1, 1, 1], dtype=np.int16)
        elif isinstance(fixed, np.ndarray):
            if len(fixed) < 4:
                raise ValueError(
                    "The fixed array is too short. Specify for all 4 fitting "
                    "parameters if they are fixed."
                )
        else:
            raise ValueError(
                "The fixed array is of the wrong type. Use an numpy array of "
                "length 4 to specify the fixed state for all 4 model "
                "parameters."
            )
        r = dict()
        x = np.zeros(8, dtype=np.float64)
        x[:4] = initial_values
        x[4] = self._bifl_scatter
        x[5] = self._p_2s_flag
# the other x values are used as outputs
        fixed = fixed.astype(dtype=np.int16)
        twoIstar = DecayFit23.fit(x, fixed, self._m_param)
        r['x'] = x
        r['fixed'] = fixed
        r['twoIstar'] = twoIstar
        if include_model:
            r['model'] = self.model
        return r


class Fit24(Fit2x):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._parameter_names = [
            'tau1', 'gamma', 'tau2', 'a2',
            'offset / background'
        ]

    def __call__(
            self,
            data, # type: np.ndarray
            initial_values, # type: np.ndarray
            fixed = None, # type: np.ndarray
            include_model = False # type: bool
    ):
# type: (...) -> dict
        """
        :param data: counting histogram containing experimental data
        :param initial_values: initial values of the model parameters that can
        be optimized. [tau1, gamma, tau2, A2, offset]
        :param fixed: optional array of short (16bit) integers that specifies if
        a parameter is fixed. Parameters that are fixed are not optimized.
        :param include_model: if set to True (default is False) the realization
        of the model that corresponds to the optimized parameters is included in
        the returned dictionary.
        :return: dictionary containing a quality parameter (key: "twoIstar"), the
        corresponding optimized model parameter values (key: "x"), and an array
        which parameters were fixed (key: "fixed").
        """
        super().__call__(data=data)
        if len(initial_values) < 5:
            raise ValueError(
                "Provide initial values for all for all 4 fitting "
                "parameters."
            )
        if fixed is None:
# lifetime free
            fixed = np.array([0, 0, 0, 0, 0], dtype=np.int16)
        elif isinstance(fixed, np.ndarray):
            if len(fixed) < 5:
                raise ValueError(
                    "The fixed array is too short. Specify for all 5 fitting "
                    "parameters if they are fixed."
                )
        else:
            raise ValueError(
                "The fixed array is of the wrong type. Use an numpy array of "
                "length 5 to specify the fixed state for all 5 model "
                "parameters."
            )
        bifl_scatter = self._bifl_scatter
        x = np.zeros(8, dtype=np.float64)
        x[:5] = initial_values
        x[5] = bifl_scatter
        fixed = fixed.astype(dtype=np.int16)
        twoIstar = DecayFit24.fit(x, fixed, self._m_param)
        if self._verbose:
            print("Fitting")
            print("Parameter names: ", self._parameter_names)
            print("initial_values: ", initial_values)
            print("fixed: ", fixed)
            print("include_model: ", include_model)
            print("x0: ", x)
        r = dict()
        r['x'] = x
        r['fixed'] = fixed
        r['twoIstar'] = twoIstar
        if include_model:
            r['model'] = self.model
        return r


class Fit25(Fit2x):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self._parameter_names = [
            'tau1', 'tau2', 'tau3', 'tau4', 'gamma'
        ]

    def __call__(
            self,
            data, # type: np.ndarray
            initial_values, # type: np.ndarray
            fixed = None, # type: np.ndarray
            include_model = False # type: bool
    ):
# type: (...) -> dict
        """
        :param data: counting histogram containing experimental data
        :param initial_values: initial values of the model parameters that can
        be optimized. [tau1, tau2, tau3, tau4, gamma]. The lifetimes are always
        fixed and not optimized. The lifetime best describing the data is
        returned.
        :param fixed: optional array of short (16bit) integers that specifies if
        a parameter is fixed. Parameters that are fixed are not optimized.
        :param include_model: if set to True (default is False) the realization
        of the model that corresponds to the optimized parameters is included in
        the returned dictionary.
        :return: dictionary containing a quality parameter (key: "twoIstar"), the
        corresponding optimized model parameter values (key: "x"), and an array
        which parameters were fixed (key: "fixed").
        """
        super().__call__(data=data)
        if len(initial_values) < 5:
            raise ValueError(
                "Provide initial values for all for all 6 fitting "
                "parameters."
            )
        if fixed is None:
            fixed = np.array([0, 0, 0, 0, 0], dtype=np.int16)
        elif isinstance(fixed, np.ndarray):
            if len(fixed) < 5:
                raise ValueError(
                    "The fixed array is too short. Specify for all 6 fitting "
                    "parameters if they are fixed."
                )
        else:
            raise ValueError(
                "The fixed array is of the wrong type. Use an numpy array of "
                "length 5 to specify the fixed state for all 6 model "
                "parameters."
            )
        bifl_scatter = self._bifl_scatter
        x = np.zeros(9, dtype=np.float64)
        if self._verbose:
            print("Fitting")
            print("Parameter names: ", self._parameter_names)
            print("initial_values: ", initial_values)
            print("fixed: ", fixed)
            print("include_model: ", include_model)
        x[:6] = initial_values
        x[6] = bifl_scatter
        if self._verbose:
            print("x0: ", x)
        fixed = fixed.astype(dtype=np.int16)
        twoIstar = DecayFit25.fit(x, fixed, self._m_param)
        r = dict()
        r['x'] = x
        r['fixed'] = fixed
        r['twoIstar'] = twoIstar
        if include_model:
            r['model'] = self.model
        return r


class Fit26(Fit2x):

    def __init__(
            self,
            pattern_1, # type: np.ndarray
            pattern_2, # type: np.ndarray
            convolution_stop = -1, # type: int
            verbose = False # type: bool
    ):
        if convolution_stop < 0:
            convolution_stop = min(len(pattern_1), len(pattern_2))
        self._corrections = np.array([1., 1.0, 0.0, 0.0, convolution_stop])
        self._irf = pattern_1
        self._background = pattern_2
        self._m_param = CreateMParam(
            irf=self._irf,
            background=self._background,
            corrections=self._corrections,
            dt=1.0
        )
        self._verbose = verbose
        self._parameter_names = ['x1']

    def __call__(
            self,
            data, # type: np.ndarray
            initial_values, # type: np.ndarray
            fixed = None, # type: np.ndarray
            include_model = False # type: bool
    ): 
# type: (...) ->  dict
        """
        :param data: counting histogram containing experimental data
        :param initial_values: initial values of the model parameters that can
        be optimized. Only the fraction of the first pattern [x1] can be optimized.
        :param fixed: optional array of short (16bit) integers that specifies if
        the fraction x1 is fixed.
        :param include_model: if set to True (default is False) the realization
        of the model that corresponds to the optimized parameters is included in
        the returned dictionary.
        :return: dictionary containing a quality parameter (key: "twoIstar"), the
        corresponding optimized model parameter values (key: "x"), and an array
        which parameters were fixed (key: "fixed").
        """
        super().__call__(data=data)
        if len(initial_values) < 1:
            raise ValueError(
                "Provide initial values for all for all 6 fitting "
                "parameters."
            )
        if fixed is None:
            fixed = np.array([0], dtype=np.int16)
        elif isinstance(fixed, np.ndarray):
            if len(fixed) < 1:
                raise ValueError(
                    "The fixed array is too short. Specify for all 6 fitting "
                    "parameters if they are fixed."
                )
        else:
            raise ValueError(
                "The fixed array is of the wrong type. Use an numpy array of "
                "length 5 to specify the fixed state for all 6 model "
                "parameters."
            )
        x = np.zeros(1, dtype=np.float64)
        x[0] = initial_values[0]
        if self._verbose:
            print("Fitting")
            print("Parameter names: ", self._parameter_names)
            print("initial_values: ", initial_values)
            print("fixed: ", fixed)
            print("include_model: ", include_model)
        if self._verbose:
            print("x0: ", x)
        fixed = fixed.astype(dtype=np.int16)
        twoIstar = DecayFit26.fit(x, fixed, self._m_param)
        r = dict()
        r['x'] = x
        r['fixed'] = fixed
        r['twoIstar'] = twoIstar
        if include_model:
            r['model'] = self.model
        return r


class DecayFit23(object):
    r"""


    C++ includes: DecayFit23.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def correct_input(x, xm, corrections, return_r):
        r"""
        correct_input(x, xm, corrections, return_r)

        Parameters
        ----------
        x: double *
        xm: double *
        corrections: LVDoubleArray *
        return_r: int


        DecayFit23::correct_input
        Correct input parameters and compute anisotropy  

        This function corrects the input parameters for fit23 and takes care of
        unreasonable values. The fluorescence lifetime is constraint to positive values,
        gamma (the fraction of scattered light) is constraint to values between 0.0 and
        0.999, the rotational correlation time rho is (if the global variable fixedrho
        is set to true) to the value that corresponds to the Perrin equation (for the
        computed, experimental anisotropy). Moreover, this function computes the
        anisotropy based on the corrected (g-factor, l1, l2, background) intensities, if
        the variable return_r is set to true.  

        Parameters
        ----------
        * `x[in`, `out]` :  
            array of length 8 that contains parameters x[0] fluorescence lifetime - tau;
            x[1] fraction of scattered light - gamma; x[2] fundamental anisotropy - r0
            x[3] rotational time - rho; x[4] softbifl - flag specifying the type of bifl
            fit (not used here) x[5] p2s_twoIstar - flag specifying the type of chi2
            calculation (not used here) x[6] background corrected anisotropy x[7]
            anisotropy without background correction  
        * `xm[in`, `out]` :  
            array that will contain the corrected parameters  
        * `corrections[in]` :  
        * `return_r[in]` :  
            if set to true (positive) computes the anisotropy and returns the scatter
            corrected and the signal (no scatter correction) anisotropy and writes the
            values to the input/output vector x.  

        """
        return _tttrlib.DecayFit23_correct_input(x, xm, corrections, return_r)

    @staticmethod
    def fit(*args):
        r"""
        fit(x, fixed, p) -> double

        Parameters
        ----------
        x: double *
        fixed: short *
        p: MParam *

        fit(x, fixed, p) -> double

        Parameters
        ----------
        x: double *
        fixed: short *
        p: MParam *

        """
        return _tttrlib.DecayFit23_fit(*args)

    @staticmethod
    def targetf(*args):
        r"""
        targetf(x, pv) -> double

        Parameters
        ----------
        x: double *
        pv: void *

        targetf(x, p) -> double

        Parameters
        ----------
        x: double *
        p: MParam *

        """
        return _tttrlib.DecayFit23_targetf(*args)

    @staticmethod
    def modelf(*args):
        r"""
        modelf(param, irf, bg, Nchannels, dt, corrections, mfunction) -> int

        Parameters
        ----------
        param: double *
        irf: double *
        bg: double *
        Nchannels: int
        dt: double
        corrections: double *
        mfunction: double *

        modelf(param, irf, bg, dt, corrections, mfunction) -> int

        Parameters
        ----------
        param: double *
        irf: double *
        bg: double *
        dt: double
        corrections: double *
        mfunction: double *

        """
        return _tttrlib.DecayFit23_modelf(*args)

    def __init__(self):
        r"""
        __init__(self) -> DecayFit23


        C++ includes: DecayFit23.h

        """
        _tttrlib.DecayFit23_swiginit(self, _tttrlib.new_DecayFit23())
    __swig_destroy__ = _tttrlib.delete_DecayFit23

# Register DecayFit23 in _tttrlib:
_tttrlib.DecayFit23_swigregister(DecayFit23)
class DecayFit24(object):
    r"""


    C++ includes: DecayFit24.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def correct_input(x, xm, corrections, return_r):
        r"""
        correct_input(x, xm, corrections, return_r)

        Parameters
        ----------
        x: double *
        xm: double *
        corrections: LVDoubleArray *
        return_r: int


        DecayFit24::correct_input
        Correct input parameters and compute anisotropy for fit24.  

        limits (0.001 < A2 < 0.999), (0.001 < gamma < 0.999), (tau1 > 0), (tau2 > 0),
        background > 0 (called offset in other places)  

        Parameters
        ----------
        * `x[in`, `out]` :  
            [0] tau1, [1] gamma [2] tau2, [3] A2, [4] background, [5] BIFL scatter fit?
            (flag, not used), [6] anisotropy r (scatter corrected, output), [7]
            anisotropy (no scatter correction, output)  
        * `xm[out]` :  
            array for corrected parameters (amplied range)  
        * `corrections` :  
            [1] g factor, [2] l1, [3] l3  
        * `return_r` :  
            if true computes the anisotropy.  

        Returns
        -------  

        """
        return _tttrlib.DecayFit24_correct_input(x, xm, corrections, return_r)

    @staticmethod
    def fit(*args):
        r"""
        fit(x, fixed, p) -> double

        Parameters
        ----------
        x: double *
        fixed: short *
        p: MParam *

        fit(x, fixed, p) -> double

        Parameters
        ----------
        x: double *
        fixed: short *
        p: MParam *

        """
        return _tttrlib.DecayFit24_fit(*args)

    @staticmethod
    def targetf(*args):
        r"""
        targetf(x, pv) -> double

        Parameters
        ----------
        x: double *
        pv: void *

        targetf(x, p) -> double

        Parameters
        ----------
        x: double *
        p: MParam *

        """
        return _tttrlib.DecayFit24_targetf(*args)

    @staticmethod
    def modelf(*args):
        r"""
        modelf(param, irf, bg, Nchannels, dt, corrections, mfunction) -> int

        Parameters
        ----------
        param: double *
        irf: double *
        bg: double *
        Nchannels: int
        dt: double
        corrections: double *
        mfunction: double *

        modelf(param, irf, bg, dt, corrections, mfunction) -> int

        Parameters
        ----------
        param: double *
        irf: double *
        bg: double *
        dt: double
        corrections: double *
        mfunction: double *

        """
        return _tttrlib.DecayFit24_modelf(*args)

    def __init__(self):
        r"""
        __init__(self) -> DecayFit24


        C++ includes: DecayFit24.h

        """
        _tttrlib.DecayFit24_swiginit(self, _tttrlib.new_DecayFit24())
    __swig_destroy__ = _tttrlib.delete_DecayFit24

# Register DecayFit24 in _tttrlib:
_tttrlib.DecayFit24_swigregister(DecayFit24)
class DecayFit25(object):
    r"""


    C++ includes: DecayFit25.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def correct_input(x, xm, corrections, return_r):
        r"""
        correct_input(x, xm, corrections, return_r)

        Parameters
        ----------
        x: double *
        xm: double *
        corrections: LVDoubleArray *
        return_r: int


        DecayFit25::correct_input
        adjust parameters for fit25 and compute anisotropy  

        Makes sure that (0 < gamma < 0.999) and (0<rho).  

        Parameters
        ----------
        * `x` :  
        * `xm` :  
        * `corrections` :  
        * `return_r` :  

        Returns
        -------  

        """
        return _tttrlib.DecayFit25_correct_input(x, xm, corrections, return_r)

    @staticmethod
    def targetf(*args):
        r"""
        targetf(x, pv) -> double

        Parameters
        ----------
        x: double *
        pv: void *

        targetf(x, p) -> double

        Parameters
        ----------
        x: double *
        p: MParam *

        """
        return _tttrlib.DecayFit25_targetf(*args)

    @staticmethod
    def fit(*args):
        r"""
        fit(x, fixed, p) -> double

        Parameters
        ----------
        x: double *
        fixed: short *
        p: MParam *

        fit(x, fixed, p) -> double

        Parameters
        ----------
        x: double *
        fixed: short *
        p: MParam *

        """
        return _tttrlib.DecayFit25_fit(*args)

    def __init__(self):
        r"""
        __init__(self) -> DecayFit25


        C++ includes: DecayFit25.h

        """
        _tttrlib.DecayFit25_swiginit(self, _tttrlib.new_DecayFit25())
    __swig_destroy__ = _tttrlib.delete_DecayFit25

# Register DecayFit25 in _tttrlib:
_tttrlib.DecayFit25_swigregister(DecayFit25)
class DecayFit26(object):
    r"""


    C++ includes: DecayFit26.h

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def correct_input(x, xm):
        r"""
        correct_input(x, xm)

        Parameters
        ----------
        x: double *
        xm: double *


        DecayFit26::correct_input
        Correct input for fit 26  

        Constrains the fraction x1 of the first pattern to (0 < x1 < 1).  

        Parameters
        ----------
        * `x[in]` :  
            x[0] fraction of first pattern  
        * `xm[out]` :  
            xm[0] corrected fraction of first pattern  

        """
        return _tttrlib.DecayFit26_correct_input(x, xm)

    @staticmethod
    def targetf(*args):
        r"""
        targetf(x, pv) -> double

        Parameters
        ----------
        x: double *
        pv: void *

        targetf(x, p) -> double

        Parameters
        ----------
        x: double *
        p: MParam *

        """
        return _tttrlib.DecayFit26_targetf(*args)

    @staticmethod
    def fit(*args):
        r"""
        fit(x, fixed, p) -> double

        Parameters
        ----------
        x: double *
        fixed: short *
        p: MParam *

        fit(x, fixed, p) -> double

        Parameters
        ----------
        x: double *
        fixed: short *
        p: MParam *

        """
        return _tttrlib.DecayFit26_fit(*args)

    def __init__(self):
        r"""
        __init__(self) -> DecayFit26


        C++ includes: DecayFit26.h

        """
        _tttrlib.DecayFit26_swiginit(self, _tttrlib.new_DecayFit26())
    __swig_destroy__ = _tttrlib.delete_DecayFit26

# Register DecayFit26 in _tttrlib:
_tttrlib.DecayFit26_swigregister(DecayFit26)

