{"version":3,"file":"shared-docprovider_lib_index_js.a13e7b0610907b7622b1.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACoD;AACS;AAClB;AACgB;AACjB;AACc;AACZ;AACd;AACI;AAClC,oCAAoC,6DAAU;AAC9C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe,GAAG,oBAAoB,GAAG,aAAa;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qDAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,2CAA2C,uBAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gCAAgC,qDAAM;AACtC;AACA,2BAA2B,2CAAM;AACjC,0BAA0B,8DAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yDAAM;AAClD;AACA,SAAS;AACT;AACA,uCAAuC,oDAAe;AACtD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,uCAAuC,oDAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sBAAsB,uCAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uCAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU,GAAG,IAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,sBAAsB,uCAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,MAAM,eAAe;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwB;AACG;;;;;;;;;;;;;;;ACT3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACgE;AACZ;AACT;AACkB;AAC7D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sEAAgB,8DAA8D,WAAW,yDAAyD,wDAAM;AACxK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAM;AACd;AACA;AACA,oCAAoC,oDAAe,IAAI,aAAa,GAAG,kBAAkB,GAAG,YAAY;AACxG;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACyB;AACK;AACvB;AACP;AACA,yBAAyB,oCAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uCAAI;AAC9B;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA,6CAA6C,KAAK,QAAQ,IAAI;AAC9D;AACA;AACA;AACA,6CAA6C,IAAI,GAAG,KAAK;AACzD;AACA;AACA,0CAA0C,KAAK,QAAQ,IAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,IAAI,EAAE,IAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uCAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uCAAI;AACxC,uBAAuB,uCAAI;AAC3B;AACA;AACA,oCAAoC,uCAAI;AACxC,uBAAuB,uCAAI;AAC3B;AACA;AACA,0BAA0B,uCAAI;AAC9B;AACA;AACA;AACA,oCAAoC,uCAAI;AACxC,0BAA0B,uCAAI;AAC9B;AACA;AACA,gBAAgB,uCAAI;AACpB;AACA;AACA,gBAAgB,uCAAI;AACpB;AACA;AACA,wCAAwC,uCAAI;AAC5C,sCAAsC,uCAAI;AAC1C,2CAA2C,uCAAI;AAC/C;AACA,yBAAyB,uCAAI;AAC7B;AACA","sources":["webpack://@jupyter/shared-docprovider-extension/../shared-docprovider/lib/drive.js","webpack://@jupyter/shared-docprovider-extension/../shared-docprovider/lib/index.js","webpack://@jupyter/shared-docprovider-extension/../shared-docprovider/lib/path.js","webpack://@jupyter/shared-docprovider-extension/../shared-docprovider/lib/provider.js","webpack://@jupyter/shared-docprovider-extension/../shared-docprovider/lib/ydrive.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { WebrtcProvider as YWebrtcProvider } from 'y-webrtc';\nimport { Signal } from '@lumino/signaling';\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { YNotebook } from '@jupyter/ydoc';\nimport { ServerConnection } from '@jupyterlab/services';\nimport { WebrtcProvider } from './provider';\nimport { Path } from './path';\nimport { YDrive } from './ydrive';\nconst signalingServers = JSON.parse(PageConfig.getOption('signalingServers'));\n/**\n * A collaborative implementation for an `IDrive`, talking to other peers using WebRTC.\n */\nexport class SharedDrive {\n    /**\n     * Construct a new drive object.\n     *\n     * @param user - The user manager to add the identity to the awareness of documents.\n     */\n    constructor(user, defaultFileBrowser, translator, globalAwareness, name) {\n        this._onSync = (synced) => {\n            var _a;\n            if (synced.synced) {\n                this._ready.resolve();\n                (_a = this._fileSystemProvider) === null || _a === void 0 ? void 0 : _a.off('synced', this._onSync);\n            }\n        };\n        this._onCreate = (options) => {\n            if (typeof options.format !== 'string') {\n                const factory = this.sharedModelFactory.documentFactories.get(options.contentType);\n                const sharedModel = factory(options);\n                return sharedModel;\n            }\n            // Check if file exists.\n            this._ydrive.get(options.path);\n            const key = `${options.format}:${options.contentType}:${options.path}`;\n            // Check if shared model alread exists.\n            const fileProvider = this._fileProviders.get(key);\n            if (fileProvider) {\n                return fileProvider.sharedModel;\n            }\n            const factory = this.sharedModelFactory.documentFactories.get(options.contentType);\n            const sharedModel = factory(options);\n            const provider = new WebrtcProvider({\n                url: '',\n                path: options.path,\n                format: options.format,\n                contentType: options.contentType,\n                model: sharedModel,\n                user: this._user,\n                translator: this._trans,\n                signalingServers: this._signalingServers\n            });\n            this._fileProviders.set(key, { provider, sharedModel });\n            sharedModel.disposed.connect(() => {\n                const fileProvider = this._fileProviders.get(key);\n                if (fileProvider) {\n                    fileProvider.provider.dispose();\n                    this._fileProviders.delete(key);\n                }\n            });\n            return sharedModel;\n        };\n        this._fileChanged = new Signal(this);\n        this._isDisposed = false;\n        this._ydrive = new YDrive();\n        this._ready = new PromiseDelegate();\n        this._signalingServers = [];\n        this._user = user;\n        this._defaultFileBrowser = defaultFileBrowser;\n        this._trans = translator;\n        this._globalAwareness = globalAwareness;\n        //this._username = this._globalAwareness?.getLocalState()?.user.identity.name;\n        //this._username = this._globalAwareness?.getLocalState()?.username;\n        this._fileProviders = new Map();\n        this.sharedModelFactory = new SharedModelFactory(this._onCreate);\n        this.serverSettings = ServerConnection.makeSettings();\n        signalingServers.forEach((url) => {\n            if (url.startsWith('ws://') ||\n                url.startsWith('wss://') ||\n                url.startsWith('http://') ||\n                url.startsWith('https://')) {\n                // It's an absolute URL, keep it as-is.\n                this._signalingServers.push(url);\n            }\n            else {\n                // It's a Jupyter server relative URL, build the absolute URL.\n                this._signalingServers.push(URLExt.join(this.serverSettings.wsUrl, url));\n            }\n        });\n        this.name = name;\n        this._fileSystemProvider = new YWebrtcProvider('fileSystem', this._ydrive.ydoc, {\n            signaling: this._signalingServers,\n            awareness: this._globalAwareness || undefined\n        });\n        this._fileSystemProvider.on('synced', this._onSync);\n    }\n    //get providers(): Map<string, WebrtcProvider> {\n    get providers() {\n        // FIXME\n        const providers = new Map();\n        for (const key in this._fileProviders) {\n            providers.set(key, this._fileProviders.get(key).provider);\n        }\n        return providers;\n    }\n    async getDownloadUrl(path) {\n        return '';\n    }\n    async delete(localPath) {\n        this._ydrive.delete(localPath);\n    }\n    async restoreCheckpoint(path, checkpointID) { }\n    async deleteCheckpoint(path, checkpointID) { }\n    async importFile(path) {\n        const model = await this._defaultFileBrowser.model.manager.services.contents.get(path, {\n            content: true\n        });\n        this._ydrive.createFile(model.name); // FIXME: create file in cwd?\n        const sharedModel = this.sharedModelFactory.createNew({\n            path: model.name,\n            format: model.format,\n            contentType: model.type,\n            collaborative: true\n        });\n        if (sharedModel) {\n            // FIXME: replace with sharedModel.source=model.content\n            // when https://github.com/jupyter-server/jupyter_ydoc/pull/273 is merged\n            if (sharedModel instanceof YNotebook) {\n                sharedModel.fromJSON(model.content);\n            }\n            else {\n                sharedModel.setSource(model.content);\n            }\n        }\n    }\n    async newUntitled(options = {}) {\n        var _a;\n        let ext = '';\n        let isDir = false;\n        if (options.type === 'directory') {\n            isDir = true;\n        }\n        else if (options.type === 'notebook') {\n            ext = '.ipynb';\n        }\n        else {\n            ext = '.txt';\n        }\n        const newPath = this._ydrive.newUntitled(isDir, options.path, ext);\n        const newName = new Path(newPath).name;\n        const model = {\n            name: newName,\n            path: newPath,\n            type: (_a = options.type) !== null && _a !== void 0 ? _a : 'file',\n            writable: true,\n            created: '',\n            last_modified: '',\n            mimetype: '',\n            content: null,\n            format: null\n        };\n        this._fileChanged.emit({\n            type: 'new',\n            oldValue: null,\n            newValue: model\n        });\n        return model;\n    }\n    async rename(path, newPath) {\n        this._ydrive.move(path, newPath);\n        const model = {\n            name: new Path(newPath).name,\n            path: newPath,\n            type: 'file',\n            writable: true,\n            created: '',\n            last_modified: '',\n            mimetype: '',\n            content: null,\n            format: null\n        };\n        return model;\n    }\n    async copy(path, toDir) {\n        throw new Error('Copy/paste not supported');\n    }\n    async createCheckpoint(path) {\n        return {\n            id: '',\n            last_modified: ''\n        };\n    }\n    async listCheckpoints(path) {\n        return [];\n    }\n    /**\n     * A signal emitted when a file operation takes place.\n     */\n    get fileChanged() {\n        return this._fileChanged;\n    }\n    /**\n     * Test whether the manager has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of the resources held by the manager.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._fileProviders.forEach(fp => fp.provider.dispose());\n        this._fileProviders.clear();\n        this._isDisposed = true;\n        Signal.clearData(this);\n    }\n    /**\n     * Get a file or directory.\n     *\n     * @param localPath: The path to the file.\n     *\n     * @param options: The options used to fetch the file.\n     *\n     * @returns A promise which resolves with the file content.\n     */\n    async get(localPath, options) {\n        let model;\n        await this._ready;\n        if (!this._ydrive.isDir(localPath)) {\n            // It's a file.\n            return {\n                name: new Path(localPath).name,\n                path: localPath,\n                type: 'file',\n                writable: true,\n                created: '',\n                last_modified: '',\n                mimetype: '',\n                content: null,\n                format: null\n            };\n        }\n        // It's a directory.\n        const content = [];\n        const dirContent = this._ydrive.get(localPath);\n        for (const [key, value] of dirContent) {\n            const isDir = value !== null;\n            const type = isDir ? 'directory' : 'file';\n            content.push({\n                name: key,\n                path: `${localPath}/${key}`,\n                type,\n                writable: true,\n                created: '',\n                last_modified: '',\n                mimetype: '',\n                content: null,\n                format: null\n            });\n        }\n        model = {\n            name: new Path(localPath).name,\n            path: localPath,\n            type: 'directory',\n            writable: true,\n            created: '',\n            last_modified: '',\n            mimetype: '',\n            content,\n            format: null\n        };\n        return model;\n    }\n    /**\n     * Save a file.\n     *\n     * @param localPath - The desired file path.\n     *\n     * @param options - Optional overrides to the model.\n     *\n     * @returns A promise which resolves with the file content model when the\n     *   file is saved.\n     */\n    async save(localPath, options = {}) {\n        const fetchOptions = {\n            type: options.type,\n            format: options.format,\n            content: false\n        };\n        return this.get(localPath, fetchOptions);\n    }\n}\n/**\n * Yjs sharedModel factory for real-time collaboration.\n */\nclass SharedModelFactory {\n    /**\n     * Shared model factory constructor\n     *\n     * @param _onCreate Callback on new document model creation\n     */\n    constructor(_onCreate) {\n        this._onCreate = _onCreate;\n        this.documentFactories = new Map();\n    }\n    /**\n     * Register a SharedDocumentFactory.\n     *\n     * @param type Document type\n     * @param factory Document factory\n     */\n    registerDocumentFactory(type, factory) {\n        if (this.documentFactories.has(type)) {\n            throw new Error(`The content type ${type} already exists`);\n        }\n        this.documentFactories.set(type, factory);\n    }\n    /**\n     * Create a new `ISharedDocument` instance.\n     *\n     * It should return `undefined` if the factory is not able to create a `ISharedDocument`.\n     */\n    createNew(options) {\n        if (typeof options.format !== 'string') {\n            console.warn(`Only defined format are supported; got ${options.format}.`);\n            return;\n        }\n        if (this.documentFactories.has(options.contentType)) {\n            const sharedModel = this._onCreate(options);\n            return sharedModel;\n        }\n        return;\n    }\n}\n","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module shared-docprovider\n */\nexport * from './drive';\nexport * from './provider';\n","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nexport class Path {\n    constructor(path) {\n        this._parts = path.split('/');\n        if (this._parts[this._parts.length - 1] === '') {\n            this._parts.pop();\n        }\n    }\n    get parts() {\n        return this._parts;\n    }\n    get parent() {\n        return this._parts.slice(0, this._parts.length - 1).join('/');\n    }\n    get name() {\n        return this._parts[this._parts.length - 1];\n    }\n}\n","/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nimport { showErrorMessage, Dialog } from '@jupyterlab/apputils';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { WebrtcProvider as YWebrtcProvider } from 'y-webrtc';\n/**\n * A class to provide Yjs synchronization over WebRTC.\n */\nexport class WebrtcProvider {\n    /**\n     * Construct a new WebrtcProvider\n     *\n     * @param options The instantiation options for a WebrtcProvider\n     */\n    constructor(options) {\n        this._onPeers = (event) => {\n            if (event.webrtcPeers.length === 0) {\n                showErrorMessage(this._trans.__('All clients disconnected'), `If you close '${this._path}', all data will be lost (unless someone reconnects).`, [Dialog.okButton()]);\n            }\n        };\n        this._onSync = (synced) => {\n            if (synced.synced) {\n                this._ready.resolve();\n                //this._yWebrtcProvider?.off('status', this._onSync);\n            }\n        };\n        this._ready = new PromiseDelegate();\n        this._isDisposed = false;\n        this._path = options.path;\n        this._contentType = options.contentType;\n        this._format = options.format;\n        this._sharedModel = options.model;\n        this._awareness = options.model.awareness;\n        this._yWebrtcProvider = null;\n        this._trans = options.translator;\n        this._signalingServers = options.signalingServers;\n        const user = options.user;\n        user.ready\n            .then(() => {\n            this._onUserChanged(user);\n        })\n            .catch(e => console.error(e));\n        user.userChanged.connect(this._onUserChanged, this);\n        this._connect().catch(e => console.warn(e));\n    }\n    /**\n     * Test whether the object has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * A promise that resolves when the document provider is ready.\n     */\n    get ready() {\n        return this._ready.promise;\n    }\n    /**\n     * Dispose of the resources held by the object.\n     */\n    dispose() {\n        var _a;\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        //this._yWebrtcProvider?.off('status', this._onSync);\n        (_a = this._yWebrtcProvider) === null || _a === void 0 ? void 0 : _a.destroy();\n        Signal.clearData(this);\n    }\n    async _connect() {\n        this._yWebrtcProvider = new YWebrtcProvider(`${this._format}:${this._contentType}:${this._path}}`, this._sharedModel.ydoc, {\n            signaling: this._signalingServers,\n            awareness: this._awareness\n        });\n        this._yWebrtcProvider.on('synced', this._onSync);\n        this._yWebrtcProvider.on('peers', this._onPeers);\n    }\n    _onUserChanged(user) {\n        this._awareness.setLocalStateField('user', user.identity);\n    }\n}\n","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nimport * as Y from 'yjs';\nimport { Path } from './path';\nexport class YDrive {\n    constructor() {\n        this._ydoc = new Y.Doc();\n        this._yroot = this._ydoc.getMap('root');\n    }\n    get ydoc() {\n        return this._ydoc;\n    }\n    _newDir() {\n        return new Y.Map();\n    }\n    isDir(path) {\n        return this.get(path) ? true : false;\n    }\n    get(path) {\n        if (path === '') {\n            return this._yroot;\n        }\n        let current = this._yroot;\n        const parts = new Path(path).parts;\n        let cwd = '';\n        const lastIdx = parts.length - 1;\n        for (let idx = 0; idx < parts.length; idx++) {\n            const part = parts[idx];\n            if (!current.has(part)) {\n                throw new Error(`No entry \"${part}\" in \"${cwd}\"`);\n            }\n            current = current.get(part);\n            if (current) {\n                cwd = cwd === '' ? part : `${cwd}/${part}`;\n            }\n            else if (idx < lastIdx) {\n                throw new Error(`Entry \"${part}\" in \"${cwd}\" is not a directory.`);\n            }\n        }\n        return current;\n    }\n    newUntitled(isDir, path, ext) {\n        path = path !== null && path !== void 0 ? path : '';\n        ext = ext !== null && ext !== void 0 ? ext : '';\n        let idx = 0;\n        let newName = '';\n        const parent = this.get(path);\n        const dir = parent.toJSON();\n        while (newName === '') {\n            const _newName = `shared${idx}${ext}`;\n            if (_newName in dir) {\n                idx += 1;\n            }\n            else {\n                newName = _newName;\n            }\n        }\n        const parts = new Path(path).parts;\n        parts.push(newName);\n        const newPath = parts.join('/');\n        if (isDir) {\n            this.createDirectory(newPath);\n        }\n        else {\n            this.createFile(newPath);\n        }\n        return newPath;\n    }\n    createFile(path) {\n        const parent = this.get(new Path(path).parent);\n        parent.set(new Path(path).name, null);\n    }\n    createDirectory(path) {\n        const parent = this.get(new Path(path).parent);\n        parent.set(new Path(path).name, this._newDir());\n    }\n    delete(path) {\n        const parts = new Path(path).parts;\n        if (parts.length === 0) {\n            throw new Error('Cannot delete root directory');\n        }\n        const parent = this.get(new Path(path).parent);\n        parent.delete(new Path(path).name);\n    }\n    move(fromPath, toPath) {\n        if (new Path(fromPath).parts.length === 0) {\n            throw new Error('Cannot move root directory');\n        }\n        if (new Path(toPath).parts.length === 0) {\n            throw new Error('Cannot move to root directory');\n        }\n        const fromParent = this.get(new Path(fromPath).parent);\n        const toParent = this.get(new Path(toPath).parent);\n        const content = fromParent.get(new Path(fromPath).name).clone();\n        this.delete(fromPath);\n        toParent.set(new Path(toPath).name, content);\n    }\n}\n"],"names":[],"sourceRoot":""}