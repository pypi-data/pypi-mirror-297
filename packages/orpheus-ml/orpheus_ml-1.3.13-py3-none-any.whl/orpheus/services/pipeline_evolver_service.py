"""
Evolverclass for applying stacked generalization on MultiEstimatorPipeline class.
Create a gen-3 metamodel from a gen-2 metamodel which was created through the ComponentService class.
"""

from copy import deepcopy
from typing import List, Optional, Tuple, Union

from sklearn.ensemble import (
    StackingClassifier,
    StackingRegressor,
    VotingClassifier,
    VotingRegressor,
)

from orpheus.services.additional_types.multi_estimator_pipeline import (
    MultiEstimatorPipeline,
)
from orpheus.utils.custom_estimators import (
    ClassifierWrapper,
    ClassifierWrapperWithPredictProba,
    PredictFuncWrapper,
    RegressorWrapper,
)
from orpheus.utils.type_vars import EstimatorType


class PipelineEvolverService:
    """
    Evolve a MultiEstimatorPipeline instance into a next-gen stacked or voting regressor/classifier.

    Public Methods
    --------------
    evolve_stacking
        Evolve the estimators in the MultiEstimatorPipeline into a stacking regressor/classifier.
        Afterwards, return the evolved MultiEstimatorPipeline.

    evolve_voting
        evolve the MultiEstimatorPipeline into a stacked or voting regressor/classifier
    """

    def __init__(self, pipeline: MultiEstimatorPipeline) -> None:
        """
        Initialize the PipelineEvolverService class.

        Parameters
        ----------
        pipeline : MultiEstimatorPipeline
            A trained MultiEstimatorPipeline instance, generated by the ComponentService class.
        """
        if not isinstance(pipeline, MultiEstimatorPipeline):
            raise ValueError(
                "pipeline should be of type MultiEstimatorPipeline, generated by the ComponentService class!"
            )

        pipeline._check_if_estimator_wrapper_is_set()

        if pipeline.type_estimator is None:
            raise ValueError(
                "type of estimator is not set. Set the type of estimator in the pipeline to either 'classifier' or 'regressor'."
            )

        self.pipeline = pipeline
        estimator_weights = list(zip(self.pipeline.estimators, self.pipeline.get_weights()))
        valid_estimators_for_final_estimator = [
            (est, w) for est, w in estimator_weights if not isinstance(est, PredictFuncWrapper)
        ]
        if not valid_estimators_for_final_estimator:
            raise ValueError("Pipeline contains no valid estimators")

        self.final_estimator_without_predict_proba = max(valid_estimators_for_final_estimator, key=lambda x: x[1])[0]

    def __repr__(self) -> str:
        return f"PipelineEvolverService({self.pipeline})"

    def evolve_stacking(
        self,
        final_estimator: Optional[EstimatorType] = None,
        *,
        cv=None,
        n_jobs=None,
        passthrough=False,
        verbose=0,
    ) -> MultiEstimatorPipeline:
        """
        Evolve the estimators in the MultiEstimatorPipeline into a stacking regressor/classifier.
        Afterwards, return the evolved MultiEstimatorPipeline.

        Parameters
        ----------
        final_estimator : estimator object, default=None
            A regressor or classifier which will be used to combine the base estimators.
            If None, the best stacked/voting estimator in the pipeline is used as final estimator.
        """
        if self.pipeline.type_estimator == "regressor":
            estimator = self._evolve_stacking_regressor(
                final_estimator=self.final_estimator_without_predict_proba
                if final_estimator is None
                else final_estimator,
                cv=cv,
                n_jobs=n_jobs,
                passthrough=passthrough,
                verbose=verbose,
            )
        elif self.pipeline.type_estimator == "classifier":
            estimator = self._evolve_stacking_classifier(
                self.final_estimator_without_predict_proba if final_estimator is None else final_estimator,
                cv=cv,
                n_jobs=n_jobs,
                passthrough=passthrough,
                verbose=verbose,
            )
        pipe_copy = deepcopy(self.pipeline)
        pipe_copy.estimators = estimator

        pipe_copy.generation = "evolved"

        return pipe_copy

    def evolve_voting(
        self,
        voting: str = "hard",
        n_jobs: Optional[int] = None,
        verbose: bool = False,
        weights=None,
    ) -> MultiEstimatorPipeline:
        """
        evolve the MultiEstimatorPipeline into a stacked or voting regressor/classifier

        Parameters
        ----------
        voting : str, default='hard'
            This parameter only applies if the MultiEstimatorPipeline contains classifiers.
            If 'hard', uses predicted class labels for majority rule voting.
            if 'soft', predicts the class label based on the argmax of the sums of the predicted probabilities.

        n_jobs : int, default=None
            The number of jobs to run in parallel.

        verbose: bool, default=False
            If True, the time elapsed while fitting will be printed as it is completed.

        weights : array-like of shape (n_classifiers,), default=None
        Sequence of weights (`float` or `int`) to weight the occurrences of
        predicted class labels (`hard` voting) or class probabilities
        before averaging (`soft` voting). Uses uniform weights if `None`.
        """
        if self.pipeline.type_estimator == "regressor":
            estimator = self._evolve_voting_regressor(weights=weights, n_jobs=n_jobs, verbose=verbose)
        elif self.pipeline.type_estimator == "classifier":
            estimator = self._evolve_voting_classifier(voting=voting, weights=weights, n_jobs=n_jobs, verbose=verbose)

        pipe_copy = deepcopy(self.pipeline)
        pipe_copy.estimators = estimator

        pipe_copy.generation = "evolved"

        return pipe_copy

    def _evolve_stacking_regressor(self, final_estimator, **kwargs):
        """evolve the pipeline into a stacked regressor"""
        estimators = self._get_stacked_compatible_estimators()
        return StackingRegressor(estimators=estimators, final_estimator=final_estimator, **kwargs)

    def _evolve_stacking_classifier(self, final_estimator, **kwargs):
        """
        Evolve the estimators in the pipeline into a stacked regressor/classifier.
        Afterwards, return the evolved pipeline.

        """
        estimators = self._get_stacked_compatible_estimators()
        return StackingClassifier(
            estimators=estimators,
            final_estimator=self.final_estimator_without_predict_proba if final_estimator is None else final_estimator,
            **kwargs,
        )

    def _evolve_voting_classifier(self, voting, **kwargs):
        """evolve the pipeline into a voting classifier"""
        estimators = self._get_stacked_compatible_estimators()
        if voting == "soft":
            # also possible: if hasattr(est, "predict_proba"). But this is more explicit.
            estimators_with_predict_proba = [
                (name, estimator)
                for name, estimator in estimators
                if isinstance(estimator, ClassifierWrapperWithPredictProba)
            ]
            if not estimators_with_predict_proba:
                raise ValueError(
                    f"No estimatorwrapper called 'ClassifierWrapperWithPredictProba' found in the pipeline, meaning no estimators where found with 'predict_proba' functionality. Estimatorwrappers: {', '.join(str(est[1]) for est in estimators)}"
                )
            estimators = estimators_with_predict_proba
        return VotingClassifier(estimators=estimators, voting=voting, **kwargs)

    def _evolve_voting_regressor(self, **kwargs):
        """evolve the pipeline into a voting regressor"""
        estimators = self._get_stacked_compatible_estimators()
        return VotingRegressor(estimators=estimators, **kwargs)

    def _get_stacked_compatible_estimators(
        self,
    ) -> Union[List[EstimatorType], List[Tuple[Union[str, Union[RegressorWrapper, ClassifierWrapper]]]]]:
        """
        Get all estimators from the pipeline attribute.
        They will be wrapped in a special RegressorWrapper or ClassifierWrapper class,
        making them compatible with Voting/Stacked Regressor/Classifier from sklearn.ensemble.
        For more info, see: https://scikit-learn.org/stable/modules/ensemble.html#w1992
        """
        estimators = []
        for idx, estimator in enumerate(self.pipeline.estimators):
            if isinstance(estimator, PredictFuncWrapper):
                continue
            name = str(idx)
            if self.pipeline.type_estimator == "regressor":
                estimator_wrapper = RegressorWrapper
            elif self.pipeline.type_estimator == "classifier":
                if hasattr(estimator, "predict_proba"):
                    estimator_wrapper = ClassifierWrapperWithPredictProba
                else:
                    estimator_wrapper = ClassifierWrapper

            wrapped_estimator = estimator_wrapper(estimator)
            estimators.append((name, wrapped_estimator))

        return estimators
