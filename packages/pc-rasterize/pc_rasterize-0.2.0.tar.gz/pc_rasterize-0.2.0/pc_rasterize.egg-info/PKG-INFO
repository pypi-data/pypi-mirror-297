Metadata-Version: 2.1
Name: pc_rasterize
Version: 0.2.0
Summary: Rasterize point cloud data in parallel
Author-email: Fred Bunt <fredrick.bunt@umt.edu>
License: MIT License
Project-URL: homepage, https://github.com/UM-RMRS/pc-rasterize
Project-URL: issue-tracker, https://github.com/UM-RMRS/pc-rasterize/issues
Keywords: point,cloud,raster,spatial
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 3
Classifier: Topic :: Scientific/Engineering :: GIS
Requires-Python: >=3.10
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: dask
Requires-Dist: geopandas
Requires-Dist: numba
Requires-Dist: numpy
Requires-Dist: odc-geo
Requires-Dist: pandas
Requires-Dist: pdal
Requires-Dist: python-pdal
Requires-Dist: rasterio
Requires-Dist: rioxarray
Requires-Dist: shapely>=2
Requires-Dist: xarray

# PC Rasterize: Rasterize Point Clouds in Parallel
---

## How to use:

```python
import pc_rasterize as pcr
import glob

files = sorted(glob.glob("../data/points/*.laz"))
# Create a GeoBox grid specification with a 100m buffer around data
geobox = pcr.build_geobox(files, resolution=0.50, crs="5070", buffer=100)
# Build a lazy CHM raster
chm = pcr.rasterize(
    files,
    geobox,
    cell_func="max",
    # Set custom dask chunk-size
    chunksize=(500, 500),
    nodata=np.nan,
    # Filter out points over 100m
    pdal_filters=[
        {
            "type": "filters.expression",
            "expression": "Z < 100"
        }
    ],
)
```

### Saving with default dask scheduling:

```python
# Use rioxarray to save to disk
chm.rio.to_raster("points_chm.tiff", tiled=True)
```

### Saving with dask's more advanced scheduling:
Dask's more advanced 'distributed' scheduling also provides a dashboard at
[http://localhost:8787/status](http://localhost:8787/status) for viewing
progress in your browser.

```python
from dask.distributed import Client, LocalCluster, Lock

with LocalCluster() as cluster, Client(cluster) as client:
    chm.rio.to_raster("points_chm.tiff", tiled=True, lock=Lock("rio"))
```
