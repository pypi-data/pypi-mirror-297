function getDefaultHeaders(){
  let state = App.getState();
  // var token = sessionStorage.getItem('token');
  token = state.get('token');
  if (token == null) {
    throw 'token expired';
  }
  var headers = [
      ['accept', 'application/json', false],
      ['Authorization', 'Bearer ' + token, false]
  ];
  return headers;
}

function decodeToText(data) {
  var utfDecoder = new TextDecoder('utf-8');
  supported = [
      'ArrayBuffer'.toLowerCase(),
      'ArrayBufferView'.toLowerCase(),
      'Uint8Array'.toLowerCase(),
  ]
  var deepType = Object.prototype.toString.call(data).slice(8,-1).toLowerCase();
  if (supported.includes(deepType)) {
    var text = utfDecoder.decode(data);  
  } else {
    var text = data;
  }
  return text;
}

async function readAllChunks(readableStream, func, doneFunc) {
  const reader = readableStream.getReader();
// Safari does not support TextDecoderStream so we call decodeToText after reading stream
//  const reader = readableStream.pipeThrough(new TextDecoderStream()).getReader();
  let done, value;
    
  while (!done) {
    ({ value, done } = await reader.read());
    var string = decodeToText(value);     
    if (done && doneFunc != undefined) {
      doneFunc(string);
    }
    func(string);
  }
}

async function requestAsync(asyncUrl, method, params=[], data=[], headers=[], json=false) {
  let state = App.getState();
  var urlParams = asyncUrl;
  params.forEach(function(p, index) {
    if (index == 0) {
        urlParams += '?' + p[0] + '=' + p[1];
    } else {
        urlParams += '&' + p[0] + '=' + p[1];        
    }
  });

  var formData = null;
  var contentType = null;
  if (json) {
    formData = JSON.stringify(data);
    contentType = 'application/json;charset=UTF-8';
  } else if (data.length > 0) {
    contentType = 'application/x-www-form-urlencoded';      
    formData = new FormData();
    data.forEach(function(obj, index){
      formData.append(obj[0], obj[1]);
    });
  }
    
  var myHeaders = {
      'Content-Type': contentType,
  };
  if (headers.length == 0) {
    try {
      headers = getDefaultHeaders();
    } catch (e) {
      if (e == 'token expired') {
          // sessionStorage.removeItem("token");
          state.deleteCookie('token');
      } else {
        showAlert('Something went wrong!')
      }
    }
  }
  headers.forEach(function(h, index){
      myHeaders[h[0]] = h[1];
  });
    
  // Default options are marked with *
  const response = await fetch(urlParams, {
    method: method, // *GET, POST, PUT, DELETE, etc.
    // mode: 'cors', // no-cors, *cors, same-origin
    // cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
    // credentials: 'same-origin', // include, *same-origin, omit
    headers: myHeaders,
    // redirect: 'follow', // manual, *follow, error
    // referrerPolicy: 'no-referrer', // no-referrer, *no-referrer-when-downgrade, origin, origin-when-cross-origin, same-origin, strict-origin, strict-origin-when-cross-origin, unsafe-url
    // body: JSON.stringify(data) // body data type must match "Content-Type" header
    body: formData
  });
  // appendCommandLogArea('\n########');
  return response;
}

function request(url, method, params=[], data=[], headers=[], json=false, isAsync=false, onprogress=null, onloadend=null) {
    let state = App.getState();
    var fullUrl = url;
    if (!url.startsWith('http')) {
        if (url.startsWith('/')) {
            fullUrl = document.location.origin + url;
        } else {
            fullUrl = document.location.origin + '/' + url;
        }
    }
    if (moment().utc().unix() - state.get('lastTokenCheck') > 300) {
        App.updateProfile();
    }
    if (isAsync) {
        return requestAsync(fullUrl, method, params, data, headers, json);
    }
    // adopted from https://web.dev/promises/#promisifying-xmlhttprequest
    // Return a new promise.
    return new Promise(function(resolve, reject) {
        // Do the usual XHR stuff
        var req = new XMLHttpRequest();
        var urlParams = fullUrl;
        params.forEach(function(p, index) {
        if (index == 0) {
            urlParams += '?' + p[0] + '=' + p[1];
        } else {
            urlParams += '&' + p[0] + '=' + p[1];        
        }
        });
        req.open(method, urlParams);
        if (headers.length == 0) {
            try {
                headers = getDefaultHeaders();
            } catch (e) {
                if (e == 'token expired') {
                    // sessionStorage.removeItem("token");
                    state.deleteCookie('token');
                } else {
                    showAlert('Something went wrong!')
                }
            }
        }
        headers.forEach(function(h, index) {
            req.setRequestHeader(h[0], h[1]);
        });
        if (json) {
            req.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');
        } else if (false) {
            req.setRequestHeader('Content-Type', 'multipart/form-data');
        }
        if (onprogress != null) {
            req.upload.onprogress = onprogress;
            // req.addEventListener('progress', onprogress);        
        }
        if (onloadend != null) {
            req.upload.onloadend = onloadend;
        }
        req.onload = function() {
            // This is called even on 404 etc
            // so check the status
            if (req.status < 400) {
                // Resolve the promise with the response text
                var res = JSON.parse(req.response);
                if (res && res.command != undefined) {
                  appendCommandLogArea('\n########\n' + res.command + '\n');
                    delete res.command;
                    appendCommandLogArea(JSON.stringify(res) + '\n');
                }
                resolve(res);
            } else {
                if (req.status == 503) { // maintenance mode
                    window.location.href = '/';
                }
                // Otherwise reject with the status text
                // which will hopefully be a meaningful error
                reject({status: req.status, response: req.response});
            }
        };
        // Handle network errors
        req.onerror = function() {
            reject(Error("Network Error"));
        };

        var formData = null;
        if (json) {
            formData = JSON.stringify(data);  
        } else if (data != undefined && data.length > 0) {
            // https://developer.mozilla.org/en-US/docs/Web/API/FormData/Using_FormData_Objects#sending_files_using_a_formdata_object
            // req.setRequestHeader('Content-Type', 'multipart/form-data');
            formData = new FormData();
            data.forEach(function(obj, index){
            formData.append(obj[0], obj[1]);
            });
        }
        // Make the request
        req.send(formData);
    });
}

function post(url, data=[], headers=[], json=false, async=false, onprogress=null, onloadend=null) {
  return request(url, 'POST', [], data, headers, json, async, onprogress, onloadend);
}

function get(url, params=[], headers=[], async=false) {
  return request(url, 'GET', params, [], headers, false, async);
}

function put(url, data=[], headers=[], json=false, async=false,  onprogress=null, onloadend=null) {
  return request(url, 'PUT', [], data, headers, json, async, onprogress, onloadend);
}

function delete_(url, data=[], headers=[], json=false, async=false) {
  return request(url, 'DELETE', [], data, headers, json, async);
}

function sendForm(form, headers=[], onprogress=null) {
  return new Promise(function(resolve, reject) {
    // Do the usual XHR stuff
    var req = new XMLHttpRequest();
    if (onprogress != null) {
      req.upload.onprogress = onprogress;
      // req.addEventListener('progress', onprogress);        
    }
    /*
    if (onloadend != null) {
      req.upload.onloadend = onloadend;
    }
    if (onerror != null) {
      req.upload.onerror = onerror;
    }
    */
    req.onload = function() {
        // This is called even on 404 etc
        // so check the status
        if (req.status < 400) {
            // Resolve the promise with the response text
            resolve(req.response);
        } else {
            // Otherwise reject with the status text
            // which will hopefully be a meaningful error
            reject(Error(req.response));
        }
    };
    // Handle network errors
    req.onerror = function() {
        reject(Error("Network Error"));
    };
    req.open(form.method, form.getAttribute("action"));
    headers.forEach(function(h, index) {
      req.setRequestHeader(h[0], h[1]);
    });            
    req.send(new FormData(form));
  });
}
