from datetime import datetime
from queue import Queue
from abc import ABCMeta, abstractmethod
from bbstrader.btengine.event import FillEvent, OrderEvent
from bbstrader.metatrader.account import Account

__all__ = [
    "ExecutionHandler",
    "SimulatedExecutionHandler",
    "MT5ExecutionHandler"
]


class ExecutionHandler(metaclass=ABCMeta):
    """
    The ExecutionHandler abstract class handles the interaction
    between a set of order objects generated by a Portfolio and
    the ultimate set of Fill objects that actually occur in the
    market.

    The handlers can be used to subclass simulated brokerages
    or live brokerages, with identical interfaces. This allows
    strategies to be backtested in a very similar manner to the
    live trading engine.

    The ExecutionHandler described here is exceedingly simple, 
    since it fills all orders at the current market price. 
    This is highly unrealistic, but serves as a good baseline for improvement.
    """

    @abstractmethod
    def execute_order(self, event: OrderEvent):
        """
        Takes an Order event and executes it, producing
        a Fill event that gets placed onto the Events queue.

        Args:
            event (OrderEvent): Contains an Event object with order information.
        """
        raise NotImplementedError(
            "Should implement execute_order()"
        )


class SimulatedExecutionHandler(ExecutionHandler):
    """
    The simulated execution handler simply converts all order
    objects into their equivalent fill objects automatically
    without latency, slippage or fill-ratio issues.

    This allows a straightforward "first go" test of any strategy,
    before implementation with a more sophisticated execution
    handler.
    """

    def __init__(self, events: Queue, **kwargs):
        """
        Initialises the handler, setting the event queues
        up internally.

        Args:
            events (Queue): The Queue of Event objects.
        """
        self.events = events

    def execute_order(self, event: OrderEvent):
        """
        Simply converts Order objects into Fill objects naively,
        i.e. without any latency, slippage or fill ratio problems.

        Args:
            event (OrderEvent): Contains an Event object with order information.
        """
        if event.type == 'ORDER':
            fill_event = FillEvent(
                datetime.now(), event.symbol,
                'ARCA', event.quantity, event.direction, None
            )
            self.events.put(fill_event)


class MT5ExecutionHandler(ExecutionHandler):
    def __init__(self, events: Queue, **kwargs):
        """
        """
        self.events = events
        self.account = Account()

    def _estimate_total_fees(self, symbol, lot):
        # TODO: Implement the calculation of fees based on the broker's fees
        # https://www.metatrader5.com/en/terminal/help/trading/market_watch
        # Calculate fees based on the broker's fees , swap and commission
        return 0.0

    def _calculate_lot(self, symbol, quantity, price):
        FX = self.account.get_symbol_type(symbol) == 'FX'
        COMD = self.account.get_symbol_type(symbol) == 'COMD'
        FUT = self.account.get_symbol_type(symbol) == 'FUT'
        CRYPTO = self.account.get_symbol_type(symbol) == 'CRYPTO'
        symbol_info = self.account.get_symbol_info(symbol)
        contract_size = symbol_info.trade_contract_size

        lot = (quantity*price) / (contract_size * price)
        if contract_size == 1:
            lot = quantity
        if COMD or FUT or CRYPTO and contract_size > 1:
            lot = quantity  / contract_size
        if FX:
            lot = (quantity*price / contract_size)
        return self._check_lot(symbol, lot)

    def _check_lot(self, symbol, lot):
        symbol_info =  self.account.get_symbol_info(symbol)
        if lot < symbol_info.volume_min:
            return symbol_info.volume_min
        elif lot > symbol_info.volume_max:
            return symbol_info.volume_max
        return round(lot, 2)
    
    def execute_order(self, event: OrderEvent):
        """
        Executes an Order event by converting it into a Fill event.

        Args:
            event (OrderEvent): Contains an Event object with order information.
        """
        if event.type == 'ORDER':
            symbol = event.symbol
            direction = event.direction
            quantity = event.quantity
            price = event.price
            lot = self._calculate_lot(symbol, quantity, price)
            fees = self._estimate_total_fees(symbol, lot)
            fill_event = FillEvent(
                timeindex=datetime.now(), symbol=symbol,
                exchange='MT5', quantity=quantity, direction=direction,
                fill_cost=None, commission=fees
            )
            self.events.put(fill_event)


class IBExecutionHandler(ExecutionHandler):
    ...