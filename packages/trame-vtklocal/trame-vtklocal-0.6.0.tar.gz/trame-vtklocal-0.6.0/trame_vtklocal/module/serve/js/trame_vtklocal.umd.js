(function(g,l){typeof exports=="object"&&typeof module<"u"?l(exports,require("vue")):typeof define=="function"&&define.amd?define(["exports","vue"],l):(g=typeof globalThis<"u"?globalThis:g||self,l(g.trame_vtklocal={},g.Vue))})(this,function(g,l){"use strict";const p=[];function O(i){return new Promise(function(e,t){if(p.indexOf(i)===-1){p.push(i);var a=document.createElement("script");a.type="module",a.src=i,a.onload=e,a.onerror=t,document.body.appendChild(a)}else e(!1)})}class j{constructor(){this.updateInProgress=0,this.loaded=!1,this.currentMTime=1,this.stateMTimes={},this.hashesMTime={},this.pendingArrays={},this.networkFetchState=null,this.networkFetchHash=null,this.networkFetchStatus=null,this.cameraIds=new Set,this.stateCache={}}async load(e,t){if(this.loaded)return;const a=`${e}/vtkWasmSceneManager.mjs`;await O(a);const n=`${e}/vtkWasmSceneManager.wasm`,o={canvas:t,locateFile(){return n},print(){console.info(Array.prototype.slice.call(arguments).join(" "))},printErr(){console.error(Array.prototype.slice.call(arguments).join(" "))}},c=await window.createVTKWasmSceneManager(o);c.initialize(),this.loaded=!0,this.sceneManager=c}bindNetwork(e,t,a){this.networkFetchState=e,this.networkFetchHash=t,this.networkFetchStatus=a}freeMemory(e=0){const t=this.sceneManager.getTotalBlobMemoryUsage(),a=Number(e);if(t>a){const n={};let o=this.currentMTime;for(Object.entries(this.hashesMTime).forEach(([c,h])=>{h<o&&(o=h);const d=h.toString();n[d]?n[d].push(c):n[d]=[c]});this.sceneManager.getTotalBlobMemoryUsage()>a;){const c=n[o];if(c)for(let h=0;h<c.length;h++)this.sceneManager.unRegisterBlob(c[h]),delete this.hashesMTime[c[h]];o++}}}async fetchState(e){const t=await this.networkFetchState(e);return this.pushState(t),t}pushState(e){if(e.length>0){const t=JSON.parse(e),{Id:a,MTime:n}=t;this.stateMTimes[a]=n,this.sceneManager.registerState(e)}}async fetchHash(e){if(this.pendingArrays[e]){await this.pendingArrays[e],this.hashesMTime[e]=this.currentMTime,delete this.pendingArrays[e];return}const t=await this.networkFetchHash(e);return this.sceneManager.registerBlob(e,t),this.hashesMTime[e]=this.currentMTime,t}pushHash(e,t){return this.pendingArrays[e]=new Promise(a=>{t.arrayBuffer?t.arrayBuffer().then(n=>{this.sceneManager.registerBlob(e,new Uint8Array(n)),this.hashesMTime[e]=this.currentMTime,a()}):(this.sceneManager.registerBlob(e,t),this.hashesMTime[e]=this.currentMTime,a())}),this.pendingArrays[e]}async update(e){if(this.updateInProgress++,this.updateInProgress===1)try{const t=await this.networkFetchStatus(e),a=[];t.ids.forEach(([n,o])=>{(!this.stateMTimes[n]||this.stateMTimes[n]<o)&&a.push(this.fetchState(n))}),t.hashes.forEach(n=>{this.hashesMTime[n]||a.push(this.fetchHash(n)),this.hashesMTime[n]=this.currentMTime}),t.cameras.forEach(n=>Number(this.cameraIds.add(n))),t.ignore_ids.forEach(n=>this.sceneManager.unRegisterState(n)),await Promise.all(a),await Promise.all(Object.values(this.pendingArrays)),this.currentMTime++;try{this.sceneManager.updateObjectsFromStates()}catch(n){console.error("WASM update failed"),console.log(n)}}catch(t){console.error("Error in update",t)}finally{this.updateInProgress--,this.updateInProgress&&(this.updateInProgress=0,await this.update())}}getState(e,t=!1){const a=Number(e);return t&&this.stateCache[a]?this.stateCache[a]:(this.sceneManager.updateStateFromObject(a),this.sceneManager.getState(a))}clearStateCache(){this.stateCache={}}getStateValue(e,t=!1){const a=Array.isArray(e)?e:[e];let n=null;for(let o=0;o<a.length;o++){const c=a[o];o===0?n=this.getState(c,t):(n=n[c],n.Id&&(n=this.getState(n.Id,t)))}return n}}function b(i,e,t){return function(){e.clearStateCache();for(const[a,n]of Object.entries(t)){const o={};for(const[c,h]of Object.entries(n))o[c]=e.getStateValue(h,!0);i.state.set(a,o)}e.clearStateCache()}}const S={VtkLocal:{emits:["updated","memory-vtk","memory-arrays","camera"],props:{renderWindow:{type:Number},eagerSync:{type:Boolean,default:!1},cacheSize:{type:Number,default:1e8},wsClient:{type:Object},listeners:{type:Object}},setup(i,{emit:e}){const t=l.inject("trame"),a=t.state.get("__trame_vtklocal_wasm_url"),n=[],o=[],c=l.ref(null),h=l.ref(null),d=i.wsClient||(t==null?void 0:t.client),C=l.toRef(i,"listeners"),r=new j;let m=null;async function E(s){return await d.getConnection().getSession().call("vtklocal.get.state",[s])}async function F(s){const f=await d.getConnection().getSession().call("vtklocal.get.hash",[s]);return f.arrayBuffer?new Uint8Array(await f.arrayBuffer()):f}async function W(s){return await d.getConnection().getSession().call("vtklocal.get.status",[s])}function I([s]){s.type==="state"&&r.pushState(s.content),s.type==="blob"&&r.pushHash(s.hash,s.content)}async function B(){const s=d.getConnection().getSession();m=s.subscribe("vtklocal.subscriptions",I),await s.call("vtklocal.subscribe.update",[i.renderWindow,1])}async function P(){const s=d.getConnection().getSession();m&&(s.unsubscribe(m),m=null),await s.call("vtklocal.subscribe.update",[i.renderWindow,-1])}function v(){const{width:s,height:u}=c.value.getBoundingClientRect(),f=Math.floor(s*window.devicePixelRatio+.5),y=Math.floor(u*window.devicePixelRatio+.5),w=l.unref(h);w&&r.loaded&&i.renderWindow&&(w.width=f,w.height=y,r.sceneManager.setSize(i.renderWindow,f,y),r.sceneManager.render(i.renderWindow))}let M=new ResizeObserver(v);function x(){r.freeMemory(i.cacheSize),e("memory-vtk",r.sceneManager.getTotalVTKDataObjectMemoryUsage()),e("memory-arrays",r.sceneManager.getTotalBlobMemoryUsage())}async function T(){r.loaded&&(await r.update(i.renderWindow),r.sceneManager.render(i.renderWindow),v(),e("updated"),x())}function N(s){r.sceneManager.resetCamera(s),r.sceneManager.render(i.renderWindow)}l.onMounted(async()=>{r.bindNetwork(E,F,W),await r.load(a,l.unref(h)),i.eagerSync&&B(),await T(),r.cameraIds.forEach(s=>{n.push([s,r.sceneManager.addObserver(s,"ModifiedEvent",()=>{e("camera",r.getState(s))})])}),l.watchEffect(()=>{for(;o.length;){const[s,u]=o.pop();r.sceneManager.removeObserver(s,u)}for(const[s,u]of Object.entries(C.value||{})){const f=Number(s);for(const[y,w]of Object.entries(u||{})){const k=b(t,r,w);o.push([f,r.sceneManager.addObserver(f,y,k)]),k()}}}),r.sceneManager.startEventLoop(i.renderWindow),M&&M.observe(l.unref(c))}),l.onBeforeUnmount(()=>{for(m&&P();n.length;){const[s,u]=n.pop();r.sceneManager.removeObserver(s,u)}for(;o.length;){const[s,u]=o.pop();r.sceneManager.removeObserver(s,u)}r.sceneManager.stopEventLoop(i.renderWindow),M&&(M.disconnect(),M=null)});function R(s){b(t,r,s)()}return{container:c,canvas:h,update:T,resetCamera:N,evalStateExtract:R}},template:`
        <div ref="container" style="position: relative; width: 100%; height: 100%;">
          <canvas 
            id="canvas"
            ref="canvas" 
            style="position: absolute; left: 0; top: 0; width: 100%; height: 100%;" 
            tabindex="0"
            
            @contextmenu.prevent
            @click="canvas.focus()"
            @mouseenter="canvas.focus()"
          />
        </div>`}};function A(i){Object.keys(S).forEach(e=>{i.component(e,S[e])})}g.install=A,Object.defineProperty(g,Symbol.toStringTag,{value:"Module"})});
