"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import date
from enum import Enum
import httpx
from plex_api_client.types import BaseModel
from plex_api_client.utils import FieldMetadata, PathParamMetadata, QueryParamMetadata
import pydantic
from typing import List, Optional, TypedDict, Union
from typing_extensions import Annotated, NotRequired


class Tag(str, Enum):
    r"""A key representing a specific tag within the section."""

    ALL = "all"
    UNWATCHED = "unwatched"
    NEWEST = "newest"
    RECENTLY_ADDED = "recentlyAdded"
    RECENTLY_VIEWED = "recentlyViewed"
    ON_DECK = "onDeck"
    COLLECTION = "collection"
    EDITION = "edition"
    GENRE = "genre"
    YEAR = "year"
    DECADE = "decade"
    DIRECTOR = "director"
    ACTOR = "actor"
    COUNTRY = "country"
    CONTENT_RATING = "contentRating"
    RATING = "rating"
    RESOLUTION = "resolution"
    FIRST_CHARACTER = "firstCharacter"
    FOLDER = "folder"


class IncludeGuids(int, Enum):
    r"""Adds the Guids object to the response"""

    DISABLE = 0
    ENABLE = 1


class IncludeMeta(int, Enum):
    r"""Adds the Meta object to the response"""

    DISABLE = 0
    ENABLE = 1


class Type(int, Enum):
    r"""The type of media to retrieve.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """

    MOVIE = 1
    TV_SHOW = 2
    SEASON = 3
    EPISODE = 4


class GetLibraryItemsRequestTypedDict(TypedDict):
    section_key: int
    r"""The unique key of the Plex library.
    Note: This is unique in the context of the Plex server.

    """
    tag: Tag
    r"""A key representing a specific tag within the section."""
    include_guids: NotRequired[IncludeGuids]
    r"""Adds the Guids object to the response

    """
    include_meta: NotRequired[IncludeMeta]
    r"""Adds the Meta object to the response

    """
    type: NotRequired[Type]
    r"""The type of media to retrieve.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """
    x_plex_container_start: NotRequired[int]
    r"""The index of the first item to return. If not specified, the first item will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 0

    """
    x_plex_container_size: NotRequired[int]
    r"""The number of items to return. If not specified, all items will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 50

    """


class GetLibraryItemsRequest(BaseModel):
    section_key: Annotated[
        int,
        pydantic.Field(alias="sectionKey"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]
    r"""The unique key of the Plex library.
    Note: This is unique in the context of the Plex server.

    """

    tag: Annotated[
        Tag, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""A key representing a specific tag within the section."""

    include_guids: Annotated[
        Optional[IncludeGuids],
        pydantic.Field(alias="includeGuids"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = IncludeGuids.DISABLE
    r"""Adds the Guids object to the response

    """

    include_meta: Annotated[
        Optional[IncludeMeta],
        pydantic.Field(alias="includeMeta"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = IncludeMeta.DISABLE
    r"""Adds the Meta object to the response

    """

    type: Annotated[
        Optional[Type],
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = None
    r"""The type of media to retrieve.
    1 = movie
    2 = show
    3 = season
    4 = episode
    E.g. A movie library will not return anything with type 3 as there are no seasons for movie libraries

    """

    x_plex_container_start: Annotated[
        Optional[int],
        pydantic.Field(alias="X-Plex-Container-Start"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 0
    r"""The index of the first item to return. If not specified, the first item will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 0

    """

    x_plex_container_size: Annotated[
        Optional[int],
        pydantic.Field(alias="X-Plex-Container-Size"),
        FieldMetadata(query=QueryParamMetadata(style="form", explode=True)),
    ] = 50
    r"""The number of items to return. If not specified, all items will be returned.
    If the number of items exceeds the limit, the response will be paginated.
    By default this is 50

    """


LibrarySectionIDTypedDict = Union[int, str]


LibrarySectionID = Union[int, str]


class GetLibraryItemsType(str, Enum):
    r"""The type of media content"""

    MOVIE = "movie"
    TV_SHOW = "show"
    SEASON = "season"
    EPISODE = "episode"


class FlattenSeasons(str, Enum):
    FALSE = "0"
    TRUE = "1"


class ShowOrdering(str, Enum):
    r"""Setting that indicates the episode ordering for the show
    None = Library default,
    tmdbAiring = The Movie Database (Aired),
    aired = TheTVDB (Aired),
    dvd = TheTVDB (DVD),
    absolute = TheTVDB (Absolute)).

    """

    NONE = "None"
    TMDB_AIRING = "tmdbAiring"
    AIRED = "aired"
    DVD = "dvd"
    ABSOLUTE = "absolute"


class HasThumbnail(str, Enum):
    FALSE = "0"
    TRUE = "1"


class GetLibraryItemsPartTypedDict(TypedDict):
    id: int
    key: str
    duration: int
    file: str
    size: int
    container: str
    r"""The container format of the media file.

    """
    video_profile: str
    audio_profile: NotRequired[str]
    indexes: NotRequired[str]
    has_thumbnail: NotRequired[HasThumbnail]


class GetLibraryItemsPart(BaseModel):
    id: int

    key: str

    duration: int

    file: str

    size: int

    container: str
    r"""The container format of the media file.

    """

    video_profile: Annotated[str, pydantic.Field(alias="videoProfile")]

    audio_profile: Annotated[Optional[str], pydantic.Field(alias="audioProfile")] = None

    indexes: Optional[str] = None

    has_thumbnail: Annotated[
        Optional[HasThumbnail], pydantic.Field(alias="hasThumbnail")
    ] = HasThumbnail.FALSE


class GetLibraryItemsMediaTypedDict(TypedDict):
    id: int
    duration: int
    bitrate: int
    width: int
    height: int
    aspect_ratio: float
    audio_channels: int
    audio_codec: str
    video_codec: str
    video_resolution: str
    container: str
    video_frame_rate: str
    video_profile: str
    part: List[GetLibraryItemsPartTypedDict]
    audio_profile: NotRequired[str]
    has_voice_activity: NotRequired[bool]


class GetLibraryItemsMedia(BaseModel):
    id: int

    duration: int

    bitrate: int

    width: int

    height: int

    aspect_ratio: Annotated[float, pydantic.Field(alias="aspectRatio")]

    audio_channels: Annotated[int, pydantic.Field(alias="audioChannels")]

    audio_codec: Annotated[str, pydantic.Field(alias="audioCodec")]

    video_codec: Annotated[str, pydantic.Field(alias="videoCodec")]

    video_resolution: Annotated[str, pydantic.Field(alias="videoResolution")]

    container: str

    video_frame_rate: Annotated[str, pydantic.Field(alias="videoFrameRate")]

    video_profile: Annotated[str, pydantic.Field(alias="videoProfile")]

    part: Annotated[List[GetLibraryItemsPart], pydantic.Field(alias="Part")]

    audio_profile: Annotated[Optional[str], pydantic.Field(alias="audioProfile")] = None

    has_voice_activity: Annotated[
        Optional[bool], pydantic.Field(alias="hasVoiceActivity")
    ] = None


class GetLibraryItemsGenreTypedDict(TypedDict):
    tag: NotRequired[str]


class GetLibraryItemsGenre(BaseModel):
    tag: Optional[str] = None


class GetLibraryItemsCountryTypedDict(TypedDict):
    tag: NotRequired[str]


class GetLibraryItemsCountry(BaseModel):
    tag: Optional[str] = None


class GetLibraryItemsDirectorTypedDict(TypedDict):
    tag: NotRequired[str]


class GetLibraryItemsDirector(BaseModel):
    tag: Optional[str] = None


class GetLibraryItemsWriterTypedDict(TypedDict):
    tag: NotRequired[str]


class GetLibraryItemsWriter(BaseModel):
    tag: Optional[str] = None


class CollectionTypedDict(TypedDict):
    tag: NotRequired[str]


class Collection(BaseModel):
    tag: Optional[str] = None


class GetLibraryItemsRoleTypedDict(TypedDict):
    tag: NotRequired[str]


class GetLibraryItemsRole(BaseModel):
    tag: Optional[str] = None


class MediaGUIDTypedDict(TypedDict):
    id: str
    r"""Can be one of the following formats:
    imdb://tt13015952, tmdb://2434012, tvdb://7945991

    """


class MediaGUID(BaseModel):
    id: str
    r"""Can be one of the following formats:
    imdb://tt13015952, tmdb://2434012, tvdb://7945991

    """


class UltraBlurColorsTypedDict(TypedDict):
    top_left: str
    top_right: str
    bottom_right: str
    bottom_left: str


class UltraBlurColors(BaseModel):
    top_left: Annotated[str, pydantic.Field(alias="topLeft")]

    top_right: Annotated[str, pydantic.Field(alias="topRight")]

    bottom_right: Annotated[str, pydantic.Field(alias="bottomRight")]

    bottom_left: Annotated[str, pydantic.Field(alias="bottomLeft")]


class GetLibraryItemsLibraryResponseType(str, Enum):
    COVER_POSTER = "coverPoster"
    BACKGROUND = "background"
    SNAPSHOT = "snapshot"
    CLEAR_LOGO = "clearLogo"


class GetLibraryItemsImageTypedDict(TypedDict):
    alt: str
    type: GetLibraryItemsLibraryResponseType
    url: str


class GetLibraryItemsImage(BaseModel):
    alt: str

    type: GetLibraryItemsLibraryResponseType

    url: str


class GetLibraryItemsMetadataTypedDict(TypedDict):
    rating_key: str
    r"""The rating key (Media ID) of this media item.
    Note: This is always an integer, but is represented as a string in the API.

    """
    key: str
    guid: str
    type: GetLibraryItemsType
    r"""The type of media content

    """
    title: str
    summary: str
    added_at: int
    r"""Unix epoch datetime in seconds"""
    studio: NotRequired[str]
    skip_children: NotRequired[bool]
    slug: NotRequired[str]
    content_rating: NotRequired[str]
    rating: NotRequired[float]
    audience_rating: NotRequired[float]
    year: NotRequired[int]
    season_count: NotRequired[int]
    tagline: NotRequired[str]
    flatten_seasons: NotRequired[FlattenSeasons]
    show_ordering: NotRequired[ShowOrdering]
    r"""Setting that indicates the episode ordering for the show
    None = Library default,
    tmdbAiring = The Movie Database (Aired),
    aired = TheTVDB (Aired),
    dvd = TheTVDB (DVD),
    absolute = TheTVDB (Absolute)).

    """
    thumb: NotRequired[str]
    art: NotRequired[str]
    banner: NotRequired[str]
    duration: NotRequired[int]
    originally_available_at: NotRequired[date]
    updated_at: NotRequired[int]
    r"""Unix epoch datetime in seconds"""
    audience_rating_image: NotRequired[str]
    chapter_source: NotRequired[str]
    primary_extra_key: NotRequired[str]
    rating_image: NotRequired[str]
    grandparent_rating_key: NotRequired[str]
    grandparent_guid: NotRequired[str]
    grandparent_key: NotRequired[str]
    grandparent_title: NotRequired[str]
    grandparent_thumb: NotRequired[str]
    grandparent_slug: NotRequired[str]
    grandparent_art: NotRequired[str]
    grandparent_theme: NotRequired[str]
    media: NotRequired[List[GetLibraryItemsMediaTypedDict]]
    r"""The Media object is only included when type query is `4` or higher.

    """
    genre: NotRequired[List[GetLibraryItemsGenreTypedDict]]
    country: NotRequired[List[GetLibraryItemsCountryTypedDict]]
    director: NotRequired[List[GetLibraryItemsDirectorTypedDict]]
    writer: NotRequired[List[GetLibraryItemsWriterTypedDict]]
    collection: NotRequired[List[CollectionTypedDict]]
    role: NotRequired[List[GetLibraryItemsRoleTypedDict]]
    media_guid: NotRequired[List[MediaGUIDTypedDict]]
    r"""The Guid object is only included in the response if the `includeGuids` parameter is set to `1`.

    """
    ultra_blur_colors: NotRequired[UltraBlurColorsTypedDict]
    image: NotRequired[List[GetLibraryItemsImageTypedDict]]
    title_sort: NotRequired[str]
    view_count: NotRequired[int]
    last_viewed_at: NotRequired[int]
    original_title: NotRequired[str]
    view_offset: NotRequired[int]
    skip_count: NotRequired[int]
    index: NotRequired[int]
    theme: NotRequired[str]
    leaf_count: NotRequired[int]
    viewed_leaf_count: NotRequired[int]
    child_count: NotRequired[int]
    has_premium_extras: NotRequired[str]
    has_premium_primary_extra: NotRequired[str]
    parent_rating_key: NotRequired[str]
    r"""The rating key of the parent item.

    """
    parent_guid: NotRequired[str]
    parent_studio: NotRequired[str]
    parent_key: NotRequired[str]
    parent_title: NotRequired[str]
    parent_index: NotRequired[int]
    parent_year: NotRequired[int]
    parent_thumb: NotRequired[str]
    parent_theme: NotRequired[str]


class GetLibraryItemsMetadata(BaseModel):
    rating_key: Annotated[str, pydantic.Field(alias="ratingKey")]
    r"""The rating key (Media ID) of this media item.
    Note: This is always an integer, but is represented as a string in the API.

    """

    key: str

    guid: str

    type: GetLibraryItemsType
    r"""The type of media content

    """

    title: str

    summary: str

    added_at: Annotated[int, pydantic.Field(alias="addedAt")]
    r"""Unix epoch datetime in seconds"""

    studio: Optional[str] = None

    skip_children: Annotated[Optional[bool], pydantic.Field(alias="skipChildren")] = (
        None
    )

    slug: Optional[str] = None

    content_rating: Annotated[Optional[str], pydantic.Field(alias="contentRating")] = (
        None
    )

    rating: Optional[float] = None

    audience_rating: Annotated[
        Optional[float], pydantic.Field(alias="audienceRating")
    ] = None

    year: Optional[int] = None

    season_count: Annotated[Optional[int], pydantic.Field(alias="seasonCount")] = None

    tagline: Optional[str] = None

    flatten_seasons: Annotated[
        Optional[FlattenSeasons], pydantic.Field(alias="flattenSeasons")
    ] = FlattenSeasons.FALSE

    show_ordering: Annotated[
        Optional[ShowOrdering], pydantic.Field(alias="showOrdering")
    ] = None
    r"""Setting that indicates the episode ordering for the show
    None = Library default,
    tmdbAiring = The Movie Database (Aired),
    aired = TheTVDB (Aired),
    dvd = TheTVDB (DVD),
    absolute = TheTVDB (Absolute)).

    """

    thumb: Optional[str] = None

    art: Optional[str] = None

    banner: Optional[str] = None

    duration: Optional[int] = None

    originally_available_at: Annotated[
        Optional[date], pydantic.Field(alias="originallyAvailableAt")
    ] = None

    updated_at: Annotated[Optional[int], pydantic.Field(alias="updatedAt")] = None
    r"""Unix epoch datetime in seconds"""

    audience_rating_image: Annotated[
        Optional[str], pydantic.Field(alias="audienceRatingImage")
    ] = None

    chapter_source: Annotated[Optional[str], pydantic.Field(alias="chapterSource")] = (
        None
    )

    primary_extra_key: Annotated[
        Optional[str], pydantic.Field(alias="primaryExtraKey")
    ] = None

    rating_image: Annotated[Optional[str], pydantic.Field(alias="ratingImage")] = None

    grandparent_rating_key: Annotated[
        Optional[str], pydantic.Field(alias="grandparentRatingKey")
    ] = None

    grandparent_guid: Annotated[
        Optional[str], pydantic.Field(alias="grandparentGuid")
    ] = None

    grandparent_key: Annotated[
        Optional[str], pydantic.Field(alias="grandparentKey")
    ] = None

    grandparent_title: Annotated[
        Optional[str], pydantic.Field(alias="grandparentTitle")
    ] = None

    grandparent_thumb: Annotated[
        Optional[str], pydantic.Field(alias="grandparentThumb")
    ] = None

    grandparent_slug: Annotated[
        Optional[str], pydantic.Field(alias="grandparentSlug")
    ] = None

    grandparent_art: Annotated[
        Optional[str], pydantic.Field(alias="grandparentArt")
    ] = None

    grandparent_theme: Annotated[
        Optional[str], pydantic.Field(alias="grandparentTheme")
    ] = None

    media: Annotated[
        Optional[List[GetLibraryItemsMedia]], pydantic.Field(alias="Media")
    ] = None
    r"""The Media object is only included when type query is `4` or higher.

    """

    genre: Annotated[
        Optional[List[GetLibraryItemsGenre]], pydantic.Field(alias="Genre")
    ] = None

    country: Annotated[
        Optional[List[GetLibraryItemsCountry]], pydantic.Field(alias="Country")
    ] = None

    director: Annotated[
        Optional[List[GetLibraryItemsDirector]], pydantic.Field(alias="Director")
    ] = None

    writer: Annotated[
        Optional[List[GetLibraryItemsWriter]], pydantic.Field(alias="Writer")
    ] = None

    collection: Annotated[
        Optional[List[Collection]], pydantic.Field(alias="Collection")
    ] = None

    role: Annotated[
        Optional[List[GetLibraryItemsRole]], pydantic.Field(alias="Role")
    ] = None

    media_guid: Annotated[Optional[List[MediaGUID]], pydantic.Field(alias="Guid")] = (
        None
    )
    r"""The Guid object is only included in the response if the `includeGuids` parameter is set to `1`.

    """

    ultra_blur_colors: Annotated[
        Optional[UltraBlurColors], pydantic.Field(alias="UltraBlurColors")
    ] = None

    image: Annotated[
        Optional[List[GetLibraryItemsImage]], pydantic.Field(alias="Image")
    ] = None

    title_sort: Annotated[Optional[str], pydantic.Field(alias="titleSort")] = None

    view_count: Annotated[Optional[int], pydantic.Field(alias="viewCount")] = None

    last_viewed_at: Annotated[Optional[int], pydantic.Field(alias="lastViewedAt")] = (
        None
    )

    original_title: Annotated[Optional[str], pydantic.Field(alias="originalTitle")] = (
        None
    )

    view_offset: Annotated[Optional[int], pydantic.Field(alias="viewOffset")] = None

    skip_count: Annotated[Optional[int], pydantic.Field(alias="skipCount")] = None

    index: Optional[int] = None

    theme: Optional[str] = None

    leaf_count: Annotated[Optional[int], pydantic.Field(alias="leafCount")] = None

    viewed_leaf_count: Annotated[
        Optional[int], pydantic.Field(alias="viewedLeafCount")
    ] = None

    child_count: Annotated[Optional[int], pydantic.Field(alias="childCount")] = None

    has_premium_extras: Annotated[
        Optional[str], pydantic.Field(alias="hasPremiumExtras")
    ] = None

    has_premium_primary_extra: Annotated[
        Optional[str], pydantic.Field(alias="hasPremiumPrimaryExtra")
    ] = None

    parent_rating_key: Annotated[
        Optional[str], pydantic.Field(alias="parentRatingKey")
    ] = None
    r"""The rating key of the parent item.

    """

    parent_guid: Annotated[Optional[str], pydantic.Field(alias="parentGuid")] = None

    parent_studio: Annotated[Optional[str], pydantic.Field(alias="parentStudio")] = None

    parent_key: Annotated[Optional[str], pydantic.Field(alias="parentKey")] = None

    parent_title: Annotated[Optional[str], pydantic.Field(alias="parentTitle")] = None

    parent_index: Annotated[Optional[int], pydantic.Field(alias="parentIndex")] = None

    parent_year: Annotated[Optional[int], pydantic.Field(alias="parentYear")] = None

    parent_thumb: Annotated[Optional[str], pydantic.Field(alias="parentThumb")] = None

    parent_theme: Annotated[Optional[str], pydantic.Field(alias="parentTheme")] = None


class GetLibraryItemsFilterTypedDict(TypedDict):
    filter_: str
    filter_type: str
    key: str
    title: str
    type: str


class GetLibraryItemsFilter(BaseModel):
    filter_: Annotated[str, pydantic.Field(alias="filter")]

    filter_type: Annotated[str, pydantic.Field(alias="filterType")]

    key: str

    title: str

    type: str


class ActiveDirection(str, Enum):
    r"""The direction of the sort. Can be either `asc` or `desc`."""

    ASCENDING = "asc"
    DESCENDING = "desc"


class DefaultDirection(str, Enum):
    r"""The direction of the sort. Can be either `asc` or `desc`."""

    ASCENDING = "asc"
    DESCENDING = "desc"


class GetLibraryItemsSortTypedDict(TypedDict):
    key: str
    title: str
    default: NotRequired[str]
    active: NotRequired[bool]
    active_direction: NotRequired[ActiveDirection]
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """
    default_direction: NotRequired[DefaultDirection]
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """
    desc_key: NotRequired[str]
    first_character_key: NotRequired[str]


class GetLibraryItemsSort(BaseModel):
    key: str

    title: str

    default: Optional[str] = None

    active: Optional[bool] = None

    active_direction: Annotated[
        Optional[ActiveDirection], pydantic.Field(alias="activeDirection")
    ] = ActiveDirection.ASCENDING
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """

    default_direction: Annotated[
        Optional[DefaultDirection], pydantic.Field(alias="defaultDirection")
    ] = DefaultDirection.ASCENDING
    r"""The direction of the sort. Can be either `asc` or `desc`.

    """

    desc_key: Annotated[Optional[str], pydantic.Field(alias="descKey")] = None

    first_character_key: Annotated[
        Optional[str], pydantic.Field(alias="firstCharacterKey")
    ] = None


class GetLibraryItemsFieldTypedDict(TypedDict):
    key: str
    title: str
    type: str
    sub_type: NotRequired[str]


class GetLibraryItemsField(BaseModel):
    key: str

    title: str

    type: str

    sub_type: Annotated[Optional[str], pydantic.Field(alias="subType")] = None


class GetLibraryItemsLibraryTypeTypedDict(TypedDict):
    key: str
    type: str
    title: str
    active: bool
    filter_: NotRequired[List[GetLibraryItemsFilterTypedDict]]
    sort: NotRequired[List[GetLibraryItemsSortTypedDict]]
    field: NotRequired[List[GetLibraryItemsFieldTypedDict]]


class GetLibraryItemsLibraryType(BaseModel):
    key: str

    type: str

    title: str

    active: bool

    filter_: Annotated[
        Optional[List[GetLibraryItemsFilter]], pydantic.Field(alias="Filter")
    ] = None

    sort: Annotated[
        Optional[List[GetLibraryItemsSort]], pydantic.Field(alias="Sort")
    ] = None

    field: Annotated[
        Optional[List[GetLibraryItemsField]], pydantic.Field(alias="Field")
    ] = None


class GetLibraryItemsOperatorTypedDict(TypedDict):
    key: str
    title: str


class GetLibraryItemsOperator(BaseModel):
    key: str

    title: str


class GetLibraryItemsFieldTypeTypedDict(TypedDict):
    type: str
    operator: List[GetLibraryItemsOperatorTypedDict]


class GetLibraryItemsFieldType(BaseModel):
    type: str

    operator: Annotated[List[GetLibraryItemsOperator], pydantic.Field(alias="Operator")]


class MetaTypedDict(TypedDict):
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`."""

    type: NotRequired[List[GetLibraryItemsLibraryTypeTypedDict]]
    field_type: NotRequired[List[GetLibraryItemsFieldTypeTypedDict]]


class Meta(BaseModel):
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`."""

    type: Annotated[
        Optional[List[GetLibraryItemsLibraryType]], pydantic.Field(alias="Type")
    ] = None

    field_type: Annotated[
        Optional[List[GetLibraryItemsFieldType]], pydantic.Field(alias="FieldType")
    ] = None


class GetLibraryItemsMediaContainerTypedDict(TypedDict):
    size: int
    total_size: int
    offset: int
    content: str
    allow_sync: bool
    art: str
    identifier: str
    library_section_id: LibrarySectionIDTypedDict
    library_section_title: str
    library_section_uuid: str
    media_tag_prefix: str
    media_tag_version: int
    thumb: str
    title1: str
    title2: str
    view_group: str
    metadata: List[GetLibraryItemsMetadataTypedDict]
    nocache: NotRequired[bool]
    view_mode: NotRequired[int]
    mixed_parents: NotRequired[bool]
    meta: NotRequired[MetaTypedDict]
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`.

    """


class GetLibraryItemsMediaContainer(BaseModel):
    size: int

    total_size: Annotated[int, pydantic.Field(alias="totalSize")]

    offset: int

    content: str

    allow_sync: Annotated[bool, pydantic.Field(alias="allowSync")]

    art: str

    identifier: str

    library_section_id: Annotated[
        LibrarySectionID, pydantic.Field(alias="librarySectionID")
    ]

    library_section_title: Annotated[str, pydantic.Field(alias="librarySectionTitle")]

    library_section_uuid: Annotated[str, pydantic.Field(alias="librarySectionUUID")]

    media_tag_prefix: Annotated[str, pydantic.Field(alias="mediaTagPrefix")]

    media_tag_version: Annotated[int, pydantic.Field(alias="mediaTagVersion")]

    thumb: str

    title1: str

    title2: str

    view_group: Annotated[str, pydantic.Field(alias="viewGroup")]

    metadata: Annotated[List[GetLibraryItemsMetadata], pydantic.Field(alias="Metadata")]

    nocache: Optional[bool] = None

    view_mode: Annotated[Optional[int], pydantic.Field(alias="viewMode")] = None

    mixed_parents: Annotated[Optional[bool], pydantic.Field(alias="mixedParents")] = (
        None
    )

    meta: Annotated[Optional[Meta], pydantic.Field(alias="Meta")] = None
    r"""The Meta object is only included in the response if the `includeMeta` parameter is set to `1`.

    """


class GetLibraryItemsResponseBodyTypedDict(TypedDict):
    r"""The contents of the library by section and tag"""

    media_container: NotRequired[GetLibraryItemsMediaContainerTypedDict]


class GetLibraryItemsResponseBody(BaseModel):
    r"""The contents of the library by section and tag"""

    media_container: Annotated[
        Optional[GetLibraryItemsMediaContainer], pydantic.Field(alias="MediaContainer")
    ] = None


class GetLibraryItemsResponseTypedDict(TypedDict):
    content_type: str
    r"""HTTP response content type for this operation"""
    status_code: int
    r"""HTTP response status code for this operation"""
    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""
    object: NotRequired[GetLibraryItemsResponseBodyTypedDict]
    r"""The contents of the library by section and tag"""


class GetLibraryItemsResponse(BaseModel):
    content_type: str
    r"""HTTP response content type for this operation"""

    status_code: int
    r"""HTTP response status code for this operation"""

    raw_response: httpx.Response
    r"""Raw HTTP response; suitable for custom response parsing"""

    object: Optional[GetLibraryItemsResponseBody] = None
    r"""The contents of the library by section and tag"""
