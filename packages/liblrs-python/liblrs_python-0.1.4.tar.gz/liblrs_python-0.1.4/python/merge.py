import json
import yaml
import click

import flatbuffers
# Flatbuffer types generated from lrs.fbs
import Lrs
import LinearReferencingMethod as LRM
import Anchor
import Direction
import Node
import Point
import Property
import Traversal
import Segment
import SegmentOfTraversal

# This script merges three datasources to build a full LRS for the French railway network
# - OpenStreetMap for the geometries
# - OSRD’s dataset for anchors geometry
# - Gaia for the distances between anchors

@click.command()
@click.option('--osm', help='Geometry from OSM as binary LRS.')
@click.option('--gaia', help='Gaia data with distances between anchors as yaml.')
@click.option('--rks', help='SNCF RKs (anchors) as json.')
@click.option('--out', help='SNCF RKs (anchors) as json.')
def merge(osm, gaia, rks, out):
    # Flatbuffer builder that we use to create the new output file
    builder = flatbuffers.Builder(1024)

    # Prepare some standard properties
    def property(builder, key, value):
        key = builder.CreateString(key)
        value = builder.CreateString(value)
        Property.Start(builder)
        Property.AddKey(builder, key)
        Property.AddValue(builder, value)
        prop = Property.End(builder)
        Anchor.StartPropertiesVector(builder, 0)
        builder.PrependUOffsetTRelative(prop)
        return builder.EndVector()

    anchor_source = {
        "pmsig": property(builder, "source", "pmsig"),
        "locinfra": property(builder, "source", "locinfra"),
        "imajnet": property(builder, "source", "imajnet")
    }

    # Step 1: distance between anchors from gaia
    gaia_lrms = {}

    with open(gaia) as gaia_lrs:
        gaia_lrs = yaml.safe_load(gaia_lrs)

        for gaia_lrm in gaia_lrs['linear_referencing_methods']:
            cumulated = 0

            distances = {}
            for i in range(1, len(gaia_lrm['distances'])): # We ignore _begin anchor
                anchor = gaia_lrm['anchors'][i]
                anchor_name = anchor.split('_')[1]
                cumulated += gaia_lrm['distances'][i]

                distances[anchor_name] = cumulated
            gaia_lrms[gaia_lrm['id']] = distances

    # Step 2: create the anchors vector and anchor geometry

    # Will contain the index in the flatbuffer structure
    anchor_indices = {}
    anchors_fb = [] # The anchors as flatbuffer
    anchors_geom_fb = [] # The anchors’ geometry as flatbuffer
    for track_id, rk_wrapper in json.loads(open(rks).read())['tracks'].items():
        anchor_indices[track_id] = {}
        rks = rk_wrapper['rks']

        for rk in rks:
            anchor_name = rk["name"]
            anchor_indices[track_id][anchor_name] = len(anchors_fb)

            anchor_id_fb = builder.CreateString(f"{track_id}_{anchor_name}")
            anchor_name_fb = builder.CreateString(anchor_name)
            Anchor.Start(builder)
            Anchor.AddId(builder, anchor_id_fb)
            Anchor.AddName(builder, anchor_name_fb)
            Anchor.AnchorAddProperties(builder, anchor_source[rk["dataSet"]])
            Anchor.AnchorAddGeometry(builder, Point.CreatePoint(builder, rk["location"]["lon"], rk["location"]["lat"]))
            anchors_fb.append(Anchor.End(builder))

    # Create the flatbuffer vectors for anchors and geometry
    Lrs.StartAnchorsVector(builder, len(anchors_fb))
    print(f"number of anchors: {len(anchors_fb)}")
    for anchor in reversed(anchors_fb):
        builder.PrependUOffsetTRelative(anchor)
    anchors_fb_vec = builder.EndVector()

    # Step 3: iterate on OSM traversals and use the distances gaia

    # Open the lrs data from OSM
    buf = open(osm, 'rb').read()
    buf = bytearray(buf)
    osm_lrs = Lrs.Lrs.GetRootAs(buf, 0)

    # Some statistics to know how much we matched
    count_fallback = 0
    count_not_found = 0
    count_perfect_match = 0

    lrms = []
    # The traversals are extracted from the data generated by OpenStreetMap
    for i in range(osm_lrs.TraversalsLength()):
        traversal = osm_lrs.Traversals(i)
        id = traversal.Id().decode('utf-8')

        # The OSM id is in the form ref:FR:SNCF_Reseau="530000,1,UNIQUE,77.299,178.061"
        # We extract the different parts of the data
        [ligne, tronçon, voie, pk_debut, pk_fin] = id.split(',')

        # Pad the line number with initial zeros
        ligne = ligne.rjust(6, '0')

        # Some RER-C weirdness where letters are used for anchors
        pk_debut = pk_debut.replace("D", "0").replace("E", "1").replace("F","2").replace("G", "3").replace("H", "4")
        pk_fin = pk_fin.replace("D", "0").replace("E", "1").replace("F","2").replace("G", "3").replace("H", "4")

        # We use the distances to filter the anchors and for statistics
        pk_debut = float(pk_debut)
        pk_fin = float(pk_fin)
        if pk_debut > pk_fin:
            pk_debut, pk_fin = pk_fin, pk_debut
        pk_distance = pk_fin - pk_debut

        # Try to find the _voie_ in the anchors dataset, and fallbacks on the line V1 if we didn’t find
        rks_id = f"{ligne}-{tronçon}-{voie}"
        fallback = f"{ligne}-1-V1"

        if rks_id in anchor_indices:
            count_perfect_match += pk_distance
        elif fallback in anchor_indices:
            count_fallback += pk_distance
            rks_id = fallback
        else:
            print(f"Could not find {rks_id} in the rks, nor the fallback {fallback}")
            count_not_found += pk_distance
            continue
        
        # Try to find the distances from the gaia dataset. If we have the _voie_ we use it, otherwise fallback on the line
        gaia_id = f"{ligne}_{voie}" if f"{ligne}_{voie}" in gaia_lrms else ligne
        gaia_lrm = gaia_lrms[gaia_id]

        for (name, index) in anchor_indices[rks_id].items():
            # We are not sure if `_begin` from gaia and `0` should be considered as the same
            # For now we decide to ignore them
            if name not in gaia_lrm and name != "0":
                print(f"could not find anchor {name} in {gaia_id}")
                continue

        # Filter anchors that apply to the segment we are considering
        anchors_on_segment = [(name, index) for (name, index) in anchor_indices[rks_id].items() if name in gaia_lrm and pk_debut <= float(name) <= pk_fin]

        # That building all the flatbuffers objects
        LRM.StartAnchorIndicesVector(builder, len(anchors_on_segment))
        for (name, index) in reversed(anchors_on_segment):
            builder.PrependUint64(index)
        indices_vector = builder.EndVector()

        LRM.StartDistancesVector(builder, len(anchors_on_segment))
        for (name, index) in reversed(anchors_on_segment):
            distance = gaia_lrm[name]
            builder.PrependFloat64(distance)
        distances_vector = builder.EndVector()
        
        id_fb = builder.CreateString(id)
        LRM.Start(builder)
        LRM.AddId(builder, id_fb)
        LRM.AddAnchorIndices(builder, indices_vector)
        LRM.AddDistances(builder, distances_vector)
        LRM.AddTraversalIndex(builder, i)
        lrms.append(LRM.End(builder))

    print(f"perfect match: {int(count_perfect_match)} km, fallback: {int(count_fallback)} km, not_found: {int(count_not_found)} km")

    Lrs.LrsStartLinearReferencingMethodsVector(builder, len(lrms))
    for lrm in reversed(lrms):
        builder.PrependUOffsetTRelative(lrm)
    fb_lrms = builder.EndVector()


    # Step 4: rebuild the complete Lrs

    # Step 4.1: rebuild the OSM data
    traversals = []
    for i in range(osm_lrs.TraversalsLength()):
        traversal = osm_lrs.Traversals(i)

        Traversal.StartSegmentsVector(builder, traversal.SegmentsLength())
        for j in reversed(range(traversal.SegmentsLength())):
            segment = traversal.Segments(j)
            SegmentOfTraversal.CreateSegmentOfTraversal(builder, segment.SegmentIndex(), segment.Direction())
        segments = builder.EndVector()

        id = builder.CreateString(traversal.Id())

        Traversal.TraversalStart(builder)
        Traversal.TraversalAddId(builder, id)
        Traversal.AddSegments(builder, segments)
        traversals.append(Traversal.End(builder))

    Lrs.StartTraversalsVector(builder, len(traversals))
    for traversal in reversed(traversals):
        builder.PrependUOffsetTRelative(traversal)
    traversal_vec = builder.EndVector()

    segments = []
    for i in range(osm_lrs.SegmentsLength()):
        segment = osm_lrs.Segments(i)

        Segment.StartGeometryVector(builder, segment.GeometryLength())
        for j in reversed(range(segment.GeometryLength())):
            point = segment.Geometry(j)
            Point.CreatePoint(builder, point.X(), point.Y())
        geometry = builder.EndVector()

        id = builder.CreateString(segment.Id())
        Segment.Start(builder)
        Segment.AddId(builder, id)
        Segment.AddGeometry(builder, geometry)
        segments.append(Segment.End(builder))

    Lrs.StartSegmentsVector(builder, len(segments))
    for segment in reversed(segments):
        builder.PrependUOffsetTRelative(segment)
    segment_vec = builder.EndVector()

    nodes = []
    for i in reversed(range(osm_lrs.NodesLength())):
        node = osm_lrs.Nodes(i)
        id = builder.CreateString(node.Id())
        Node.Start(builder)
        Node.NodeAddId(builder, id)
        nodes.append(Node.End(builder))
        
    Lrs.StartNodesVector(builder, len(nodes))
    for node in reversed(nodes):
        builder.PrependUOffsetTRelative(node)
    fb_nodes = builder.EndVector()

    # Step 4.2: save everything in the final file
    Lrs.Start(builder)
    Lrs.AddSegments(builder, segment_vec)
    Lrs.AddTraversals(builder, traversal_vec)
    Lrs.AddNodes(builder, fb_nodes)
    Lrs.AddLinearReferencingMethods(builder, fb_lrms)
    Lrs.AddAnchors(builder, anchors_fb_vec)
    final_lrs = Lrs.End(builder)
    builder.Finish(final_lrs)

    buf = builder.Output()
    with open(out, 'bw') as f:
        f.write(buf)

if __name__ == "__main__":
    merge()