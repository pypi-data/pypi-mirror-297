#! /usr/bin/env python
# -*- coding: utf-8 -*-
#
# Copyright (C) 2023 MESH Research
#
# core-migrate is free software; you can redistribute it and/or
# modify it under the terms of the MIT License; see LICENSE file for more
# details.

from invenio_record_importer_kcworks.libs.fedoraapi import FedoraApi
import requests
from typing import Optional
import os
from pprint import pprint
import xml.etree.ElementTree as ET

from invenio_record_importer_kcworks.utils.utils import valid_date

fedora_fields = [
    "pid",
    "label",
    "state",
    "ownerId",
    "cDate",
    "mDate",
    "dcmDate",
    "title",
    "creator",
    "subject",
    "description",
    "publisher",
    "contributor",
    "date",
    "type",
    "format",
    "identifier",
    "source",
    "language",
    "relation",
    "coverage",
    "rights",
]


def fetch_fedora_records(
    query: Optional[str],
    protocol: str,
    pid: Optional[str],
    terms: Optional[str],
    fields: Optional[str],
    count: int,
) -> list[dict]:
    """
    Fetch deposit records from the Fedora CORE datastream.

    DEPRECATED AND NOT CURRENTLY FUNCTIONAL
    """
    fields_list = fields.split(",") if fields is not None else fedora_fields
    FEDORA_USER = os.environ["FEDORA_USER"]
    FEDORA_PASSWORD = os.environ["FEDORA_PASSWORD"]

    f = FedoraApi(
        base_url="https://comcore.devel.lib.msu.edu/fedora",
        username=os.environ["FEDORA_USER"],
        password=os.environ["FEDORA_PASSWORD"],
    )
    r = ""
    if protocol == "fedora-xml":
        fedora_url = (  # whole datastream object
            f"https://comcore.devel.lib.msu.edu/fedora/objects/{pid}/objectXML"
        )
        r = requests.get(fedora_url, auth=(FEDORA_USER, FEDORA_PASSWORD))
        pprint(r.text)
    if protocol == "DC":
        fedora_url = f"https://comcore.devel.lib.msu.edu/fedora/objects/{pid}/datastreams/DC?format=xml"  # dc metadata
        r = requests.get(fedora_url, auth=(FEDORA_USER, FEDORA_PASSWORD))
        pprint(r.text)
    elif protocol == "ext":
        fedora_url = f"https://comcore.devel.lib.msu.edu/fedora/objects/{pid}/datastreams/RELS-EXT?format=xml"  # rdf
        r = requests.get(fedora_url, auth=(FEDORA_USER, FEDORA_PASSWORD))
        pprint(r.text)
    elif protocol == "content":
        fedora_url = f"https://comcore.devel.lib.msu.edu/fedora/objects/{pid}/datastreams/CONTENT?format=xml"  # file size, etc.
        r = requests.get(fedora_url, auth=(FEDORA_USER, FEDORA_PASSWORD))
        pprint(r.text)
    # fedora_url = "https://comcore.devel.lib.msu.edu/fedora/objects/hc:23276/relationships?format=xml" # rdf
    # fedora_url = "https://comcore.devel.lib.msu.edu/fedora/objects/hc:23276/datastreams?format=xml" # rdf
    # fedora_url = "https://comcore.devel.lib.msu.edu/fedora/search"

    # query = urllib.quote('title:rome creator:staples')
    # fedora_url = f'https://comcore.devel.lib.msu.edu/fedora/objects?pid=true&label=true&state=true&ownerId=true&cDate=true&mDate=true&dcmDate=true&title=true&creator=true&subject=true&description=true&publisher=true&contributor=true&date=true&type=true&format=true&identifier=true&source=true&language=true&relation=true&coverage=true&rights=true&terms=&query=title~gothic&resultFormat=xml&query=title~Gothic creator~*K*&maxResults=3'
    elif protocol == "fedora-terms":
        r = f.find_all_objects(
            terms, fields=fields_list, query=f"identifier~{pid}"
        )
        pprint(r)
    elif protocol == "fedora-pid":
        r = f.find_all_objects_by_id(f"{pid}", fields=fields_list)
        pprint(r)
    # all_objects = f.find_all_objects("", fields=fields_list,
    #                                  query="'title~Gothic'", maxResults=count)

    records = []
    aggregator_pid = 0
    main_pid = 0

    root = ET.fromstring(r[1])

    def _getnode(base, fieldname):
        # node = base.find(f'{dc}{fieldname}')
        node = base.findall(f"{prefix}{fieldname}")
        if len(node) > 0:
            return node[0].text
        else:
            return None

    def _getnodes(base, fieldname):
        # nodes = base.findall(f'{dc}{fieldname}')
        nodes = base.findall(f"{prefix}{fieldname}")
        return nodes

    prefix = "{http://www.fedora.info/definitions/1/0/types/}"
    # prefix = "{info:fedora/fedora-system:def/foxml#}"
    # oai_dc = "{http://www.openarchives.org/OAI/2.0/oai_dc/}"
    # dc = "{http://purl.org/dc/elements/1.1/}"
    # basepath = f'./{prefix}datastream/{prefix}datastreamVersion/{prefix}xmlContent/{oai_dc}dc'

    # rdf = "{http://www.w3.org/1999/02/22-rdf-syntax-ns#}"
    # cc_rights = root.findall(f'./{prefix}datastream[@ID="RELS-EXT"]/{prefix}datastreamVersion/{prefix}xmlContent/{rdf}RDF/{rdf}Description/{{http://creativecommons.org/ns#}}license')

    versions = root.findall(f"./{prefix}resultList/{prefix}objectFields")
    for v in versions:
        newrec = {
            "metadata": {
                "resource_type": {},
                "title": "",
                "creators": [],
                "publication_date": [],
                "identifiers": [],
                "dates": [],
                "subjects": [],
                "languages": [],
                "rights": [],
                "formats": [],
            },
            "files": {"entries": []},
        }

        # TODO: standardize type vocabulary?
        newrec["metadata"]["resource_type"] = _getnode(v, "type")
        newrec["metadata"]["title"] = _getnode(v, "title")

        for c in _getnodes(v, "creator"):
            newrec["metadata"]["creators"].append(
                {
                    "person_or_org": {
                        "type": "personal",
                        "name": c.text,
                        "identifiers": [],
                    },
                    "affiliations": [],
                }
            )
        # TODO: given name and family name???
        # TODO: Affiliation???
        for o in _getnodes(v, "contributor"):
            newrec["metadata"]["contributors"].append(
                {
                    "person_or_org": {
                        "type": "personal",
                        "name": o.text,
                        "identifiers": [],
                    },
                    "affiliations": [],
                }
            )

        newrec["metadata"]["description"] = _getnode(v, "description")
        for s in _getnodes(v, "subject"):
            newrec["metadata"]["subjects"].append(
                {"subject": s.text, "scheme": "fast"}
            )
        # TODO: put this in pids?
        main_pid = _getnode(v, "pid")
        newrec["metadata"]["identifiers"].append(
            {"identifier": main_pid, "scheme": "hc"}
        )
        # Checks to ensure EDTF Level 0 format
        pubDate = _getnode(v, "date")
        newrec["metadata"]["publication_date"] = pubDate
        try:
            assert valid_date(pubDate)
        except AssertionError:
            print("could not validate pubDate:", pubDate, f"({main_pid})")

        for i in _getnodes(v, "identifier"):
            if i.text != main_pid:
                aggregator_pid = i.text
                newrec["metadata"]["identifiers"].append(
                    {"identifier": i.text, "scheme": "hc-aggregator"}
                )
        if _getnode(v, "rights") == None:
            newrec["metadata"]["rights"].append(
                {
                    "id": "cc-by-4.0",
                    "description": {
                        "en": (
                            "The Creative Commons Attribution "
                            "license allows re-distribution and re-use of "
                            "a licensed work on the condition that the "
                            "creator is appropriately credited."
                        )
                    },
                    "link": "https://creativecommons.org/licenses/by/4.0/",
                }
            )
        else:
            newrec["metadata"]["rights"].append({"id": _getnode(v, "rights")})

        if _getnode(v, "publisher"):
            newrec["metadata"]["publisher"] = _getnode(v, "publisher")
        if _getnode(v, "format"):
            newrec["metadata"]["formats"] = [_getnode(v, "format")]

        # TODO: format language???
        if _getnode(v, "language"):
            newrec["metadata"]["languages"].append(
                {"id": _getnode(v, "language")}
            )

        # CORE uses w3cdtf and Invenio requires edtf level 0
        # Ensure EDTF
        cDate = _getnode(v, "cDate")
        if cDate:
            newrec["metadata"]["dates"].append(
                {
                    "date": cDate,
                    "description": "record created",
                    "type": {
                        "id": "created",
                        "title": {"en": "Record created"},
                    },
                }
            )
        try:
            assert valid_date(cDate)
        except AssertionError:
            print("could not validate cDate:", cDate, f"({main_pid})")

        # Ensure EDTF
        mDate = _getnode(v, "mDate")
        if mDate:
            newrec["metadata"]["dates"].append(
                {
                    "date": mDate,
                    "description": "record last updated",
                    "type": {
                        "id": "updated",
                        "title": {"en": "Record updated"},
                    },
                }
            )
        try:
            assert valid_date(mDate)
        except AssertionError:
            print("could not validate cDate:", mDate, f"({main_pid})")

        # TODO: do we keep this AND mdate?
        dcmDate = _getnode(v, "dcmDate")
        if dcmDate:
            newrec["metadata"]["dates"].append(
                {
                    "date": dcmDate,
                    "description": "record last updated (dc)",
                    "type": {
                        "id": "updated",
                        "title": {"en": "Record updated (dc)"},
                    },
                }
            )
            assert valid_date(dcmDate)

        filename = _getnode(v, "label")
        newrec["files"]["entries"].append(
            {
                f"{filename}": {
                    "key": filename,
                    "mimetype": _getnode(v, "format"),
                }
            }
        )

        # TODO: ownerId???
        # TODO: CORE tags?
        # TODO: CORE url?
        # TODO: CORE issn?
        # TODO: CORE notes?

        # TODO: CORE 'source', 'relation', 'coverage',

        # TODO: CORE 'state',

        # Retrieve data not available via Fedora api
        fedora_desc_url = f"https://comcore.devel.lib.msu.edu/fedora/objects/{aggregator_pid}/datastreams/descMetadata/content?format=xml"
        ag_result = requests.get(
            fedora_desc_url, auth=(FEDORA_USER, FEDORA_PASSWORD)
        )

        # print(r.status_code)
        # print(r.headers)
        if ag_result.status_code != 200:
            print("Failed to retrieve descMetadata for", aggregator_pid)
        # print(r.encoding)
        # print(ag_result.text)
        # print(ag_result.content)
        mods_prefix = "{http://www.loc.gov/mods/v3}"
        ag_root = ET.fromstring(ag_result.text)

        # TODO: can <name> also be contributor?
        # FIXME: Some names given erroneous @type of "personal":
        # e.g., hc:38793-4
        for name in ag_root.findall(f"{mods_prefix}name"):
            gname = name.find(f'{mods_prefix}namePart[@type="given"]')
            fname = name.find(f'{mods_prefix}namePart[@type="family"]')
            if fname is not None:
                myName = gname.text + " " + fname.text
                print("myName", myName)
                n = [
                    n
                    for n in newrec["metadata"]["creators"]
                    if n["person_or_org"]["name"] == myName
                ][0]
                n["person_or_org"]["given_name"] = gname.text
                n["person_or_org"]["family_name"] = fname.text
                # TODO: what is organizational type called?
                # assume everyone is personal otherwise?
                if name.get("type") not in ["personal", None]:
                    print("name type is:", name.get("type"))
                t = name.get("type") if name.get("type") else "personal"
                n["person_or_org"]["type"] = t
                # TODO: get ORCID identifiers?
                # TODO: am I right that the ID here is the hc user id?
                if name.get("ID"):
                    n["person_or_org"]["identifiers"].append(
                        {"scheme": "hc", "identifier": name.get("ID")}
                    )
                if name.find(f"{mods_prefix}role/roleTerm") is not None:
                    n["role"] = name.find(f"{mods_prefix}role/roleTerm")
                # Invenio only allows affiliations for persons
                if (
                    n["person_or_org"]["type"] == "personal"
                    and name.find(f"{mods_prefix}affiliation") is not None
                ):
                    n["affiliations"].append(
                        {"name": name.find(f"{mods_prefix}affiliation").text}
                    )
                    # should we try to add 'id' for org from ROR?
        lang = ag_root.find(f"{mods_prefix}language")
        if newrec["metadata"]["languages"] == [] and lang is not None:
            newrec["metadata"]["languages"].append(
                {"id": lang.find(f"{mods_prefix}languageTerm").text}
            )

        records.append(newrec)

    pprint(records)
    # newrec['status'] =

    # pprint(records)

    return records
