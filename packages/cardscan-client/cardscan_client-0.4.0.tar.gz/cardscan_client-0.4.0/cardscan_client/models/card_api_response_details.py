# coding: utf-8

"""
    CardScan API

    The official documentation for the CardScan API.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import BaseModel, conlist
from cardscan_client.models.match_score import MatchScore

class CardApiResponseDetails(BaseModel):
    """
    CardApiResponseDetails
    """
    group_number: Optional[MatchScore] = None
    member_number: Optional[MatchScore] = None
    payer_name: Optional[MatchScore] = None
    rx_bin: Optional[MatchScore] = None
    rx_pcn: Optional[MatchScore] = None
    member_name: Optional[MatchScore] = None
    dependent_names: Optional[conlist(MatchScore)] = None
    plan_name: Optional[MatchScore] = None
    plan_id: Optional[MatchScore] = None
    card_specific_id: Optional[MatchScore] = None
    __properties = ["group_number", "member_number", "payer_name", "rx_bin", "rx_pcn", "member_name", "dependent_names", "plan_name", "plan_id", "card_specific_id"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> CardApiResponseDetails:
        """Create an instance of CardApiResponseDetails from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of group_number
        if self.group_number:
            _dict['group_number'] = self.group_number.to_dict()
        # override the default output from pydantic by calling `to_dict()` of member_number
        if self.member_number:
            _dict['member_number'] = self.member_number.to_dict()
        # override the default output from pydantic by calling `to_dict()` of payer_name
        if self.payer_name:
            _dict['payer_name'] = self.payer_name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of rx_bin
        if self.rx_bin:
            _dict['rx_bin'] = self.rx_bin.to_dict()
        # override the default output from pydantic by calling `to_dict()` of rx_pcn
        if self.rx_pcn:
            _dict['rx_pcn'] = self.rx_pcn.to_dict()
        # override the default output from pydantic by calling `to_dict()` of member_name
        if self.member_name:
            _dict['member_name'] = self.member_name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in dependent_names (list)
        _items = []
        if self.dependent_names:
            for _item in self.dependent_names:
                if _item:
                    _items.append(_item.to_dict())
            _dict['dependent_names'] = _items
        # override the default output from pydantic by calling `to_dict()` of plan_name
        if self.plan_name:
            _dict['plan_name'] = self.plan_name.to_dict()
        # override the default output from pydantic by calling `to_dict()` of plan_id
        if self.plan_id:
            _dict['plan_id'] = self.plan_id.to_dict()
        # override the default output from pydantic by calling `to_dict()` of card_specific_id
        if self.card_specific_id:
            _dict['card_specific_id'] = self.card_specific_id.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> CardApiResponseDetails:
        """Create an instance of CardApiResponseDetails from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return CardApiResponseDetails.parse_obj(obj)

        _obj = CardApiResponseDetails.parse_obj({
            "group_number": MatchScore.from_dict(obj.get("group_number")) if obj.get("group_number") is not None else None,
            "member_number": MatchScore.from_dict(obj.get("member_number")) if obj.get("member_number") is not None else None,
            "payer_name": MatchScore.from_dict(obj.get("payer_name")) if obj.get("payer_name") is not None else None,
            "rx_bin": MatchScore.from_dict(obj.get("rx_bin")) if obj.get("rx_bin") is not None else None,
            "rx_pcn": MatchScore.from_dict(obj.get("rx_pcn")) if obj.get("rx_pcn") is not None else None,
            "member_name": MatchScore.from_dict(obj.get("member_name")) if obj.get("member_name") is not None else None,
            "dependent_names": [MatchScore.from_dict(_item) for _item in obj.get("dependent_names")] if obj.get("dependent_names") is not None else None,
            "plan_name": MatchScore.from_dict(obj.get("plan_name")) if obj.get("plan_name") is not None else None,
            "plan_id": MatchScore.from_dict(obj.get("plan_id")) if obj.get("plan_id") is not None else None,
            "card_specific_id": MatchScore.from_dict(obj.get("card_specific_id")) if obj.get("card_specific_id") is not None else None
        })
        return _obj


