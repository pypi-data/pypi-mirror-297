"""Autogenerated API"""
from argus_api.session import get_session
from typing import TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from argus_api.session import ArgusAPISession
from requests import Response


def get_event(
    timestamp: int,
    customerID: int,
    eventID: str,
    includeProperties: str = None,
    includeAllProperties: bool = None,
    includeComments: bool = None,
    includeSubEvents: bool = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Fetches corresponding event (DEV)
    
    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Event ID
    :param list includeProperties: Which properties to include in the response \(if includeAllProperties\=false\)
    :param bool includeAllProperties: Whether to include all properties
    :param bool includeComments: Whether to include comments
    :param bool includeSubEvents: Whether to include sub\-event IDs
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/{timestamp}/{customerID}/{eventID}".format(timestamp=timestamp,
        customerID=customerID,
        eventID=eventID,
        includeAllProperties=includeAllProperties,
        includeComments=includeComments,
        includeSubEvents=includeSubEvents,
        includeProperties=includeProperties)

    session = api_session or get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send includeAllProperties if the argument was provided, don't send null values
    if includeAllProperties is not None:
        query_parameters.update({"includeAllProperties": includeAllProperties})
    
    # Only send includeComments if the argument was provided, don't send null values
    if includeComments is not None:
        query_parameters.update({"includeComments": includeComments})
    
    # Only send includeSubEvents if the argument was provided, don't send null values
    if includeSubEvents is not None:
        query_parameters.update({"includeSubEvents": includeSubEvents})
    
    # Only send includeProperties if the argument was provided, don't send null values
    if includeProperties is not None:
        query_parameters.update({"includeProperties": includeProperties})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_event_compatibility(
    type: str,
    timestamp: int,
    customerID: int,
    eventID: str,
    includeProperties: str = None,
    includeAllProperties: bool = None,
    includeComments: bool = None,
    includeSubEvents: bool = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Fetches corresponding event (by compatibility path) (DEV)
    
    :param str type: Event type \(ignored\, provided for path compatibility\)
    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Event ID
    :param list includeProperties: Which properties to include in the response \(if includeAllProperties\=false\)
    :param bool includeAllProperties: Whether to include all properties
    :param bool includeComments: Whether to include comments
    :param bool includeSubEvents: Whether to include sub\-event IDs
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/{type}/{timestamp}/{customerID}/{eventID}".format(type=type,
        timestamp=timestamp,
        customerID=customerID,
        eventID=eventID,
        includeAllProperties=includeAllProperties,
        includeComments=includeComments,
        includeSubEvents=includeSubEvents,
        includeProperties=includeProperties)

    session = api_session or get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send includeAllProperties if the argument was provided, don't send null values
    if includeAllProperties is not None:
        query_parameters.update({"includeAllProperties": includeAllProperties})
    
    # Only send includeComments if the argument was provided, don't send null values
    if includeComments is not None:
        query_parameters.update({"includeComments": includeComments})
    
    # Only send includeSubEvents if the argument was provided, don't send null values
    if includeSubEvents is not None:
        query_parameters.update({"includeSubEvents": includeSubEvents})
    
    # Only send includeProperties if the argument was provided, don't send null values
    if includeProperties is not None:
        query_parameters.update({"includeProperties": includeProperties})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_event_statistics(
    subCriteria: dict = None,
    type: str = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    severity: str = None,
    eventIdentifier: str = None,
    customer: str = None,
    productionCustomers: bool = None,
    endpoint: dict = None,
    attack: dict = None,
    domain: str = None,
    includeFlag: str = None,
    excludeFlag: str = None,
    property: dict = None,
    associatedCaseID: int = None,
    groupBy: dict = None,
    timeline: dict = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Generate the requested statistics for events matching the provided search criteria. (DEV)
    
    :param list subCriteria: 
    :param list type: Restrict search to of events of this type. If nothing is specified we will return all types
    :param int startTimestamp: Restrict search to data after this time \(epoch millis\)
    :param int endTimestamp: Restrict search to data before this time \(epoch millis\)
    :param list timeFieldStrategy: Which time fields to search for
    :param str timeMatchStrategy: Which time match strategy to use. Defaults to matching if any \(default any\)
    :param list severity: Which severities to search for
    :param list eventIdentifier: Which event identifiers to search for
    :param list customer: Which customers to search for events for. Search by id or short name
    :param bool productionCustomers: Restricts the search to customers that either are\, or are not in production.
If null we don\'t filter \(default\)
If true we only return production customers
If false\, we exclude all production customers

    :param list endpoint: Restrict search to events with endpoints matching these criteria
These criteria follow sub request logic\, which means that they are by default OR\-ed together\,
but will be AND\-ed together if you set required\=true.
You can also use exclude\=true to match on the negation of the query

    :param list attack: Restrict search to events matching these attack criteria.
These criteria follow sub request logic\, which means that they are by default OR\-ed together\,
but will be AND\-ed together if you set required\=true.
You can also use exclude\=true to match on the negation of the query

    :param list domain: Restrict search to events with one of these domains set
    :param list includeFlag: Restrict search to events with ALL of these flags set
    :param list excludeFlag: Restrict search to events with NONE of these flags set
    :param list property: Restrict search to events with properties matching these criteria.
These criteria follow sub request logic\, which means that they are by default OR\-ed together\,
but will be AND\-ed together if you set required\=true.
You can also use exclude\=true to match on the negation of the query.

    :param list associatedCaseID: Restrict search to events associated to cases with these IDs.
NOTE\: Searching for ID 0 will return events that are not associated to any cases.

    :param list groupBy: The list of fields to group by
The order in the list will determine the hierarchy of the aggregations and their buckets.

    :param list timeline: The set of time range metrics used to create histogram buckets

    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/statistics".format()

    session = api_session or get_session()
    headers = {}

    body = body or {}
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send eventIdentifier if the argument was provided, don't send null values
    if eventIdentifier is not None:
        body.update({"eventIdentifier": eventIdentifier})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send productionCustomers if the argument was provided, don't send null values
    if productionCustomers is not None:
        body.update({"productionCustomers": productionCustomers})
    # Only send endpoint if the argument was provided, don't send null values
    if endpoint is not None:
        body.update({"endpoint": endpoint})
    # Only send attack if the argument was provided, don't send null values
    if attack is not None:
        body.update({"attack": attack})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send includeFlag if the argument was provided, don't send null values
    if includeFlag is not None:
        body.update({"includeFlag": includeFlag})
    # Only send excludeFlag if the argument was provided, don't send null values
    if excludeFlag is not None:
        body.update({"excludeFlag": excludeFlag})
    # Only send property if the argument was provided, don't send null values
    if property is not None:
        body.update({"property": property})
    # Only send associatedCaseID if the argument was provided, don't send null values
    if associatedCaseID is not None:
        body.update({"associatedCaseID": associatedCaseID})
    # Only send groupBy if the argument was provided, don't send null values
    if groupBy is not None:
        body.update({"groupBy": groupBy})
    # Only send timeline if the argument was provided, don't send null values
    if timeline is not None:
        body.update({"timeline": timeline})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_payload(
    timestamp: int,
    customerID: int,
    eventID: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Fetch specified event payload (DEV)
    
    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Unique UUID for the event
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/{timestamp}/{customerID}/{eventID}/payload".format(timestamp=timestamp,
        customerID=customerID,
        eventID=eventID)

    session = api_session or get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_payload_compatibility(
    type: str,
    timestamp: int,
    customerID: int,
    eventID: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """  Fetch specified event payload. This variant accepts a type parameter which is not used
  but should make it easier to paste in AGGR-ids from the v1 api.
 (DEV)
    
    :param str type: Event type \(ignored\, provided for path compatibility\)
    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Unique UUID for the event
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/{type}/{timestamp}/{customerID}/{eventID}/payload".format(type=type,
        timestamp=timestamp,
        customerID=customerID,
        eventID=eventID)

    session = api_session or get_session()
    headers = {}

    body = body or {}

    query_parameters = {}

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_pcap(
    timestamp: int,
    customerID: int,
    eventID: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> Response:
    """Fetch specified event payload as PCAP (DEV)
    
    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Unique UUID for the event
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: ``requests.Response`` object
    
    """

    route = "/events/v2/event/{timestamp}/{customerID}/{eventID}/pcap".format(timestamp=timestamp,
        customerID=customerID,
        eventID=eventID)

    session = api_session or get_session()
    headers = {}
    headers['content'] = None

    body = body or {}

    query_parameters = {}

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response
    


def get_pcap_compatibility(
    type: str,
    timestamp: int,
    customerID: int,
    eventID: str,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> Response:
    """Fetch specified event payload as PCAP. This variant accepts a type parameter which is not used
but should make it easier to paste in AGGR-ids from the v1 api.
 (DEV)
    
    :param str type: Event type \(ignored\, provided for path compatibility\)
    :param int timestamp: Event timestamp
    :param int customerID: Customer ID
    :param str eventID: Unique UUID for the event
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: ``requests.Response`` object
    
    """

    route = "/events/v2/event/{type}/{timestamp}/{customerID}/{eventID}/pcap".format(type=type,
        timestamp=timestamp,
        customerID=customerID,
        eventID=eventID)

    session = api_session or get_session()
    headers = {}
    headers['content'] = None

    body = body or {}

    query_parameters = {}

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response
    


def list_events(
    type: str = None,
    customer: str = None,
    signature: str = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Simple search for events (DEV)
    
    :param list type: Limit to events of this type
    :param list customer: Limit to customer
    :param list signature: Limit to signature
    :param int startTimestamp: Only look for events after this timestamp
    :param int endTimestamp: Only look for events before this timestamp
    :param int limit: The max number of events to return
    :param int offset: The offset of the search
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/events/v2/event".format(limit=limit,
        type=type,
        customer=customer,
        signature=signature,
        startTimestamp=startTimestamp,
        endTimestamp=endTimestamp,
        offset=offset)

    session = api_session or get_session()
    headers = {}
    headers['content'] = None
    if json:
        headers['content'] = 'application/json'

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        query_parameters.update({"type": type})
    
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    # Only send signature if the argument was provided, don't send null values
    if signature is not None:
        query_parameters.update({"signature": signature})
    
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def reindex_events(
    eventID: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Reindexes a set of events into the search engine (INTERNAL)
    
    :param list eventID: The events that should be reindexed. The set should contain event IDs on the Argus EventID format\, e.g. AGGR\/10000\/1\/8bf1732c\-f845\-409a\-8425\-8fad3b5007ab.
If one of the IDs is malformed\, or does not match an event you have access to the request will fail.

    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/reindex".format()

    session = api_session or get_session()
    headers = {}

    body = body or {}
    # Only send eventID if the argument was provided, don't send null values
    if eventID is not None:
        body.update({"eventID": eventID})

    query_parameters = {}

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def search_events(
    subCriteria: dict = None,
    sortBy: str = None,
    type: str = None,
    startTimestamp: int = None,
    endTimestamp: int = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    severity: str = None,
    eventIdentifier: str = None,
    customer: str = None,
    productionCustomers: bool = None,
    endpoint: dict = None,
    attack: dict = None,
    domain: str = None,
    includeFlag: str = None,
    excludeFlag: str = None,
    property: dict = None,
    associatedCaseID: int = None,
    indexStartTimestamp: int = None,
    indexEndTimestamp: int = None,
    order: str = None,
    includeProperties: str = None,
    limit: int = 25,
    offset: int = None,
    includeAllProperties: bool = None,
    includeComments: bool = None,
    includeSubEvents: bool = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Searches for events (DEV)
    
    :param list subCriteria: 
    :param list sortBy: 
    :param list type: Restrict search to of events of this type. If nothing is specified we will return all types
    :param int startTimestamp: Restrict search to data after this time \(epoch millis\)
    :param int endTimestamp: Restrict search to data before this time \(epoch millis\)
    :param list timeFieldStrategy: Which time fields to search for
    :param str timeMatchStrategy: Which time match strategy to use. Defaults to matching if any \(default any\)
    :param list severity: Which severities to search for
    :param list eventIdentifier: Which event identifiers to search for
    :param list customer: Which customers to search for events for. Search by id or short name
    :param bool productionCustomers: Restricts the search to customers that either are\, or are not in production.
If null we don\'t filter \(default\)
If true we only return production customers
If false\, we exclude all production customers

    :param list endpoint: Restrict search to events with endpoints matching these criteria
These criteria follow sub request logic\, which means that they are by default OR\-ed together\,
but will be AND\-ed together if you set required\=true.
You can also use exclude\=true to match on the negation of the query

    :param list attack: Restrict search to events matching these attack criteria.
These criteria follow sub request logic\, which means that they are by default OR\-ed together\,
but will be AND\-ed together if you set required\=true.
You can also use exclude\=true to match on the negation of the query

    :param list domain: Restrict search to events with one of these domains set
    :param list includeFlag: Restrict search to events with ALL of these flags set
    :param list excludeFlag: Restrict search to events with NONE of these flags set
    :param list property: Restrict search to events with properties matching these criteria.
These criteria follow sub request logic\, which means that they are by default OR\-ed together\,
but will be AND\-ed together if you set required\=true.
You can also use exclude\=true to match on the negation of the query.

    :param list associatedCaseID: Restrict search to events associated to cases with these IDs.
NOTE\: Searching for ID 0 will return events that are not associated to any cases.

    :param int indexStartTimestamp: Only search in indexes after or on this day
    :param int indexEndTimestamp: Only search in indexes before or on this day
    :param list order: Which field\(s\) by which to sort the results
    :param list includeProperties: Which properties to include \(if includeAllProperties\=false\).
    :param int limit: Limit the results to the specified amount. If set to 0 we will stream all results matching the query \(default 25\)
    :param int offset: Skip specified amount of results \(default 0\)
    :param bool includeAllProperties: Whether to include all properties \(overrides the selection of \'includeProperties\' if set to true\). \(default false\)
    :param bool includeComments: Whether to include comments. \(default false\)
    :param bool includeSubEvents: Whether to include sub\-events\' IDs \(only for aggregated events\). \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/events/v2/event/search".format()

    session = api_session or get_session()
    headers = {}
    headers['content'] = None
    if json:
        headers['content'] = 'application/json'

    body = body or {}
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send eventIdentifier if the argument was provided, don't send null values
    if eventIdentifier is not None:
        body.update({"eventIdentifier": eventIdentifier})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send productionCustomers if the argument was provided, don't send null values
    if productionCustomers is not None:
        body.update({"productionCustomers": productionCustomers})
    # Only send endpoint if the argument was provided, don't send null values
    if endpoint is not None:
        body.update({"endpoint": endpoint})
    # Only send attack if the argument was provided, don't send null values
    if attack is not None:
        body.update({"attack": attack})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send includeFlag if the argument was provided, don't send null values
    if includeFlag is not None:
        body.update({"includeFlag": includeFlag})
    # Only send excludeFlag if the argument was provided, don't send null values
    if excludeFlag is not None:
        body.update({"excludeFlag": excludeFlag})
    # Only send property if the argument was provided, don't send null values
    if property is not None:
        body.update({"property": property})
    # Only send associatedCaseID if the argument was provided, don't send null values
    if associatedCaseID is not None:
        body.update({"associatedCaseID": associatedCaseID})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send indexStartTimestamp if the argument was provided, don't send null values
    if indexStartTimestamp is not None:
        body.update({"indexStartTimestamp": indexStartTimestamp})
    # Only send indexEndTimestamp if the argument was provided, don't send null values
    if indexEndTimestamp is not None:
        body.update({"indexEndTimestamp": indexEndTimestamp})
    # Only send order if the argument was provided, don't send null values
    if order is not None:
        body.update({"order": order})
    # Only send includeAllProperties if the argument was provided, don't send null values
    if includeAllProperties is not None:
        body.update({"includeAllProperties": includeAllProperties})
    # Only send includeComments if the argument was provided, don't send null values
    if includeComments is not None:
        body.update({"includeComments": includeComments})
    # Only send includeSubEvents if the argument was provided, don't send null values
    if includeSubEvents is not None:
        body.update({"includeSubEvents": includeSubEvents})
    # Only send includeProperties if the argument was provided, don't send null values
    if includeProperties is not None:
        body.update({"includeProperties": includeProperties})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def submit_events(
    startTimestamp: int = None,
    endTimestamp: int = None,
    id: dict = None,
    signature: str = None,
    severity: str = None,
    count: int = None,
    location: str = None,
    protocol: str = None,
    source: dict = None,
    destination: dict = None,
    flags: str = None,
    properties: dict = None,
    subEvents: str = None,
    uri: str = None,
    fqdn: str = None,
    aggregationKey: str = None,
    associatedCaseID: int = None,
    associatedCaseIDs: int = None,
    payload: dict = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Submit event to central storage. (INTERNAL)
    
    :param int startTimestamp: 
    :param int endTimestamp: 
    :param dict id: 
    :param str signature: Event signature. If set\, the system will automatically assign alarm and attack category based on this value.
    :param str severity: Event severity. When creating a new event\, the default severity is low.
    :param int count: Number of occurrences this event represents. The value must be at least 1\, which is the default.
    :param str location: The sensor location \(id or shortname\) where this event was observed. If set\, this location must be resolvable for the current user\, and must either belong to the same customer as this event\, or be a global location.
    :param str protocol: The protocol id or well\-known name. Numeric protocol ID must be between 0 and 255. Protocol name must be well known \(icmp\, tcp\, udp\, esp\, ah\)
    :param dict source: 
    :param dict destination: 
    :param list flags: Event flags requested by the client for this event. On updating an existing event\, existing flags will be retained\, and flags in the update will be added. Flags that have a PARTIAL flag have custom handling. If FINALIZED flag is set\, additional updates to this event will be ignored.
    :param dict properties: Custom properties for this event. Each property key may have multiple values.
On updating an existing event\, setting an existing property will overwrite existing value.

The max length of property keys is 50 characters. Keys longer than that will be truncated to the first 50.
If there are duplicate keys\, one will overwrite the other.
This will also happen if there are duplicates after truncation.

The max length of property values are 1024 characters for each value.
Any value longer than this will be truncated to 1024 characters.

    :param list subEvents: IDs \(on form TYPE\/timestamp\/customer\/UUID\) for subevents to this event. Subevents may not be stored yet. System will validate that all subevents have the same customer as this event.
    :param str uri: URI observed in this event.
    :param str fqdn: FQDN \(fqdn\) observed in this event.
    :param str aggregationKey: Client specified aggregation key for this event.
    :param int associatedCaseID: Associated case ID. If set\, the associated case must be readable for the current user\, and must belong to the same customer as this event.
    :param list associatedCaseIDs: Add one or more case associations to an event\, not required. If set\, the associated case must be readable for the current user\, and must belong to the same customer as this event.
    :param dict payload: 
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event".format()

    session = api_session or get_session()
    headers = {}

    body = body or {}
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send id if the argument was provided, don't send null values
    if id is not None:
        body.update({"id": id})
    # Only send signature if the argument was provided, don't send null values
    if signature is not None:
        body.update({"signature": signature})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send count if the argument was provided, don't send null values
    if count is not None:
        body.update({"count": count})
    # Only send location if the argument was provided, don't send null values
    if location is not None:
        body.update({"location": location})
    # Only send protocol if the argument was provided, don't send null values
    if protocol is not None:
        body.update({"protocol": protocol})
    # Only send source if the argument was provided, don't send null values
    if source is not None:
        body.update({"source": source})
    # Only send destination if the argument was provided, don't send null values
    if destination is not None:
        body.update({"destination": destination})
    # Only send flags if the argument was provided, don't send null values
    if flags is not None:
        body.update({"flags": flags})
    # Only send properties if the argument was provided, don't send null values
    if properties is not None:
        body.update({"properties": properties})
    # Only send subEvents if the argument was provided, don't send null values
    if subEvents is not None:
        body.update({"subEvents": subEvents})
    # Only send uri if the argument was provided, don't send null values
    if uri is not None:
        body.update({"uri": uri})
    # Only send fqdn if the argument was provided, don't send null values
    if fqdn is not None:
        body.update({"fqdn": fqdn})
    # Only send aggregationKey if the argument was provided, don't send null values
    if aggregationKey is not None:
        body.update({"aggregationKey": aggregationKey})
    # Only send associatedCaseID if the argument was provided, don't send null values
    if associatedCaseID is not None:
        body.update({"associatedCaseID": associatedCaseID})
    # Only send associatedCaseIDs if the argument was provided, don't send null values
    if associatedCaseIDs is not None:
        body.update({"associatedCaseIDs": associatedCaseIDs})
    # Only send payload if the argument was provided, don't send null values
    if payload is not None:
        body.update({"payload": payload})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def submit_events_bulk(
    events: dict = None,
    onError: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    """Submit a bulk of events to central storage. (INTERNAL)
    
    :param list events: Events to submit in this bulk.
    :param str onError: Define how validation errors on single events should be handled. Using mode dropInvalid\, invalid events will be ignored and reported in the response. The default mode is rejectAll\, which will cause a 412 error on the entire request on a valiation failure for any event.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/events/v2/event/bulk".format()

    session = api_session or get_session()
    headers = {}

    body = body or {}
    # Only send events if the argument was provided, don't send null values
    if events is not None:
        body.update({"events": events})
    # Only send onError if the argument was provided, don't send null values
    if onError is not None:
        body.update({"onError": onError})

    query_parameters = {}

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
